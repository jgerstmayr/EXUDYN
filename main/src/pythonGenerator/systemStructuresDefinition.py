#autogenerated system data structures
#load this file into pythonAutoGenerateInterfaces.py (in same folder

#USAGE:
#  define a certain class with
#    class = [C++ class name]
#  define parameters per line, see pattern below, using types and flags
#  finally write:
#    writeFile=[C++ file name]
#
#text with "" may contain spaces and commas, etc; tabs will be erased
#
#[V|F[v]]: V...Value (=member variable), F...Function (access via member function); v ... virtual Function; VL ... linked variable: variable will be linked, but is no member
#pythonName: name which is used in python
#cplusplusName: name which is used in C++ side of EXUDYN (leave empty if it is the same)
#size = leave empty if size is variable; e.g. 3 (size of vector), 2x3 (2 rows, 3 columns)  %used for vectors and matrices only!
#type = Bool, Int, Real, UInt, UReal, Vector, Matrix, SymmetricMatrix
#defaultValue = default value or string (use "" to clearly identify strings incl. spaces); for 'V'-types: default initialization; vor 'F' and 'F'-types: C++ code of function;
#cFlags = A...add access functions (e.g. const Real&/Real&), S...substructure (e.g. Newton), V... return value policy copy, O...move return policy, G... add args for pybind, R(read only), M(modifiableDuringSimulation), C...const function, D...definition only (implementation in separate file), P ... write Pybind11 interface [default is read/write access and that changes are immediately applied and need no reset of the system]
#parameterDescription = description for parameter used in C++ code

# classDescription = "parameters for CSystem"
# class = System2
# latexText = ""        #text, which will be added before the class description (e.g., to start a new section)
# addConstructor = "",   #code added to default constructor
# addDictionaryAccess #add access function to export/import data to/from dictionary (with type information)
# linkedClass= "",       #member variable (representing a class) to which this object is linked
#V|F, pythonName, cplusplusName (or empty if same), size, type, defaultValue,args, cflags, parameterDescription
# name, 	 	 , 0 	,	String, "empty", , "this is a description,	using	comma"
# name2, , 0,Real, 12, , "this is a Real"
# writeFile=test.h


#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SolutionSettings
#appendToFile=True #not done in first class
writePybindIncludes = True
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsection{Simulation settings}\nThis section includes hierarchical structures for simulation settings, e.g., time integration, static solver, Newton iteration and solution file export.\n"
classDescription = "General settings for exporting the solution (results) of a simulation."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args,cFlags, parameterDescription
V,  writeSolutionToFile,			,    , bool, 						   true,      ,      P		, "flag (true/false), which determines if (global) solution vector is written to file"
V,  appendToFile,			        ,  	, bool, 					   false,     ,      P	  , "flag (true/false); if true, solution is appended to existing file (otherwise created)"
V,  writeFileHeader,			     ,  	, bool, 						true,      ,      P	  , "flag (true/false); if true, file header is written (turn off, e.g. for multiple runs of time integration)"
V,  writeFileFooter,			     ,  	, bool, 						true,      ,      P	  , "flag (true/false); if true, information at end of simulation is written: convergence, total solution time, statistics"
V,  solutionWritePeriod,			,  	, UReal, 						0.01,  		,      P     , "time span (period), determines how often the solution is written during a simulation"
#
V,  sensorsAppendToFile,	     ,    , bool, 						   false,  	,      P     , "flag (true/false); if true, sensor output is appended to existing file (otherwise created)"
V,  sensorsWriteFileHeader,     ,  	, bool, 						true,      ,      P	  , "flag (true/false); if true, file header is written for sensor output (turn off, e.g. for multiple runs of time integration)"
V,  sensorsWritePeriod,			   ,  	, UReal, 						0.01,  		,      P     , "time span (period), determines how often the sensor output is written during a simulation"
#
V,  exportVelocities,			     ,    , bool, 						   true,  		,      P     , "solution is written as displacements, velocities[, accelerations] [,algebraicCoordinates] [,DataCoordinates]"
V,  exportAccelerations,			,  	, bool, 						true,  		,      P     , "solution is written as displacements, [velocities,] accelerations [,algebraicCoordinates] [,DataCoordinates]"
V,  exportAlgebraicCoordinates,	,    , bool, 						   true,  		,      P     , "solution is written as displacements, [velocities,] [accelerations,], algebraicCoordinates (=Lagrange multipliers) [,DataCoordinates]"
V,  exportDataCoordinates,	     ,    , bool, 						   true,  		,      P     , "solution is written as displacements, [velocities,] [accelerations,] [,algebraicCoordinates (=Lagrange multipliers)] ,DataCoordinates"
V,  coordinatesSolutionFileName,, 	  , FileName,                "coordinatesSolution.txt", ,P		, "filename and (relative) path of solution file containing all coordinates versus time"
#
V,  solverInformationFileName,  , 	  , FileName,                "solverInformation.txt",   ,P		, "filename and (relative) path of text file showing detailed information during solving; detail level according to yourSolver.verboseModeFile"
V,  solutionInformation,	     ,    , String,                "",       ,      P	  , "special information added to header of solution file (e.g. parameters and settings, modes, ...)"
V,  outputPrecision,            , 	  , Index,                 10,       ,       P		, "precision for floating point numbers written to solution and sensor files"
V,  recordImagesInterval,       , 	  , Real,                  -1.,      ,       P    ,  "record frames (images) during solving: amount of time to wait until next image (frame) is recorded; set recordImages = -1. if no images shall be recorded; set, e.g., recordImages = 0.01 to record an image every 10 milliseconds (requires that the time steps / load steps are sufficiently small!); for file names, etc., see VisualizationSettings.exportImages"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = NumericalDifferentiationSettings
appendToFile=True
writePybindIncludes = True
classDescription = "Settings for numerical differentiation of a function (needed for computation of numerical jacobian e.g. in implizit integration); HOTINT1: relativeEpsilon * Maximum(minimumCoordinateSize, fabs(x(i)))."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,  relativeEpsilon,      ,  		     ,      UReal, 			   1e-7,        ,      P	 , "relative differentiation parameter epsilon; the numerical differentiation parameter $\varepsilon$ follows from the formula ($\varepsilon = \varepsilon_\mathrm{relative}*max(q_{min}, |q_i + [q^{Ref}_i]|)$, with $\varepsilon_\mathrm{relative}$=relativeEpsilon, $q_{min} = $minimumCoordinateSize, $q_i$ is the current coordinate which is differentiated, and $qRef_i$ is the reference coordinate of the current coordinate"
V,  minimumCoordinateSize,,  		     ,      UReal, 			   1e-2,        ,      P	 , "minimum size of coordinates in relative differentiation parameter"
V,  doSystemWideDifferentiation,,    ,      bool, 			   false,          ,      P    , "true: system wide differentiation (e.g. all ODE2 equations w.r.t. all ODE2 coordinates); false: only local (object) differentiation"
V,  addReferenceCoordinatesToEpsilon,, ,    bool, 			   false,          ,      P    , "true: for the size estimation of the differentiation parameter, the reference coordinate $q^{Ref}_i$ is added to ODE2 coordinates --> see; false: only the current coordinate is used for size estimation of the differentiation parameter"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = NewtonSettings
appendToFile=True
writePybindIncludes = True
classDescription = "Settings for Newton method used in static or dynamic simulation."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,  numericalDifferentiation,, , NumericalDifferentiationSettings,      ,,        PS		, "numerical differentiation parameters for numerical jacobian (e.g. Newton in static solver or implicit time integration)"
V,  useNumericalDifferentiation, ,  	,      bool, 					   false,  , P		, "flag (true/false); false = perform direct computation of jacobian, true = use numerical differentiation for jacobian"
V,  useNewtonSolver,	       ,  		    ,     bool, 					true,   , P		, "flag (true/false); false = linear computation, true = use Newton solver for nonlinear solution"
V,  relativeTolerance,      ,  		   ,      UReal, 					1e-8,   , P		, "relative tolerance of residual for Newton (general goal of Newton is to decrease the residual by this factor)"
V,  absoluteTolerance,      ,  		   ,      UReal, 					1e-10,  , P		, "absolute tolerance of residual for Newton (needed e.g. if residual is fulfilled right at beginning); condition: sqrt(q*q)/numberOfCoordinates <= absoluteTolerance"
V,  weightTolerancePerCoordinate,	,   ,     bool, 					false,  , P		, "flag (true/false); false = compute error as L2-Norm of residual; true = compute error as (L2-Norm of residual) / (sqrt(number of coordinates)), which can help to use common tolerance independent of system size"
V,  newtonResidualMode,	    ,  		    ,     Index, 					0,      , P		, "0 ... use residual for computation of error (standard); 1 ... use change of solution increment for error (set relTol and absTol to same values!) ==> may be advantageous if residual is zero, e.g., in kinematic analysis; TAKE CARE with this flag"
V,  adaptInitialResidual,	,         ,       bool, 					true,   ,P		, "flag (true/false); false = standard; true: if initialResidual is very small (or zero), it may increas dramatically in first step; to achieve relativeTolerance, the initialResidual will by updated by a higher residual within the first Newton iteration"
#
V,  modifiedNewtonContractivity, ,  	 ,     UReal, 				    0.5,   ,P		, "maximum contractivity (=reduction of error in every Newton iteration) accepted by modified Newton; if contractivity is greater, a Jacobian update is computed"
V,  useModifiedNewton,	     ,  		 ,     bool, 					false,   ,P		, "true: compute Jacobian only at first step; no Jacobian updates per step; false: Jacobian computed in every step"
V,  modifiedNewtonJacUpdatePerStep, ,  ,    bool, 					false,   ,P		, "true: compute Jacobian at every time step, but not in every iteration (except for bad convergence ==> switch to full Newton)"
V,  maxIterations,	           ,  		 ,     Index, 					25,    ,  P		, "maximum number of iterations (including modified + restart Newton steps); after that iterations, the static/dynamic solver stops with error"
V,  maxModifiedNewtonIterations,,     ,     Index, 					8,     , P		, "maximum number of iterations for modified Newton (without Jacobian update); after that number of iterations, the modified Newton method gets a jacobian update and is further iterated"
V,  maxModifiedNewtonRestartIterations, , , Index, 					7,     , P		, "maximum number of iterations for modified Newton after aJacobian update; after that number of iterations, the full Newton method is started for this step"
V,  maximumSolutionNorm,	  ,  		 ,       UReal, 					1e38,  ,  P		, "this is the maximum allowed value for solutionU.L2NormSquared() which is the square of the square norm (value=$u_1^2$+$u_2^2$+...), and solutionV/A...; if the norm of solution vectors are larger, Newton method is stopped; the default value is chosen such that it would still work for single precision numbers (float)"
#discontinuous iteration -> does not really belong to Newton, but is a kind of extension
V,  maxDiscontinuousIterations,	,  	 ,     Index, 					5,     , P		, "maximum number of discontinuous (post Newton) iterations"
V,  ignoreMaxDiscontinuousIterations,	,,     bool, 					true,     , P		, "continue solver if maximum number of discontinuous (post Newton) iterations is reached (ignore tolerance)"
V,  discontinuousIterationTolerance,  , ,    UReal, 					1,     ,  P		, "absolute tolerance for discontinuous (post Newton) iterations; the errors represent absolute residuals and can be quite high"
#
V,  stepInformation,	       ,  	    ,       Index, 			      2  ,   ,  P, "0 ... only current step time, 1 ... show time to go, 2 ... show newton iterations (Nit) per step, 3 ... show discontinuous iterations (Dit) and newton jacobians (jac) per step"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = GeneralizedAlphaSettings
appendToFile=True
writePybindIncludes = True
classDescription = "Settings for generalized-alpha, implicit trapezoidal or Newmark time integration methods."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,  newmarkBeta,	         ,  		      ,     UReal, 				0.25,   , P		, "value beta for Newmark method; default value beta = $\frac 1 4$ corresponds to (undamped) trapezoidal rule"
V,  newmarkGamma,	         ,  		      ,     UReal, 				0.5,    , P		, "value gamma for Newmark method; default value gamma = $\frac 1 2$ corresponds to (undamped) trapezoidal rule"
V,  useIndex2Constraints,	 ,  		      ,     bool, 				  false,   , P		, "set useIndex2Constraints = true in order to use index2 (velocity level constraints) formulation"
V,  useNewmark,	            ,  		      ,     bool, 				  false,   , P		, "if true, use Newmark method with beta and gamma instead of generalized-Alpha"
V,  spectralRadius,	       ,  		      ,     UReal, 				0.9,    , P		, "spectral radius for Generalized-alpha solver; set this value to 1 for no damping or to 0 < spectralRadius < 1 for damping of high-frequency dynamics; for position-level constraints (index 3), spectralRadius must be < 1"
V,  computeInitialAccelerations,	,     ,     bool, 				  true,    , P		, "true: compute initial accelerations from system EOM in acceleration form; NOTE that initial accelerations that are following from user functions in constraints are not considered for now! false: use zero accelerations"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = TimeIntegrationSettings
appendToFile=True
classDescription = "General parameters used in time integration; specific parameters are provided in the according solver settings, e.g. for generalizedAlpha."
writePybindIncludes = True
#V|F, pythonName, 		cplusplusName,   size,   type,		defaultValue,args,cFlags, parameterDescription
V,  newton,              ,     , NewtonSettings,         ,     ,   PS,      "parameters for Newton method; used for implicit time integration methods only"
V,  startTime,				 , 	 	, UReal, 			        0	, 	  ,   P, "start time of time integration (usually set to zero)"
V,  endTime,				    , 	 	, UReal, 			        1	, 		,  P, "end time of time integration"
V,  numberOfSteps,		    , 	 	, UInt, 			        100	, 	,	 P, "number of steps in time integration; stepsize is computed from (endTime-startTime)/numberOfSteps"
V,  adaptiveStep,			 , 	 	, bool, 			        true,   ,  P, "true: use step reduction if step fails; false: constant step size"
V,  minimumStepSize,	    ,  		, UReal, 		           1e-8,   ,  P, "lower limit of time step size, before integrator stops"
#
V,  verboseMode,	      ,  	  , Index, 			        0  ,    ,   P, "0 ... no output, 1 ... show short step information every 2 seconds (error), 2 ... show every step information, 3 ... show also solution vector, 4 ... show also mass matrix and jacobian (implicit methods), 5 ... show also Jacobian inverse (implicit methods)"
V,  verboseModeFile,	    ,  	  , Index, 			        0  ,    ,   P, "same behaviour as verboseMode, but outputs all solver information to file"
V,  generalizedAlpha,    ,     , GeneralizedAlphaSettings,  ,   ,   PS, "parameters for generalized-alpha, implicit trapezoidal rule or Newmark (options only apply for these methods)"
V,  preStepPyExecute,		 , 	 	, String, 			        ""	, 		,   P, "Python code to be executed prior to every step and after last step, e.g. for postprocessing"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = StaticSolverSettings
appendToFile=True
writePybindIncludes = True
classDescription = "Settings for static solver linear or nonlinear (Newton)."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,    newton,               ,           ,   NewtonSettings,         ,       ,PS   , "parameters for Newton method (e.g. in static solver or time integration)"
#
#not needed: V,  useLoadSteps,	         ,  		     ,      bool, 					false,   P		, "flag (true/false); false = 1 load step, true = use predefined (or adaptive) load steps"
V,  numberOfLoadSteps,      ,  		     ,      Index, 					1,       ,P		, "number of load steps; if numberOfLoadSteps=1, no load steps are used and full forces are applied at once"
V,  loadStepDuration,       ,  		     ,      UReal, 					1,       ,P		, "quasi-time for all load steps (added to current time in load steps)"
V,  loadStepStart,	         ,  		     ,      UReal, 					0,       ,P		, "a quasi time, which can be used for the output (first column) as well as for time-dependent forces; quasi-time is increased in every step i by loadStepDuration/numberOfLoadSteps; loadStepTime = loadStepStart + i*loadStepDuration/numberOfLoadSteps, but loadStepStart untouched ==> increment by user"
V,  loadStepGeometric,	    ,  		     ,      bool, 					  false,    ,P		, "if loadStepGeometric=false, the load steps are incremental (arithmetic series, e.g. 0.1,0.2,0.3,...); if true, the load steps are increased in a geometric series, e.g. for $n=8$ numberOfLoadSteps and $d = 1000$ loadStepGeometricRange, it follows: $1000^{1/8}/1000=0.00237$, $1000^{2/8}/1000=0.00562$, $1000^{3/8}/1000=0.0133$, ..., $1000^{7/8}/1000=0.422$, $1000^{8/8}/1000=1$"
V,  loadStepGeometricRange, ,  		     ,      UReal, 				1000,       ,P		, "if loadStepGeometric=true, the load steps are increased in a geometric series, see loadStepGeometric"
V,  useLoadFactor,          ,  		     ,      bool, 					  true,     ,P		, "true: compute a load factor $\in [0,1]$ from static step time; all loads are scaled by the load factor; false: loads are always scaled with 1 -- use this option if time dependent loads use a userFunction"
V,  stabilizerODE2term,     ,  		     ,      UReal, 				   0,       ,P		, "add mass-proportional stabilizer term in ODE2 part of jacobian for stabilization (scaled ), e.g. of badly conditioned problems; the diagnoal terms are scaled with $stabilizer = (1-loadStepFactor^2)$, and go to zero at the end of all load steps: $loadStepFactor=1$ -> $stabilizer = 0$"
V,  adaptiveStep,			    , 	 	     ,      bool, 			       true, 		 ,P, "true: use step reduction if step fails; false: fixed step size"
V,  minimumStepSize,	       ,  		     ,      UReal, 					1e-8,    ,P		, "lower limit of step size, before nonlinear solver stops"
#
V,  verboseMode,	         ,  		     ,      Index, 					1,       ,P		, "0 ... no output, 1 ... show errors and load steps, 2 ... show short Newton step information (error), 3 ... show also solution vector, 4 ... show also jacobian, 5 ... show also Jacobian inverse"
V,  verboseModeFile,	       ,  	        ,      Index, 			     0,       ,P, "same behaviour as verboseMode, but outputs all solver information to file"
V,  preStepPyExecute,		     , 	 	     ,      String, 			     ""	, 		 ,P, "Python code to be executed prior to every load step and after last step, e.g. for postprocessing"
#
writeFile=SimulationSettings.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SimulationSettings
appendToFile=True
addDictionaryAccess = True
writePybindIncludes = True
classDescription = "General Settings for simulation; according settings for solution and solvers are given in subitems of this structure"
#V|F, pythonName, 		             cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,  timeIntegration,                ,  		        , TimeIntegrationSettings, 	  , , PS		, "time integration parameters"
V,  solutionSettings,				       , 	 	        , SolutionSettings,  	          , , PS		, "settings for solution files"
V,  staticSolver,				         , 	 	        , StaticSolverSettings,  		  , , PS	   , "static solver parameters"
V,  linearSolverType,				       , 	 	        , LinearSolverType,    "LinearSolverType::EXUdense", , P	   , "selection of numerical linear solver: exu.LinearSolverType.EXUdense (dense matrix inverse), exu.LinearSolverType.EigenSparse (sparse matrix LU-factorization), ... (enumeration type)"
V,  cleanUpMemory,                  , 	           , bool,                false   , , P		, "true: solvers will free memory at exit (recommended for large systems); false: keep allocated memory for repeated computations to increase performance"
V,  displayStatistics,              , 	           , bool,                false   , , P		, "display general computation information at end of time step (steps, iterations, function calls, step rejections, ..."
V,  displayComputationTime,         , 	           , bool,                false   , , P		, "display computation time statistics at end of solving"
V,  pauseAfterEachStep,             ,  		        , bool, 	             false   , , P		, "pause after every time step or static load step(user press SPACE)"
V,  outputPrecision,                , 	           , Index,               6       , , P		, "precision for floating point numbers written to console; e.g. values written by solver"
V,  numberOfThreads,                , 	           , Index,               1       , , P		, "number of threads used for parallel computation (1 == scalar processing); not yet implemented (status: Nov 2019)"
#
writeFile=SimulationSettings.h





#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SolverContainer
appendToFile=False
classDescription = "Container for handling all different available solvers"
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,  solverRK1,						,  		, SolverRK1, 					, 		     ,     A, "first order Runge-Kutta solver (explicit Euler)"
V,  solverStatic,					,  		, SolverStatic, 				, 	     ,     A, "static (non-)linear solver; requires a statically solvable system"
V,  solverGeneralizedAlpha,,  		   , SolverGeneralizedAlpha, 	, 		  ,     A, "second order generalized-alpha, implicit trapezoidal rule or Newmark"
#
writeFile=SystemContainer.h

#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
class = SystemContainer
appendToFile=True
classDescription = "Container class for all several computable systems (with according AdminSystem); several CSystems could be used in parallel."
#V|F, pythonName, 		cplusplusName,   size, type,					defaultValue,args, cFlags, parameterDescription
V,   cSystems,			             ,  		, ResizableArray<CSystem*>, 	 , 	 ,      A, "contains one or a set of complete multibody/finite element systems"
#V,  visualizationSystem,			, 	 	, VisualizationSystem,  			,     , 		, "contains all linking to visualization"
V,   solvers,						        , 	 	  , SolverContainer,  			    , 	 ,      A, "contains a structure with all solver-relevant structures (dynamic, static, etc.)"
#
writeFile=SystemContainer.h








#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#VISUALIZATION
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class = VSettingsGeneral
appendToFile=False
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsection{Visualization settings}\nThis section includes hierarchical structures for visualization settings, e.g., drawing of nodes, bodies, connectors, loads and markers and furthermore openGL, window and save image options.\n"
writePybindIncludes = True
classDescription = "General settings for visualization."
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      graphicsUpdateInterval,         , 	             ,     float,        "0.1f",                 , P,      "interval of graphics update during simulation in seconds; 0.1 = 10 frames per second; low numbers might slow down computation speed"
V,      autoFitScene,                   , 	             ,     bool,         true,                   , P,      "automatically fit scene within first second after StartRenderer()"
V,      textSize,                       , 	             ,     float,        "12.f",                 , P,      "general text size if not overwritten"
V,      minSceneSize,                   , 	             ,     float,        "0.1f",                 , P,      "minimum scene size for initial scene size and for autoFitScene, to avoid division by zero; SET GREATER THAN ZERO"
V,      backgroundColor,                , 	             4,    Float4,       "Float4({1.f,1.f,1.f,1.f})", , P, "red, green, blue and alpha values for background of render window (white=[1,1,1,1]; black = [0,0,0,1])"
V,      coordinateSystemSize,           , 	             ,     float,        "0.4f",                 , P,      "size of coordinate system relative to screen"
V,      drawCoordinateSystem,           , 	             ,     bool,         true,                   , P,      "false = no coordinate system shown"
V,      showComputationInfo,            , 	             ,     bool,         true,                   , P,      "false = no info about computation (current time, solver, etc.) shown"
V,      pointSize,                      , 	             ,     float,        "0.01f",                , P,      "global point size (absolute)"
V,      circleTiling,                   , 	             ,     Index,        "16",                   , P,      "global number of segments for circles; if smaller than 2, 2 segments are used (flat)"
V,      cylinderTiling,                 , 	             ,     Index,        "16",                   , P,      "global number of segments for cylinders; if smaller than 2, 2 segments are used (flat)"
V,      sphereTiling,                   , 	             ,     Index,        "8",                    , P,      "global number of segments for spheres; if smaller than 2, 2 segments are used (flat)"
V,      axesTiling,                     , 	             ,     Index,        "12",                   , P,      "global number of segments for drawing axes cylinders and cones (reduce this number, e.g. to 4, if many axes are drawn)"
#
writeFile=VisualizationSettings.h

class = VSettingsWindow
appendToFile=True
writePybindIncludes = True
classDescription = "Window and interaction settings for visualization; handle changes with care, as they might lead to unexpected results or crashes."
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      renderWindowSize,               , 	             2,    Index2,       "Index2({1024,768})",   , P,      "initial size of OpenGL render window in pixel"
V,      startupTimeout,                 , 	             ,     Index,        "5000",                 , P,      "OpenGL render window startup timeout in ms (change might be necessary if CPU is very slow)"
V,      alwaysOnTop,                    , 	             ,     bool,         false,                  , P,      "true: OpenGL render window will be always on top of all other windows"
V,      maximize,                       , 	             ,     bool,         false,                  , P,      "true: OpenGL render window will be maximized at startup"
V,      showWindow,                     , 	             ,     bool,         true,                   , P,      "true: OpenGL render window is shown on startup; false: window will be iconified at startup (e.g. if you are starting multiple computations automatically)"
V,      keypressRotationStep,           , 	             ,     float,        "5.f",                  , P,      "rotation increment per keypress in degree (full rotation = 360 degree)"
V,      mouseMoveRotationFactor,        , 	             ,     float,        "1.f",                  , P,      "rotation increment per 1 pixel mouse movement in degree"
V,      keypressTranslationStep,        , 	             ,     float,        "0.1f",                 , P,      "translation increment per keypress relative to window size"
V,      zoomStepFactor,                 , 	             ,     float,        "1.15f",                , P,      "change of zoom per keypress (keypad +/-) or mouse wheel increment"
#
writeFile=VisualizationSettings.h

class = VSettingsOpenGL
appendToFile=True
writePybindIncludes = True
classDescription = "OpenGL settings for 2D and 2D rendering."
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      initialCenterPoint,             , 	             3,    Float3,       "Float3({0.f,0.f,0.f})",, P,      "centerpoint of scene (3D) at renderer startup; overwritten if autoFitScene = True"
V,      initialZoom,                    , 	             ,     float,        "1.f",                  , P,      "initial zoom of scene; overwritten/ignored if autoFitScene = True"
V,      initialMaxSceneSize,            , 	             ,     float,        "1.f",                  , P,      "initial maximum scene size (auto: diagonal of cube with maximum scene coordinates); used for 'zoom all' functionality and for visibility of objects; overwritten if autoFitScene = True"
V,      initialModelRotation,           , 	             3x3,    StdArray33F,    "EXUmath::Matrix3DFToStdArray33(Matrix3DF(3,3,{1.f,0.f,0.f, 0.f,1.f,0.f, 0.f,0.f,1.f}))",      , P,      "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]"
#V,      initialModelRotation,           , 	             9,    Matrix3DF,    "Matrix3DF(3,3,{1.f,0.f,0.f, 0.f,1.f,0.f, 0.f,0.f,1.f})",      , P,      "initial model rotation matrix for OpenGl; in python use e.g.: initialModelRotation=[[1,0,0],[0,1,0],[0,0,1]]"
# 
V,      multiSampling,                  , 	             1,    Index,        "1",                    , P,      "multi sampling turned off (<=1) or turned on to given values (2, 4, 8 or 16); increases the graphics buffers and might crash due to graphics card memory limitations; only works if supported by hardware; if it does not work, try to change 3D graphics hardware settings!"
V,      lineWidth,                      , 	             1,    float,        "1.f",                  , P,      "width of lines used for representation of lines, circles, points, etc."
V,      lineSmooth,                     , 	             1,    bool,         true,                   , P,      "draw lines smooth"
V,      textLineWidth,                  , 	             1,    float,        "1.f",                  , P,      "width of lines used for representation of text"
V,      textLineSmooth,                 , 	             1,    bool,         false,                  , P,      "draw lines for representation of text smooth"
V,      showFaces,                      , 	             1,    bool,         true,                   , P,      "show faces of triangles, etc.; using the options showFaces=false and showFaceEdges=true gives are wire frame representation"
V,      showFaceEdges,                  , 	             1,    bool,         false,                  , P,      "show edges of faces; using the options showFaces=false and showFaceEdges=true gives are wire frame representation"
#
V,      shadeModelSmooth,               , 	             1,    bool,         true,                   , P,      "true: turn on smoothing for shaders, which uses vertex normals to smooth surfaces"
V,      materialSpecular,               , 	             4,    Float4,       "Float4({1.f,1.f,1.f,1.f})",, P,"4f specular color of material"
V,      materialShininess,              , 	             1,    float,        "60.f",                 , P,      "shininess of material"
#
V,      enableLight0,                   , 	             1,    bool,         true,                   , P,      "turn on/off light0"
V,      light0position,                 , 	             4,    Float4,       "Float4({1.f,1.f,-10.f,0.f})",, P,      "4f position vector of GL light0; 4th value should be 0, otherwise the vector obtains a special interpretation, see opengl manuals"
V,      light0ambient,                  , 	             1,    float,        "0.25f",                , P,      "ambient value of GL light0"
V,      light0diffuse,                  , 	             1,    float,        "0.4f",                 , P,      "diffuse value of GL light0"
V,      light0specular,                 , 	             1,    float,        "0.4f",                 , P,      "specular value of GL light0"
V,      enableLight1,                   , 	             1,    bool,         true,                   , P,      "turn on/off light1"
V,      light1position,                 , 	             4,    Float4,       "Float4({0.f,3.f,2.f,0.f})",, P,      "4f position vector of GL light1; 4th value should be 0, otherwise the vector obtains a special interpretation, see opengl manuals"
V,      light1ambient,                  , 	             1,    float,        "0.25f",                , P,      "ambient value of GL light1"
V,      light1diffuse,                  , 	             1,    float,        "0.4f",                 , P,      "diffuse value of GL light1"
V,      light1specular,                 , 	             1,    float,        "0.f",                  , P,      "specular value of GL light1"
# debug:
V,      drawFaceNormals,                , 	             1,    bool,         false,                  , P,      "draws triangle normals, e.g. at center of triangles; used for debugging of faces"
V,      drawVertexNormals,              , 	             1,    bool,         false,                  , P,      "draws vertex normals; used for debugging"
V,      drawNormalsLength,              , 	             1,    float,        "0.1f",                 , P,      "length of normals; used for debugging"
#
writeFile=VisualizationSettings.h

class = VSettingsContour
appendToFile=True
writePybindIncludes = True
classDescription = "Settings for contour plots; use these options to visualize field data, such as displacements, stresses, strains, etc. for bodies, nodes and finite elements."
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      outputVariableComponent,        , 	             1,    Index,        "0",                    , P,      "select the component of the chosen output variable; e.g., for displacements, 3 components are available: 0 == x, 1 == y, 2 == z component; if this component is not available by certain objects or nodes, no value is drawn"
V,      outputVariable,                 , 	             ,     OutputVariableType,  "OutputVariableType::_None",  , P, "selected contour plot output variable type; select OutputVariableType.\_None to deactivate contour plotting."
V,      minValue,                       , 	             1,    float,        "0",                    , P,      "minimum value for contour plot; set manually, if automaticRange == False"
V,      maxValue,                       , 	             1,    float,        "1",                    , P,      "maximum value for contour plot; set manually, if automaticRange == False"
#V,      currentMinValue,                , 	             1,    float,        "0",                    , P,      "minimum value for contour plot; set manually, if automaticRange == False"
#V,      currentMaxValue,                , 	             1,    float,        "1",                    , P,      "maximum value for contour plot; set manually, if automaticRange == False"
V,      automaticRange,                 , 	             ,     bool,         true,                   , P,      "if true, the contour plot value range is chosen automatically to the maximum range"
V,      showColorBar,                   , 	             ,     bool,         true,                   , P,      "show the colour bar with minimum and maximum values for the contour plot"
V,      colorBarTiling,                 , 	             1,    Index,        "12",                   , P,      "number of tiles (segements) shown in the colorbar for the contour plot"
#
writeFile=VisualizationSettings.h

class = VSettingsExportImages
appendToFile=True
writePybindIncludes = True
classDescription = "Functionality to export images to files (.tga format) which can be used to create animations; to activate image recording during the solution process, set SolutionSettings.recordImagesInterval accordingly."
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      saveImageTimeOut,               , 	             ,     Index,        "5000",                 , P,      "timeout for safing a frame as image to disk; this is the amount of time waited for redrawing; increase for very complex scenes"
V,      saveImageFileName,              , 	             ,     FileName,       "images/frame",         , P,      "filename (without extension!) and (relative) path for image file(s) with consecutive numbering (e.g., frame0000.tga, frame0001.tga,...); folders must already exist!"
V,      saveImageFileCounter,           , 	             ,     Index,        0,                      , P,      "current value of the counter which is used to consecutively save frames (images) with consecutive numbers"
V,      saveImageSingleFile,            , 	             ,     bool,         false,                  , P,      "true: only save single files with given filename, not adding numbering; false: add numbering to files, see saveImageFileName"
#
writeFile=VisualizationSettings.h

class = VSettingsNodes
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for nodes."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                     , P,      "flag to decide, whether the nodes are shown"
V,      showNumbers,                , 	             ,     bool,         false,                    , P,      "flag to decide, whether the node number is shown"
V,      defaultSize,                , 	             ,     float,        "-1.f",                   , P,      "global node size; if -1.f, node size is relative to openGL.initialMaxSceneSize"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.2f,0.2f,1.f,1.f})",, P,    "default cRGB olor for nodes; 4th value is alpha-transparency"
V,      showNodalSlopes,            , 	             ,     Index,        false,                    , P,       "draw nodal slope vectors, e.g. in ANCF beam finite elements"
#
writeFile=VisualizationSettings.h


class = VSettingsBeams
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for beam finite elements."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      axialTiling,                , 	             ,     Index,         "8",                      , P,       "number of segments to discretise the beams axis"
#
writeFile=VisualizationSettings.h

class = VSettingsBodies
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for bodies."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                       , P,    "flag to decide, whether the bodies are shown"
V,      showNumbers,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether the body(=object) number is shown"
V,      defaultSize,                , 	             3,    Float3,       "Float3({1.f,1.f,1.f})",    , P,    "global body size of xyz-cube"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.2f,0.2f,1.f,1.f})",, P,    "default cRGB olor for bodies; 4th value is "
V,      beams,                      , 	             ,     VSettingsBeams,   ,                       , PS,    "visualization settings for beams (e.g. ANCFCable or other beam elements)"
#
writeFile=VisualizationSettings.h


class = VSettingsConnectors
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for connectors."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                       , P,    "flag to decide, whether the connectors are shown"
V,      showNumbers,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether the connector(=object) number is shown"
V,      showJointAxes,              , 	             ,     bool,         false,                      , P,    "flag to decide, whether contact joint axes of 3D joints are shown"
V,      jointAxesLength,            , 	             ,     float,        "0.2f",                     , P,    "global joint axes length"
V,      jointAxesRadius,            , 	             ,     float,        "0.02f",                    , P,    "global joint axes radius"
V,      showContact,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether contact points, lines, etc. are shown"
V,      defaultSize,                , 	             ,     float,        "0.1f",                       , P,    "global connector size; if -1.f, connector size is relative to maxSceneSize"
V,      contactPointsDefaultSize,   , 	             ,     float,        "0.02f",                      , P,    "global contact points size; if -1.f, connector size is relative to maxSceneSize"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.2f,0.2f,1.f,1.f})",, P,    "default cRGB olor for connectors; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h


class = VSettingsMarkers
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for markers."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                       , P,    "flag to decide, whether the markers are shown"
V,      showNumbers,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether the marker numbers are shown"
V,      defaultSize,                , 	             ,     float,        "-1.f",                     , P,    "global marker size; if -1.f, marker size is relative to maxSceneSize"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.1f,0.5f,0.1f,1.f})",, P,    "default cRGB olor for markers; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h


class = VSettingsLoads
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for loads."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                       , P,    "flag to decide, whether the loads are shown"
V,      showNumbers,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether the load numbers are shown"
V,      defaultSize,                , 	             ,     float,        "0.2f",                     , P,    "global load size; if -1.f, load size is relative to maxSceneSize"
V,      defaultRadius,              , 	             ,     float,        "0.005f",                   , P,    "global radius of load axis if drawn in 3D"
V,      fixedLoadSize,              , 	             ,     bool,         true,                       , P,    "if true, the load is drawn with a fixed vector length in direction of the load vector, independently of the load size"
V,      loadSizeFactor,             , 	             ,     float,        "0.1f",                     , P,    "if fixedLoadSize=false, then this scaling factor is used to draw the load vector"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.7f,0.1f,0.1f,1.f})",, P,    "default cRGB olor for loads; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h

class = VSettingsSensors
appendToFile=True
writePybindIncludes = True
classDescription = "Visualization settings for sensors."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,args,           cFlags, parameterDescription
V,      show,                       , 	             ,     bool,         true,                       , P,    "flag to decide, whether the sensors are shown"
V,      showNumbers,                , 	             ,     bool,         false,                      , P,    "flag to decide, whether the sensor numbers are shown"
V,      defaultSize,                , 	             ,     float,        "-1.f",                     , P,    "global sensor size; if -1.f, sensor size is relative to maxSceneSize"
V,      defaultColor,               , 	             4,    Float4,       "Float4({0.6f,0.6f,0.1f,1.f})",, P,    "default cRGB olor for sensors; 4th value is alpha-transparency"
#
writeFile=VisualizationSettings.h


#Visualization:General,Window(mouse move, zoom),OpenGL,System(Objects,Nodes,...),Text
class = VisualizationSettings
appendToFile=True
writePybindIncludes = True
addDictionaryAccess = True
classDescription = "Settings for visualization"
#V|F,   pythonName, 		          cplusplusName,      size, type,	     defaultValue,args,           cFlags, parameterDescription
V,      general,                    , 	             ,     VSettingsGeneral,  ,                 , PS,      "general visualization settings"
V,      window,                     , 	             ,     VSettingsWindow,   ,                 , PS,      "visualization window and interaction settings"
V,      openGL,                     , 	             ,     VSettingsOpenGL,   ,                 , PS,      "OpenGL rendering settings"
V,      contour,                    , 	             ,     VSettingsContour,  ,                 , PS,      "contour plot visualization settings"
V,      exportImages,               , 	             ,     VSettingsExportImages,,              , PS,      "settings for exporting (saving) images to files in order to create animations"
#
V,      nodes,                      , 	             ,     VSettingsNodes,    ,                 , PS,      "node visualization settings"
V,      bodies,                     , 	             ,     VSettingsBodies,   ,                 , PS,      "body visualization settings"
V,      connectors,                 , 	             ,     VSettingsConnectors,,                , PS,      "connector visualization settings"
V,      markers,                    , 	             ,     VSettingsMarkers,  ,                 , PS,      "marker visualization settings"
V,      loads,                      , 	             ,     VSettingsLoads,    ,                 , PS,      "load visualization settings"
V,      sensors,                    , 	             ,     VSettingsSensors,  ,                 , PS,      "sensor visualization settings"
#done in WriteToPybind function FL,      GetDictionaryWithTypeInformation,  ,        ,     py::dict,          ,                 , DP,      "access function to dictionary of settings hierarchical structure including type information"
#
writeFile=VisualizationSettings.h




#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#CSolver Structures
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class = CSolverTimer
appendToFile=False
writePybindIncludes = True
latexText = "\n%++++++++++++++++++++++++++++++++++++++\n\mysubsection{Solver substructures}\nThis section includes structures contained in the solver, which can be accessed via the python interface during solution or for building a customized solver in python.\n"
classDescription = "Structure for timing in solver. Each Real variable is used to measure the CPU time which certain parts of the solver need. This structure is only active if the code is not compiled with the __FAST_EXUDYN_LINALG option and if displayComputationTime is set True. Timings will only be filled, if useTimer is True."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      useTimer,                   , 	             ,     bool,         true,                   ,   P,    "flag to decide, whether the timer is used (true) or not"
V,      total,                      , 	             ,     Real,         0.,                     ,   P,    "total time measured between start and end of computation (static/dynamics)"
V,      factorization,              , 	             ,     Real,         0.,                     ,   P,    "solve or inverse"
V,      newtonIncrement,            , 	             ,     Real,         0.,                     ,   P,    "Jac$^{-1}$ * RHS; backsubstitution"
V,      integrationFormula,         , 	             ,     Real,         0.,                     ,   P,    "time spent for evaluation of integration formulas"
V,      ODE2RHS,                    , 	             ,     Real,         0.,                     ,   P,    "time for residual evaluation of ODE2 right-hand-side"
V,      AERHS,                      , 	             ,     Real,         0.,                     ,   P,    "time for residual evaluation of algebraic equations right-hand-side"
V,      totalJacobian,              , 	             ,     Real,         0.,                     ,   P,    "time for all jacobian computations"
V,      jacobianODE2,               , 	             ,     Real,         0.,                     ,   P,    "jacobian w.r.t. coordinates of ODE2 equations (not counted in sum)"
V,      jacobianODE2_t,             , 	             ,     Real,         0.,                     ,   P,    "jacobian w.r.t. coordinates\_t of ODE2 equations (not counted in sum)"
V,      jacobianAE,                 , 	             ,     Real,         0.,                     ,   P,    "jacobian of algebraic equations (not counted in sum)"
V,      massMatrix,                 , 	             ,     Real,         0.,                     ,   P,    "mass matrix computation"
V,      reactionForces,             , 	             ,     Real,         0.,                     ,   P,    "CqT * lambda"
V,      postNewton,                 , 	             ,     Real,         0.,                     ,   P,    "post newton step"
V,      writeSolution,              , 	             ,     Real,         0.,                     ,   P,    "time for writing solution"
V,      overhead,                   , 	             ,     Real,         0.,                     ,   P,    "overhead, such as initialization, copying and some matrix-vector multiplication"
V,      python,                     , 	             ,     Real,         0.,                     ,   P,    "time spent for python functions"
V,      visualization,              , 	             ,     Real,         0.,                     ,   P,    "time spent for visualization in computation thread"
F,      Reset,                      ,                ,     void,         "*this = CSolverTimer(); useTimer = useSolverTimer;", "bool useSolverTimer", P, "reset solver timings to initial state by assigning default values; useSolverTimer sets the useTimer flag"
F,      Sum,                        ,                ,     Real,         ,                       ,   CDPV,    "compute sum of all timers (except for those counted multiple, e.g., jacobians"
F,      StartTimer,                 ,                ,     void,         ,                       "Real& value",   DP,    "start timer function for a given variable; subtracts current CPU time from value"
F,      StopTimer,                  ,                ,     void,         ,                       "Real& value",   DP,    "stop timer function for a given variable; adds current CPU time to value"
F,      ToString,                   ,                ,     String,       ,                       ,   CDPV,    "converts the current timings to a string"
#
writeFile=CSolverStructures.h


class = SolverLocalData
appendToFile=True
writePybindIncludes = True
addConstructor = "    SetLinearSolverType(LinearSolverType::EXUdense); //for safety, data is linked initially\n"
classDescription = "Solver local data structure for solution vectors, system matrices and temporary vectors and data structures."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      nODE2,                      , 	             ,     Index,        0,                      ,   P,    "number of second order ordinary diff. eq. coordinates"
V,      nODE1,                      , 	             ,     Index,        0,                      ,   P,    "number of first order ordinary diff. eq. coordinates"
V,      nAE,                        , 	             ,     Index,        0,                      ,   P,    "number of algebraic coordinates"
V,      nData,                      , 	             ,     Index,        0,                      ,   P,    "number of data coordinates"
V,      nSys,                       , 	             ,     Index,        0,                      ,   P,    "number of system (unknown) coordinates = nODE2+nODE1+nAE"
V,      startAE,                    , 	             ,     Index,        0,                      ,   P,    "start of algebraic coordinates, but set to zero if nAE==0"
#
V,      systemJacobian,             , 	             ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse system jacobian"
V,      systemMassMatrix,           , 	             ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse system matrix"
V,      jacobianAE,                 , 	             ,     GeneralMatrix*, nullptr,             ,    ,    "link to dense or sparse algebraic equations jacobian"
#
V,      systemResidual,             , 	             ,     ResizableVector, ,                    ,   P,    "system residual vector (vectors will be linked to this vector!)"
V,      newtonSolution,             , 	             ,     ResizableVector, ,                    ,   P,    "Newton decrement (computed from residual and jacobian)"
V,      tempODE2,                   , 	             ,     ResizableVector, ,                    ,   P,    "temporary vector for ODE2 quantities; use in initial accelerations and during Newton"
V,      temp2ODE2,                  , 	             ,     ResizableVector, ,                    ,   P,    "second temporary vector for ODE2 quantities; use in static computation"
V,      tempODE2F0,                 , 	             ,     ResizableVector, ,                    ,   P,    "temporary vector for ODE2 Jacobian"
V,      tempODE2F1,                 , 	             ,     ResizableVector, ,                    ,   P,    "temporary vector for ODE2 Jacobian"
#
V,      startOfStepStateAAlgorithmic,, 	             ,     ResizableVector, ,                    ,   P,    "additional term needed for generalized alpha (startOfStep state)"
V,      aAlgorithmic,               , 	             ,     ResizableVector, ,                    ,   P,    "additional term needed for generalized alpha (current state)"
#
V,      tempCompData,               , 	             ,     TemporaryComputationData, ,           ,    ,    "temporary data used during item-related residual and jacobian computation; duplicated for parallel computation"
#private members:
Vp,     linearSolverType,           , 	             ,     LinearSolverType,,                    ,    ,    "contains linear solver type value; cannot be accessed directly, because a change requires new linking of system matrices"
#DENSE:
Vp,     systemJacobianDense,        , 	             ,     GeneralMatrixEXUdense,,               ,    ,    "dense system jacobian"
Vp,     systemMassMatrixDense,      , 	             ,     GeneralMatrixEXUdense,,               ,    ,    "dense mass matrix"
Vp,     jacobianAEdense,            , 	             ,     GeneralMatrixEXUdense,,               ,    ,    "dense AE jacobian"
#SPARSE:
Vp,     systemJacobianSparse,       , 	             ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse system jacobian"
Vp,     systemMassMatrixSparse,     , 	             ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse mass matrix"
Vp,     jacobianAEsparse,           , 	             ,     GeneralMatrixEigenSparse,,            ,    ,    "sparse AE jacobian"
#
#now done with addConstructor flag; F,      SolverLocalData,            ,                ,     ,             "SetLinearSolverType(LinearSolverType::EXUdense);", ,   P,  "for safety, data is linked immediately to dense matrices"
F,      CleanUpMemory,              ,                ,     void,         ,                       ,    DP,  "if desired, temporary data is cleaned up to safe memory"
F,      SetLinearSolverType,        ,                ,     void,         ,                       "LinearSolverType linearSolverType",   DP,  "set linear solver type and matrix version: links system matrices to according dense/sparse versions"
F,      GetLinearSolverType,        ,                ,     LinearSolverType, "return linearSolverType;", ,   CPV,  "return current linear solver type (dense/sparse)"
#
writeFile=CSolverStructures.h


class = SolverIterationData
appendToFile=True
writePybindIncludes = True
#classDescription = "test"
classDescription = "Solver internal structure for counters, steps, step size, time, etc.; solution vectors, residuals, etc. are SolverLocalData. The given default values are overwritten by the simulationSettings when initializing the solver."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      maxStepSize,                , 	             ,     Real,         0.,                     ,   P,    "constant or maximum stepSize"
V,      minStepSize,                , 	             ,     Real,         0.,                     ,   P,    "minimum stepSize for static/dynamic solver; only used, if adaptive step is activated"
V,      currentStepSize,            , 	             ,     Real,         0.,                     ,   P,    "stepSize of current step"
V,      numberOfSteps,              , 	             ,     Index,        0,                      ,   P,    "number of time steps (if fixed size); $n$"
V,      currentStepIndex,           , 	             ,     Index,        0,                      ,   P,    "current step index; $i$"
#
V,      adaptiveStep,               , 	             ,     bool,         true,                   ,   P,    "if true, the step size may be adaptively controlled"
#
V,      currentTime,                , 	             ,     Real,         0.,                     ,   P,    "holds the current simulation time, copy of state.current.time; interval is [startTime,tEnd]; in static solver, duration is loadStepDuration"
V,      startTime,                  , 	             ,     Real,         0.,                     ,   P,    "time at beginning of time integration"
V,      endTime,                    , 	             ,     Real,         0.,                     ,   P,    "end time of static/dynamic solver"
#
V,      discontinuousIteration,     , 	             ,     Index,        0,                      ,   P,    "number of current discontinuous iteration"
V,      newtonSteps,                , 	             ,     Index,        0,                      ,   P,    "number of current newton steps"
#
V,      newtonStepsCount,           , 	             ,     Index,        0,                      ,   P,    "count total Newton steps"
V,      newtonJacobiCount,          , 	             ,     Index,        0,                      ,   P,    "count total Newton jacobian computations"
V,      rejectedModifiedNewtonSteps,, 	             ,     Index,        0,                      ,   P,    "count the number of rejected modified Newton steps (switch to full Newton)"
V,      discontinuousIterationsCount,, 	             ,     Index,        0,                      ,   P,    "count total number of discontinuous iterations (min. 1 per step)"
#
F,      ToString,                   ,                ,     String,       ,                       ,   CDPV,  "convert iteration statistics to string; used for displayStatistics option"
#
writeFile=CSolverStructures.h


class = SolverConvergenceData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for convergence information: residua, iteration loop errors and error flags. For detailed behavior of these flags, visit the source code!"
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      stepReductionFailed,        , 	             ,     bool,         false,                       ,   P,    "true, if iterations over time/static steps failed (finally, cannot be recovered)"
V,      discontinuousIterationsFailed,,              ,     bool,         false,                       ,   P,    "true, if discontinuous iterations failed (may be recovered if adaptive step is active)"
V,      linearSolverFailed,         , 	             ,     bool,         false,                       ,   P,    "true, if linear solver failed to factorize"
V,      newtonConverged,            , 	             ,     bool,         false,                       ,   P,    "true, if Newton has (finally) converged"
V,      newtonSolutionDiverged,     , 	             ,     bool,         false,                       ,   P,    "true, if Newton diverged (may be recovered)"
V,      jacobianUpdateRequested,    , 	             ,     bool,         true,                        ,   P,    "true, if a jacobian update is requested in modified Newton (determined in previous step)"
V,      massMatrixNotInvertible,    , 	             ,     bool,         true,                        ,   P,    "true, if mass matrix is not invertable during initialization or solution (explicit solver)"
#RESIDUALS and ERRORS:
V,      discontinuousIterationError,, 	             ,     Real,         0.,                          ,   P,    "error of discontinuous iterations (contact, friction, ...) outside of Newton iteration"
V,      residual,                   , 	             ,     Real,         0.,                          ,   P,    "current Newton residual"
V,      lastResidual,               , 	             ,     Real,         0.,                          ,   P,    "last Newton residual to determine contractivity"
V,      contractivity,              , 	             ,     Real,         0.,                          ,   P,    "Newton contractivity = geometric decay of error in every step"
V,      errorCoordinateFactor,      , 	             ,     Real,         1.,                          ,   P,    "factor may include the number of system coordinates to reduce the residual"
#
F,      InitializeData,             ,                ,     void,         "*this = SolverConvergenceData();",,P, "initialize SolverConvergenceData by assigning default values"
#
writeFile=CSolverStructures.h


class = SolverOutputData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for output modes, output timers and counters."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      finishedSuccessfully,       , 	             ,     bool,         false,                  ,   P,    "flag is false until solver finshed successfully (can be used as external trigger)"
#write to file and console
V,      verboseMode,                , 	             ,     Index,        0,                      ,   P,    "this is a copy of the solvers verboseMode used for console output"
V,      verboseModeFile,            , 	             ,     Index,        0,                      ,   P,    "this is a copy of the solvers verboseModeFile used for file"
V,      writeToSolutionFile,        , 	             ,     bool,         false,                  ,   P,    "if false, no solution file is generated and no file is written"
V,      writeToSolverFile,          , 	             ,     bool,         false,                  ,   P,    "if false, no solver output file is generated and no file is written"
V,      sensorValuesTemp,           , 	             ,     ResizableVector, ,                    ,   P,    "temporary vector for per sensor values (overwritten for every sensor; usually contains last sensor)"
#simulation and CPU time of events:
V,      lastSolutionWritten,        , 	             ,     Real,         0.,                     ,   P,    "simulation time when last solution has been written"
V,      lastSensorsWritten,         , 	             ,     Real,         0.,                     ,   P,    "simulation time when last sensors have been written"
V,      lastImageRecorded,          , 	             ,     Real,         0.,                     ,   P,    "simulation time when last image has been recorded"
V,      cpuStartTime,               , 	             ,     Real,         0.,                     ,   P,    "CPU start time of computation (starts counting at computation of initial conditions)"
V,      cpuLastTimePrinted,         , 	             ,     Real,         0.,                     ,   P,    "CPU time when output has been printed last time"
#
F,      InitializeData,             ,                ,     void,         "*this = SolverOutputData();",,P, "initialize SolverOutputData by assigning default values"
#
writeFile=CSolverStructures.h

class = SolverFileData
appendToFile=True
writePybindIncludes = True
classDescription = "Solver internal structure for output files. This structure is not linked to pybind, because std::ofstream is not supported."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
V,      solutionFile,               , 	             ,     std::ofstream,,                       ,    ,    "solution file with coordinate data"
V,      solverFile,                 , 	             ,     std::ofstream,,                       ,    ,    "file with detailed solver information"
V,      sensorFileList,             , 	             ,     std::vector<std::ofstream*>,,         ,    ,    "files for sensor output; the ofstream list corresponds exactly to the sensors in the computationalSystem (i.e., sensorFileList[0] is the ofstream for sensor 0, etc.); file lists need to be closed and deleted at end of simulation!"
#
#F,      InitializeData,             ,                ,     void,         "*this = SolverOutputData();",,P, "initialize SolverOutputData by assigning default values"
#
writeFile=CSolverStructures.h

#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
# MAIN SOLVER interfaces
#+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

class = MainSolverStatic
parentClass="MainSolverBase"
appendToFile=False
writePybindIncludes = True
#linkedClass = "cSolver" #not needed any more
classDescription = "PyBind interface (trampoline) class for static solver. With this interface, the static solver and its substructures can be accessed via python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (performance much lower than internal solver) due to python interfaces, and should thus be used for small systems. To access the solver in python, write: \bi\n \item[] solver = MainSolverStatic() \n\ei\n and hereafter you can access all data and functions via 'solver'."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
VL,     timer,                    cSolver.timer , 	       ,     CSolverTimer,      ,                  ,   PS,    "timer which measures the CPU time of solver sub functions"
VL,     it,                       cSolver.it    , 	       ,     SolverIterationData, ,                ,   PS,    "all information about iterations (steps, discontinuous iteration, newton,...)"
VL,     conv,                     cSolver.conv  , 	       ,     SolverConvergenceData, ,              ,   PS,    "all information about tolerances, errors and residua"
VL,     output,                   cSolver.output, 	       ,     SolverOutputData,  ,                  ,   PS,    "output modes and timers for exporting solver information and solution"
VL,     newton,                   cSolver.newton, 	       ,     NewtonSettings,    ,                  ,   PS,    "copy of newton settings from timeint or staticSolver"
#these structures cannot be accessed directly via pybind:
#VL,     data,                        , 	             ,     SolverLocalData,   ,                  ,   P,    "local solver vectors and matrices"
#VL,     file,                      , 	             ,     SolverFileData,  ,                  ,   P,    "output files for solver information and solution"
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized variables for CSolverStatic:
#
V,      cSolver,                     , 	             ,     CSolverStatic,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
V,      loadStepGeometricFactor,     cSolver.loadStepGeometricFactor,               ,     Real,              ,                  ,   P,    "multiplicative load step factor; this factor is computed from loadStepGeometric parameters in SolveSystem(...)"
#
V,      isInitialized,               , 	             ,     bool,              ,                  ,    ,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
V,      initializedSystemSizes,      , 	             ,     Index4,            ,                  ,    ,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized functions for CSolverStatic:
F,      MainSolverStatic,            ,               ,     ,                  "isInitialized = false;",,,  "constructor, in order to set valid state (settings not initialized at beginning)"
Fv,     GetCSolver,                  ,                ,    const CSolverBase& ,            "return cSolver;",,C,  "const access to cSolver"
Fv,     GetCSolver,                  ,                ,    CSolverBase& ,                  "return cSolver;",,,  "reference access to cSolver"
FvL,    CheckInitialized,            ,               ,     bool,              ,                  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
F,      ComputeLoadFactor,           ,                ,    Real,        "return cSolver.ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
#++++++++++++++++++++++++++++++++++++++++++++++
#this should be exactly the same as MainSolverImplicitSecondOrder
#general functions:
FvL,    GetSolverName,               ,                ,    "std::string", ,                     ,   CGPV,    "get solver name - needed for output file header and visualization window"
FvL,    IsStaticSolver,              ,                ,    bool,        ,                       ,   CGPV,    "return true, if static solver; needs to be overwritten in derived class"
FvL,    GetSimulationEndTime,        ,                ,    Real,        ,                       "const SimulationSettings& simulationSettings",   CGPV,    "compute simulation end time (depends on static or time integration solver)"
FvL,    ReduceStepSize,              ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
FvL,    IncreaseStepSize,            ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
#initialization functions:
FvL,    InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
FvL,    PreInitializeSolverSpecific, ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
FvL,    InitializeSolverOutput,      ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
FvL,    InitializeSolverPreChecks,   ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
FvL,    InitializeSolverData,        ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
FvL,    InitializeSolverInitialConditions, ,          ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
FvL,    PostInitializeSolverSpecific,,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
#++++++++++++++++++++++++++++++++++
#solve functions:
FvL,    SolveSystem,                 ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
FvL,    FinalizeSolver,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
FvL,    SolveSteps,                  ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
FvL,    UpdateCurrentTime,           ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
FvL,    InitializeStep,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; python-functions; do some outputs, checks, etc."
FvL,    FinishStep,                  ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "finish static step / time step; write output of results to file"
FvL,    DiscontinuousIteration,      ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
FvL,    Newton,                      ,                ,    bool,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
FvL,    ComputeNewtonResidual,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store result in systemResidual"
FvL,    ComputeNewtonUpdate,         ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian)"
FvL,    ComputeNewtonJacobian,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
#output functions:
FvL,    WriteSolutionFileHeader,     ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
FvL,    WriteCoordinatesToFile,      ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
FvL,    IsVerboseCheck,              ,                ,    bool,        ,                                   "Index level",   CGPV,    "return true, if file or console output is at or above the given level"
FvL,    VerboseWrite,                ,                ,    void,        ,                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"

#special functions to access residua and system matrices
FvL,    GetODE2size,                 ,                ,    Index,       ,                                ,   CGP,    "number of ODE2 equations in solver"
FvL,    GetODE1size,                 ,                ,    Index,       ,                                ,   CGP,    "number of ODE1 equations in solver (not yet implemented)"
FvL,    GetAEsize,                   ,                ,    Index,       ,                                ,   CGP,    "number of algebraic equations in solver"
FvL,    GetDataSize,                 ,                ,    Index,       ,                                ,   CGP,    "number of data (history) variables in solver"
#
FvL,    GetSystemJacobian,           ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed system jacobian of solver"
FvL,    GetSystemMassMatrix,         ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed mass matrix of solver"
FvL,    GetSystemResidual,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed system residual"
FvL,    GetNewtonSolution,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed solution (=increment) of Newton"
FvL,    SetSystemJacobian,           ,                ,    void,        ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemMassMatrix,         ,                ,    void,        ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemResidual,           ,                ,    void,        ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
#
#special functions for interaction with mainSystem:
FvL,    ComputeMassMatrix,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix"
FvL,    ComputeJacobianODE2RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver"
FvL,    ComputeJacobianODE2RHS_t,    ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver"
FvL,    ComputeJacobianAE,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=1., bool velocityLevel=false",   DGPV,    "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level"
#
FvL,    ComputeODE2RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)"
FvL,    ComputeAlgebraicEquations,   ,                ,    void,        ,                       "MainSystem& mainSystem, bool velocityLevel=false",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
#
writeFile=MainSolver.h


class = MainSolverImplicitSecondOrder
parentClass="MainSolverBase"
appendToFile=True
writePybindIncludes = True
classDescription = "PyBind interface (trampoline) class for dynamic implicit solver. Note that this solver includes the classical Newmark method (set useNewmark True; with option of index 2 reduction) as well as the generalized-alpha method. With the interface, the dynamic implicit solver and its substructures can be accessed via python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (performance much lower than internal solver) due to python interfaces, and should thus be used for small systems. To access the solver in python, write \bi\n \item[] solver = MainSolverImplicitSecondOrder() \n\ei\n and hereafter you can access all data and functions via 'solver'.\n In this solver, user functions are possible to extend the solver at certain parts, while keeping the overal C++ performance."
#V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
VL,     timer,                    cSolver.timer , 	       ,     CSolverTimer,      ,                  ,   P,    "timer which measures the CPU time of solver sub functions"
VL,     it,                       cSolver.it    , 	       ,     SolverIterationData, ,                ,   P,    "all information about iterations (steps, discontinuous iteration, newton,...)"
VL,     conv,                     cSolver.conv  , 	       ,     SolverConvergenceData, ,              ,   P,    "all information about tolerances, errors and residua"
VL,     output,                   cSolver.output, 	       ,     SolverOutputData,  ,                  ,   P,    "output modes and timers for exporting solver information and solution"
VL,     newton,                   cSolver.newton, 	       ,     NewtonSettings,    ,                  ,   P,    "copy of newton settings from timeint or staticSolver"
#these structures cannot be accessed directly via pybind:
#VL,     data,                        , 	             ,     SolverLocalData,   ,                  ,   P,    "local solver vectors and matrices"
#VL,     file,                      , 	             ,     SolverFileData,  ,                  ,   P,    "output files for solver information and solution"
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized variables for CSolverStatic:
#
V,      cSolver,                     , 	             ,     CSolverImplicitSecondOrderTimeIntUserFunction,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
#without user function: V,      cSolver,                     , 	             ,     CSolverImplicitSecondOrderTimeInt,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
#copy of parameters from integration scheme (cannot be changed during integration!)
V,      newmarkBeta,                 cSolver.newmarkBeta,                     ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      newmarkGamma,                cSolver.newmarkGamma,                    ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      alphaM,                      cSolver.alphaM,                          ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      alphaF,                      cSolver.alphaF,                          ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      spectralRadius,              cSolver.spectralRadius,                  ,     Real,              ,                  ,   P,    "copy of parameter in timeIntegration.generalizedAlpha"
V,      factJacAlgorithmic,          cSolver.factJacAlgorithmic,              ,     Real,              ,                  ,   P,    "locally computed parameter from generalizedAlpha parameters"
#
V,      isInitialized,               , 	             ,     bool,              ,                  ,    ,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
V,      initializedSystemSizes,      , 	             ,     Index4,            ,                  ,    ,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
#++++++++++++++++++++++++++++++++++++++++++++++
#specialized functions for CSolverImplicitSecondOrder:
F,      MainSolverImplicitSecondOrder,,               ,    ,            ,,D,  "constructor, in order to set valid state (settings not initialized at beginning)"
Fv,     GetCSolver,                  ,                ,    const CSolverBase& ,            "return cSolver;",,C,  "const access to cSolver"
Fv,     GetCSolver,                  ,                ,    CSolverBase& ,                  "return cSolver;",,,  "reference access to cSolver"
#
FvL,    CheckInitialized,            ,                ,    bool,        ,                  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
F,      ComputeLoadFactor,           ,                ,    Real,        "return cSolver.ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
#
F,      GetAAlgorithmic,             ,                ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations"
F,      GetStartOfStepStateAAlgorithmic, ,            ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations at start of step"
#++++++++++++++++++++++++++++++++++++++++++++++
#User functions: (must be initialized)
##
#V,      userFunctionUpdateCurrentTime,,               ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override UpdateCurrentTime()"
#V,      userFunctionInitializeStep,  ,                ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override InitializeStep()"
#V,      userFunctionFinishStep,      ,                ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override FinishStep()"
#V,      userFunctionDiscontinuousIteration,,          ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override DiscontinuousIteration()"
#V,      userFunctionNewton,          , 	            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionComputeNewtonUpdate,,             ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonUpdate()"
#V,      userFunctionComputeNewtonResidual,,           ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonResidual()"
#V,      userFunctionComputeNewtonJacobian,,           ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override ComputeNewtonJacobian()"
#
#V,      userFunctionPreInitializeSolverSpecific,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionInitializeSolverInitialConditions,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
#V,      userFunctionPostInitializeSolverSpecific,,            ,     MainSolverImplicitSecondOrderUserFunction,            ,                  ,    P,   "User function to override Newton()"
F,       SetUserFunctionUpdateCurrentTime,,            ,    void,            "cSolver.SetUserFunctionUpdateCurrentTime(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionInitializeStep,   ,            ,    void,            "cSolver.SetUserFunctionInitializeStep(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionFinishStep,       ,            ,    void,            "cSolver.SetUserFunctionFinishStep(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionDiscontinuousIteration,,       ,    void,            "cSolver.SetUserFunctionDiscontinuousIteration(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionNewton,           ,            ,    void,            "cSolver.SetUserFunctionNewton(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonUpdate,,          ,    void,            "cSolver.SetUserFunctionComputeNewtonUpdate(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonResidual,,        ,    void,            "cSolver.SetUserFunctionComputeNewtonResidual(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
F,       SetUserFunctionComputeNewtonJacobian,,        ,    void,            "cSolver.SetUserFunctionComputeNewtonJacobian(this, &mainSystem, userFunction);","MainSystem& mainSystem, const MainSolverImplicitSecondOrderUserFunction& userFunction", P,  "set user function"
#
#++++++++++++++++++++++++++++++++++++++++++++++
#this should be exactly the same as MainSolverStatic
#general functions:
FvL,    GetSolverName,               ,                ,    "std::string", ,                     ,   CGPV,    "get solver name - needed for output file header and visualization window"
FvL,    IsStaticSolver,              ,                ,    bool,        ,                       ,   CGPV,    "return true, if static solver; needs to be overwritten in derived class"
FvL,    GetSimulationEndTime,        ,                ,    Real,        ,                       "const SimulationSettings& simulationSettings",   CGPV,    "compute simulation end time (depends on static or time integration solver)"
FvL,    ReduceStepSize,              ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
FvL,    IncreaseStepSize,            ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
#initialization functions:
FvL,    InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
FvL,    PreInitializeSolverSpecific, ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
FvL,    InitializeSolverOutput,      ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
FvL,    InitializeSolverPreChecks,   ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
FvL,    InitializeSolverData,        ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
FvL,    InitializeSolverInitialConditions, ,          ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
FvL,    PostInitializeSolverSpecific,,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
#++++++++++++++++++++++++++++++++++
#solve functions:
FvL,    SolveSystem,                 ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
FvL,    FinalizeSolver,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
FvL,    SolveSteps,                  ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
#
FvL,    UpdateCurrentTime,           ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
FvL,    InitializeStep,              ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; python-functions; do some outputs, checks, etc."
FvL,    FinishStep,                  ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",  DGPV,    "finish static step / time step; write output of results to file"
FvL,    DiscontinuousIteration,      ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
FvL,    Newton,                      ,                ,    bool,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
FvL,    ComputeNewtonResidual,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store result in systemResidual"
FvL,    ComputeNewtonUpdate,         ,                ,    void,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian)"
FvL,    ComputeNewtonJacobian,       ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
#output functions:
FvL,    WriteSolutionFileHeader,     ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
FvL,    WriteCoordinatesToFile,      ,                ,    void,        , "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
FvL,    IsVerboseCheck,              ,                ,    bool,        ,                                   "Index level",   CGPV,    "return true, if file or console output is at or above the given level"
FvL,    VerboseWrite,                ,                ,    void,        ,                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"

#special functions to access residua and system matrices
FvL,    GetODE2size,                 ,                ,    Index,       ,                                ,   CGP,    "number of ODE2 equations in solver"
FvL,    GetODE1size,                 ,                ,    Index,       ,                                ,   CGP,    "number of ODE1 equations in solver (not yet implemented)"
FvL,    GetAEsize,                   ,                ,    Index,       ,                                ,   CGP,    "number of algebraic equations in solver"
FvL,    GetDataSize,                 ,                ,    Index,       ,                                ,   CGP,    "number of data (history) variables in solver"
#
FvL,    GetSystemJacobian,           ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed system jacobian of solver"
FvL,    GetSystemMassMatrix,         ,                ,    NumpyMatrix, ,                       ,   CDGPV,    "get locally stored / last computed mass matrix of solver"
FvL,    GetSystemResidual,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed system residual"
FvL,    GetNewtonSolution,           ,                ,    NumpyVector, ,                       ,   CDGPV,    "get locally stored / last computed solution (=increment) of Newton"
FvL,    SetSystemJacobian,           ,                ,    void,        ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemMassMatrix,         ,                ,    void,        ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
FvL,    SetSystemResidual,           ,                ,    void,        ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
#
#special functions for interaction with mainSystem:
FvL,    ComputeMassMatrix,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix"
FvL,    ComputeJacobianODE2RHS,      ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver"
FvL,    ComputeJacobianODE2RHS_t,    ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor=1.",   DGPV,    "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver"
FvL,    ComputeJacobianAE,           ,                ,    void,        ,                       "MainSystem& mainSystem, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=1., bool velocityLevel=false",   DGPV,    "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level"
#
FvL,    ComputeODE2RHS,              ,                ,    void,        ,                       "MainSystem& mainSystem",   DGPV,    "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)"
FvL,    ComputeAlgebraicEquations,   ,                ,    void,        ,                       "MainSystem& mainSystem, bool velocityLevel=false",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
#
writeFile=MainSolver.h













##+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
## MAIN SOLVER interfaces
##+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#
#class = MainSolverStatic
#appendToFile=False
#writePybindIncludes = True
#linkedClass = "cSolver"
#classDescription = "PyBind interface (trampoline) class for CSolverStatic. With this interface, the static solver and its substructures can be accessed via python. NOTE that except from SolveSystem(...), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (performance much lower than internal solver) due to python interfaces, and should thus be used for small systems."
##V|F,   pythonName, 		          cplusplusName,      size, type,	      defaultValue,            args,           cFlags, parameterDescription
#VL,     timer,                       , 	             ,     CSolverTimer,      ,                  ,   P,    "timer which measures the CPU time of solver sub functions"
#VL,     it,                          , 	             ,     SolverIterationData, ,                ,   P,    "all information about iterations (steps, discontinuous iteration, newton,...)"
#VL,     conv,                        , 	             ,     SolverConvergenceData, ,              ,   P,    "all information about tolerances, errors and residua"
#VL,     output,                      , 	             ,     SolverOutputData,  ,                  ,   P,    "output modes and timers for exporting solver information and solution"
#VL,     newton,                      , 	             ,     NewtonSettings,    ,                  ,   P,    "copy of newton settings from timeint or staticSolver"
##these structures cannot be accessed directly via pybind:
##VL,     data,                        , 	             ,     SolverLocalData,   ,                  ,   P,    "local solver vectors and matrices"
##VL,     file,                      , 	             ,     SolverFileData,  ,                  ,   P,    "output files for solver information and solution"
##specialized variables for CSolverStatic
#VL,     loadStepGeometricFactor,     ,               ,     Real,              ,                  ,   P,    "multiplicative load step factor; this factor is computed from loadStepGeometric parameters in SolveSystem(...)"
##
#V,      cSolver,                     , 	             ,     CSolverStatic,     ,                  ,    ,    "link to C++ CSolver, not accessible from Python"
##
#V,      isInitialized,               , 	             ,     bool,              ,                  ,    ,   "variable is used to see, if system is initialized ==> avoid crashes; DO not change these variables: can easily lead to crash! "
#V,      initializedSystemSizes,      , 	             ,     Index4,            ,                  ,    ,   "index-array contains 4 integers: nODE2, nODE1, nAE and nData of initialization: this guaranties, that no function is called with wrong system sizes; DO not change these variables: can easily lead to crash! "
##++++++++++++++++++++++++++++++++++++++++++++++
#F,      MainSolverStatic,            ,               ,     ,                  "isInitialized = false;",,,  "constructor, in order to set valid state (settings not initialized at beginning)"
#F,      CheckInitialized,            ,               ,     bool,              ,                  "const MainSystem& mainSystem",   DGPV,  "check if MainSolver and MainSystem are correctly initialized ==> otherwise raise SysError"
##++++++++++++++++++++++++++++++++++++++++++++++
##this should be exactly the same as MainSolverImplicitSecondOrder
##general functions:
#F,      GetSolverName,               ,                ,    "std::string", "return cSolver.GetSolverName();",                                       ,   GPV,    "get solver name - needed for output file header and visualization window"
#F,      IsStaticSolver,              ,                ,    bool,        "return cSolver.IsStaticSolver();",                                        ,   GPV,    "return true, if static solver; needs to be overwritten in derived class"
#F,      GetSimulationEndTime,        ,                ,    Real,        "return cSolver.GetSimulationEndTime(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "compute simulation end time (depends on static or time integration solver)"
#F,      ReduceStepSize,              ,                ,    bool,        "CheckInitialized(mainSystem); return cSolver.ReduceStepSize(*(mainSystem.cSystem), simulationSettings, severity);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Index severity",   GPV,    "reduce step size (1..normal, 2..severe problems); return true, if reduction was successful"
#F,      IncreaseStepSize,            ,                ,    void,        "CheckInitialized(mainSystem); cSolver.IncreaseStepSize(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "increase step size if convergence is good"
#F,      ComputeLoadFactor,           ,                ,    Real,        "return cSolver.ComputeLoadFactor(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "for static solver, this is a factor in interval [0,1]; MUST be overwritten"
##initialization functions:
#F,      InitializeSolver,            ,                ,    bool,        ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files"
#F,      PreInitializeSolverSpecific, ,                ,    void,        "CheckInitialized(mainSystem); cSolver.PreInitializeSolverSpecific(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset"
#F,      InitializeSolverOutput,      ,                ,    void,        "cSolver.InitializeSolverOutput(simulationSettings);",                       "const SimulationSettings& simulationSettings",   GPV,    "initialize output files; called from InitializeSolver()"
#F,      InitializeSolverPreChecks,   ,                ,    bool,        "CheckInitialized(mainSystem); return cSolver.InitializeSolverPreChecks(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "check if system is solvable; initialize dense/sparse computation modes"
#F,      InitializeSolverData,        ,                ,    void,        "CheckInitialized(mainSystem); cSolver.InitializeSolverData(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize all data,it,conv; called from InitializeSolver()"
#F,      InitializeSolverInitialConditions, ,          ,    void,        "CheckInitialized(mainSystem); cSolver.InitializeSolverInitialConditions(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "set/compute initial conditions (solver-specific!); called from InitializeSolver()"
#F,      PostInitializeSolverSpecific,,                ,    void,        "CheckInitialized(mainSystem); cSolver.PostInitializeSolverSpecific(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "post-initialize for solver specific tasks; called at the end of InitializeSolver"
##++++++++++++++++++++++++++++++++++
##solve functions:
#F,      SolveSystem,                 ,                ,    bool,        "return cSolver.SolveSystem(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "solve System: InitializeSolver, SolveSteps, FinalizeSolver"
#F,      FinalizeSolver,              ,                ,    void,        "CheckInitialized(mainSystem); cSolver.FinalizeSolver(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write concluding information (timer statistics, messages) and close files"
#F,      SolveSteps,                  ,                ,    bool,        "CheckInitialized(mainSystem); return cSolver.SolveSteps(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "main solver part: calls multiple InitializeStep(...)/ DiscontinuousIteration(...)/ FinishStep(...); do step reduction if necessary; return true if success, false else"
#F,      UpdateCurrentTime,           ,                ,    void,        "CheckInitialized(mainSystem); cSolver.UpdateCurrentTime(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "update currentTime (and load factor); MUST be overwritten in special solver class"
#F,      InitializeStep,              ,                ,    void,        "CheckInitialized(mainSystem); cSolver.InitializeStep(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "initialize static step / time step; python-functions; do some outputs, checks, etc."
#F,      FinishStep,                  ,                ,    void,        "CheckInitialized(mainSystem); cSolver.FinishStep(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "finish static step / time step; write output of results to file"
#F,      DiscontinuousIteration,      ,                ,    bool,        "CheckInitialized(mainSystem); return cSolver.DiscontinuousIteration(*(mainSystem.cSystem), simulationSettings);",                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual"
#F,      Newton,                      ,                ,    bool,        "CheckInitialized(mainSystem); return cSolver.Newton(*(mainSystem.cSystem), simulationSettings);", "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "perform Newton method for given solver method"
#F,      ComputeNewtonResidual,       ,                ,    void,        "CheckInitialized(mainSystem); cSolver.ComputeNewtonResidual(*(mainSystem.cSystem), simulationSettings);", "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute residual for Newton method (e.g. static or time step); store result in systemResidual"
#F,      ComputeNewtonUpdate,         ,                ,    void,        "CheckInitialized(mainSystem); cSolver.ComputeNewtonUpdate(*(mainSystem.cSystem));",                       "MainSystem& mainSystem",   GPV,    "compute update for currentState from newtonSolution (decrement from residual and jacobian)"
#F,      ComputeNewtonJacobian,       ,                ,    void,        "CheckInitialized(mainSystem); cSolver.ComputeNewtonJacobian(*(mainSystem.cSystem), simulationSettings);", "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "compute jacobian for newton method of given solver method; store result in systemJacobian"
##output functions:
#F,      WriteSolutionFileHeader,     ,                ,    void,        "CheckInitialized(mainSystem); cSolver.WriteSolutionFileHeader(*(mainSystem.cSystem), simulationSettings);", "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique file header, depending on static/ dynamic simulation"
#F,      WriteCoordinatesToFile,      ,                ,    void,        "CheckInitialized(mainSystem); cSolver.WriteCoordinatesToFile(*(mainSystem.cSystem), simulationSettings);", "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   GPV,    "write unique coordinates solution file"
#F,      IsVerboseCheck,              ,                ,    bool,        "return cSolver.IsVerboseCheck(level);",                                   "Index level",   GPV,    "return true, if file or console output is at or above the given level"
#F,      VerboseWrite,                ,                ,    void,        "cSolver.VerboseWrite(level, str);",                                "Index level, const std::string& str",   GPV,    "write to console and/or file in case of level"
#
##special functions to access residua and system matrices
#F,      GetODE2size,                 ,                ,    Index,       "return cSolver.data.nODE2;",                                ,   GP,    "number of ODE2 equations in solver"
#F,      GetODE1size,                 ,                ,    Index,       "return cSolver.data.nODE1;",                                ,   GP,    "number of ODE1 equations in solver (not yet implemented)"
#F,      GetAEsize,                   ,                ,    Index,       "return cSolver.data.nAE;",                                  ,   GP,    "number of algebraic equations in solver"
#F,      GetDataSize,                 ,                ,    Index,       "return cSolver.data.nData;",                                ,   GP,    "number of data (history) variables in solver"
##
#F,      GetSystemJacobian,           ,                ,    NumpyMatrix,    ,                       ,   DGPV,    "get locally stored / last computed system jacobian of solver"
#F,      GetSystemMassMatrix,         ,                ,    NumpyMatrix,    ,                       ,   DGPV,    "get locally stored / last computed mass matrix of solver"
#F,      GetSystemResidual,           ,                ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed system residual"
#F,      GetNewtonSolution,           ,                ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed solution (=increment) of Newton"
#F,      SetSystemJacobian,           ,                ,    void,    ,                       "const py::array_t<Real>& systemJacobian",   DGPV,      "set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE"
#F,      SetSystemMassMatrix,         ,                ,    void,    ,                       "const py::array_t<Real>& systemMassMatrix",   DGPV,    "set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE"
#F,      SetSystemResidual,           ,                ,    void,    ,                       "const Vector& systemResidual",   DGPV,    "set locally stored system residual; must have size nODE2+nODE1+nAE"
##
##F,      GetAAlgorithmic,             ,                ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations"
##F,      GetStartOfStepStateAAlgorithmic, ,            ,    NumpyVector,    ,                       ,   DGPV,    "get locally stored / last computed algorithmic accelerations at start of step"
##
##special functions for interaction with mainSystem:
#F,      ComputeMassMatrix,           ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Real scalarFactor=1.",   DGPV,    "compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix"
#F,      ComputeJacobianODE2RHS,      ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Real scalarFactor=1.",   DGPV,    "set systemJacobian to zero and add jacobian (multiplied with factor) of ODE2RHS to systemJacobian in cSolver"
#F,      ComputeJacobianODE2RHS_t,    ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Real scalarFactor=1.",   DGPV,    "add jacobian of ODE2RHS_t (multiplied with factor) to systemJacobian in cSolver"
#F,      ComputeJacobianAE,           ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings, Real scalarFactor_ODE2=1., Real scalarFactor_ODE2_t=1., bool velocityLevel=false",   DGPV,    "add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. ODE2 coordinates and w.r.t. ODE2_t (velocity) coordinates; if velocityLevel == true, the constraints are evaluated at velocity level"
#
#F,      ComputeODE2RHS,              ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "compute the RHS of ODE2 equations in systemResidual in range(0,nODE2)"
#F,      ComputeAlgebraicEquations,   ,                ,    void,    ,                       "MainSystem& mainSystem, const SimulationSettings& simulationSettings",   DGPV,    "compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)"
#
##
#writeFile=MainSolver.h
#
#

