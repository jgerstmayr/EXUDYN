/** ***********************************************************************************************
* @class        GlfwClient
* @brief        Hub to glfw class for 3D visualization using OpenGL
*
* @author       Gerstmayr Johannes
* @date         2019-05-24 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */
#ifndef GLFWCLIENT__H
#define GLFWCLIENT__H

#include "Utilities/ReleaseAssert.h"
#include "Utilities/BasicDefinitions.h"
#include "Main/rendererPythonInterface.h"

#include <ostream>
//#include <stdlib.h> //only works in MSVC for initialization with std::vector
#include <array>
#include <vector>
#include <stdio.h>
#include <thread>

#include "Graphics/GraphicsData.h"
#include "Autogenerated/VisualizationSettings.h"
#include "Graphics/VisualizationSystemContainerBase.h" //common interface to visualization system


#ifdef USE_GLFW_GRAPHICS

//#define GLFW_INCLUDE_ES3 //open gl ES version
#define GLFW_INCLUDE_GLEXT
//#define GL_GLEXT_PROTOTYPES OpenGL3.2
#include <GLFW/glfw3.h>

#define USE_TEXTURED_BITMAP_FONTS //!< activate this flag for faster textured based fonts with glLists

#include "Graphics/GlfwClientText.h" //link to external library; include only if copyright is appropriate
#include "Graphics/GlfwClientBitmapText.h"


enum class RendererMode {
	_None, Move, Rotate, ZoomView, Select
};

//! size for bitmap fonts
enum class FontSizeType {
	small = 1,		//small text, e.g., for contour numbers
	normal = 2,		//regular text
	large = 4,		//large text
	userText = 8,	//size of user texts
};



//! variables that describe the renderer's state machine ==> zoom, move, etc. with mouse
class RenderStateMachine
{
public:
	bool leftMousePressed;
	bool rightMousePressed;
	bool shiftPressed;
	bool ctrlPressed;
	RendererMode mode;			//!< determines the state of any action

	double mousePositionX;		//!< currently recorded mouse position; use double for GLFW compatibility
	double mousePositionY;		//!< currently recorded mouse position; use double for GLFW compatibility
	double lastMousePressedX;	//!< last mouse button position pressed
	double lastMousePressedY;	//!< last mouse button position pressed

	float storedCenterPointX;	//!< stored centerpoint position during mouse-move
	float storedCenterPointY;	//!< stored centerpoint position during mouse-move

	Float16 storedModelRotation;//!< stored rotation matrix before right mouse button pressed

	//++++++++++++++++++++++++++++++++++++
	//selection:
	//DELETE: selectionMode;					//!< true, if in selection mode
	Vector2D selectionMouseCoordinates; //!mouse coordinates used for selection
	std::string selectionString;		//!< string about object to be shown on screen
	
	std::string rendererMessage;		//!< rendererMessage to be shown in status line
	Real renderMessageTimeout; 			//!< time at which message shall be removed, using EXUstd::GetTimeInSeconds(); 0, if no timeout

};


//! this is the rendering module for displaying 3D model data
class GlfwRenderer
{
private:
	//static RenderState state;
	static bool rendererActive;			//!< signal that shows that renderer is active
	static bool stopRenderer;			//!< signal that shows that renderer should quit
	static bool useMultiThreadedRendering;		//!< according to visualizationSettings.general; always false for MACOS (__APPLE__)
	static Real lastGraphicsUpdate;		//!< time of last graphics update
	static Real lastEventUpdate;		//!< time of last event polling
	static bool callBackSignal;			//!< for single threaded applications, react if callback is sent=> update graphics immediately

	static GLFWwindow* window;
	static RenderState* state;		//!< this represents the current OpenGL parameters
	static RenderStateMachine stateMachine; //!< all variables (mouse, keyboard, ...) used for state machine (zoom, zoom-view, move, ...)
	static std::thread rendererThread;	//!< std::thread variable for rendererThread
	static Index rendererError;			//!< 0 ... no error, 1 ... glfwInit() failed, 2 ... glfwCreateWindow failed, 3 ... other error
	static bool verboseRenderer;        //!< initialized in SetupRenderer(bool verbose): output helpful information
	static Index firstRun; //zoom all in first run
	static std::atomic_flag renderFunctionRunning;  //!< semaphore to check if Render(...)  function is currently running (prevent from calling twice)
	static std::atomic_flag showMessageSemaphore;   //!< semaphore to prevent calling ShowMessage twice

	//+++++++++++++++++++++++++++++++++++++++++
	static BitmapFont bitmapFont;				//!< bitmap font for regular texts and for textured fonts, initialized upon start of renderer
	static float fontScale;						//!< monitor scaling factor from windows, to scale fonts
	static constexpr float fontSmallFactor = 0.7500001f; //!< factor for small fonts
	static constexpr float fontLargeFactor = 1.400001f;  //!< factor for large fonts
	static constexpr float fontHugeFactor = 2.500001f;  //!< factor for large fonts
#ifndef USE_TEXTURED_BITMAP_FONTS
	static BitmapFont bitmapFontSmall;			//!< bitmap font for small texts, initialized upon start of renderer
	static BitmapFont bitmapFontLarge;			//!< bitmap font for large texts, initialized upon start of renderer
	static BitmapFont bitmapFontHuge;			//!< bitmap font for huge texts, initialized upon start of renderer
#else
	//+++ for textures with glLists +++:
	static GLuint textureNumberRGBbitmap[256];	//!< store texture numbers for every character of bitmap font
	static GLuint bitmapFontListBase;			//!< starting index for GLlists for font bitmap textured quads
	static ResizableArray<GLubyte> charBuffer;	//!< buffer for converstion of UTF8 into internal unicode-like format
#endif
	//+++++++++++++++++++++++++++++++++++++++++
	//link to GraphicsData and Settings:
	static ResizableArray<GraphicsData*>* graphicsDataList;					//!< link to graphics data; only works for one MainSystem, but could also be realized for several systems
	static VisualizationSettings* visSettings;  //!< link to visualization settings
	static VisualizationSystemContainerBase* basicVisualizationSystemContainer;
	//+++++++++++++++++++++++++++++++++++++++++

public:
	GlfwRenderer();
	~GlfwRenderer() 
	{	
		//glfwTerminate(); //move to destructor
	};

	//! Initializes and starts the Renderer in a separate thread;
	//  Returns false, if problems with glfw library or windows creation, otherwise true; 
	//  @todo test with apple and linux
	static bool SetupRenderer(bool verbose = false);

	//! stop the renderer engine and its thread; @todo StopRenderer currently also stops also main thread (python)
	static void StopRenderer();

	//! return renderState object
	static RenderState GetRenderState() { return *state; }

	static bool WindowIsInitialized()
	{
		if (window && rendererActive) { return true; }
		else { return false; }
	}

	//! Links the Renderer to a specific GraphicsData/settings; 
	//! Only one data linked at one time
	//! Returns true on success and false, if data is already linked (==> call DetachVisualizationSystem first)
	static bool LinkVisualizationSystem(ResizableArray<GraphicsData*>* graphicsDataListInit, VisualizationSettings* settingsInit,
										VisualizationSystemContainerBase* basicVisualizationSystemContainerInit, RenderState* renderStateInit)
	{
		if (graphicsDataList == nullptr)
		{
			graphicsDataList = graphicsDataListInit;
			visSettings = settingsInit;
			basicVisualizationSystemContainer = basicVisualizationSystemContainerInit;
			state = renderStateInit;
			//now state can be initialized:
			state->mouseCoordinates = Vector2D({ 0.,0. });
			state->openGLcoordinates = Vector2D({ 0.,0. });
			state->mouseLeftPressed = false;
			state->mouseRightPressed = false;
			state->mouseMiddlePressed = false;

			return true;
		}
		else { return false; }
	}

	//! Detach the GraphicsData/settings; enables the visualization of different MainSystems; return true on success
	static bool DetachVisualizationSystem(VisualizationSystemContainerBase* detachingVisualizationSystemContainer)
	{
		//only detach, if detachingVisualizationSystemContainer is still linked to GLFWrenderer
		if (detachingVisualizationSystemContainer == nullptr || basicVisualizationSystemContainer == detachingVisualizationSystemContainer)
		{
			StopRenderer();

			if (graphicsDataList == nullptr) { return false; }//this just shows that no system was linked yet
			else
			{
				graphicsDataList = nullptr;
				visSettings = nullptr;

				window = nullptr; //is set in StopRenderer anyway
				state = nullptr;
				basicVisualizationSystemContainer = nullptr;

				return true;
			}
		}
		return false;
	}

	static void UpdateGraphicsDataNow()
	{
		if (basicVisualizationSystemContainer)
		{
			basicVisualizationSystemContainer->UpdateGraphicsDataNow();
		}
	}

	//! write dictionary for selected item; return true if success; MAY ONLY BE CALLED FROM PYTHON THREAD!!!
	static bool PySetRendererSelectionDict(Index itemID);

	//! retrieve basic item information from MainSystemBacklink; return true if success; renderer thread safe (no Python calls)
	static bool GetItemInformation(Index itemID, STDstring& itemTypeName, STDstring& itemName);// , STDstring& itemInfo);

	//! print delayed via safe communication with main thread
	static void PrintDelayed(const STDstring& str, bool lineFeed = true) 
	{
		if (useMultiThreadedRendering)
		{
			if (lineFeed)
			{
				PyQueueExecutableString("print('" + str + "')\n");
			}
			else
			{
				PyQueueExecutableString("print('" + str + "', end='')\n");
			}
		}
		else
		{
			pout << str;
			if (lineFeed) { pout << "\n"; }
		}
	};

	static STDstring OnOffFromBool(bool flag) { if (flag) { return "on"; } else { return "off"; } }

	//! add status message, e.g., if button is pressed
	static void ShowMessage(const STDstring& str, Real timeout = 0);

	//! run renderer idle for certain amount of time; use this for single-threaded, interactive animations; waitSeconds==-1 waits forever
	static void DoRendererIdleTasks(Real waitSeconds);

	//! check if separate thread used:
	static bool UseMultiThreadedRendering() { return useMultiThreadedRendering; }

private: //to be called internally only!
	static void error_callback(int error, const char* description)
	{
		std::cout << description << "\n";
	}

	//static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods)
	static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods);
	static void scroll_callback(GLFWwindow* window, double xoffset, double yoffset);
	static void mouse_button_callback(GLFWwindow* window, int button, int action, int mods);
	static void cursor_position_callback(GLFWwindow* window, double xpos, double ypos);
	static void window_close_callback(GLFWwindow* window)
	{
		//StopRenderer();
		//rendererActive = false;
		//basicVisualizationSystemContainer->StopSimulation(); //if user waits for termination of render engine, it tells that window is closed
		//stopRenderer = false;	//if stopped by user

		glfwSetWindowShouldClose(window, GLFW_FALSE); //do not close ....
		if (PyGetRendererCallbackLock()) { return; }

		ShowMessage("PRESS ESC or Q to close window!",5);
	
	}
	//! if callback function like mousemove is called, immediately refresh graphics independently of graphicsUpdateInterval
	static void SetCallBackSignal(bool flag = true) { callBackSignal = flag; }
	static bool GetCallBackSignal() { return callBackSignal; }
	
	//! zoom in to mouse position, used to render that area lateron (replacement for gluPickMatrix(...)
	static void SetViewOnMouseCursor(GLdouble x, GLdouble y, GLdouble deltax, GLdouble deltay, GLint viewport[4]);
	
	//! function to evaluate selection of items
	static void MouseSelectOpenGL(GLFWwindow* window, Index mouseX, Index mouseY, Index& itemID);

	//! function to evaluate selection of items, return true, if item selected
	static bool MouseSelect(GLFWwindow* window, Index mouseX, Index mouseY, Index& itemID);

	//! GlfwInit and glfw->CreateWindow() calls; returns false, if functions fail
	static void InitCreateWindow();

	//! loop which checks for keyboard/mouse input; check for visualization updates (new data, window size changed, zoom, mouse move, etc.) and calls Render()
	static void RunLoop();

	//! tasks which are regularly called by RunLoop(), used if no separate thread used in GLFW; use wait in seconds to do this 
	static void DoRendererTasks();

	//! tasks which are done if renderer is shut down
	static void FinishRunLoop();

	//! Render function called for every update of OpenGl window
	static void Render(GLFWwindow* window); //GLFWwindow* needed in argument, because of glfwSetWindowRefreshCallback

	//! check if frame shall be grabed and saved to file using visualization options
	static void SaveImage();

	//! save scene to a file with filename
	static void SaveSceneToFile(const STDstring& filename);
	
	//! Render particulary the graphics data of multibody system; selectionMode==true adds names
	static void RenderGraphicsData(bool selectionMode = false); // fontScale now stored in GLFWRenderer: float fontScale); 

	//! Zoom all graphics objects (for current configuration)
	static void ZoomAll();

	//! Set all light functions for openGL
	static void SetGLLights();

	//!transform pixel coordinates (from bottom/left) into vertex coordinates
	//!works if model view is initialized with 	glMatrixMode(GL_MODELVIEW);glLoadIdentity();
	static Float2 PixelToVertexCoordinates(float x, float y);

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//FONTS
	//! initialize bitmap for bitmap font (loaded from characterBitmap.h
	static void InitFontBitmap(guint fontSize);// , guint fontSizeSmall, guint fontSizeLarge, guint fontSizeHuge);

	//! draw a 0-terminated text string with fontSize, including monitor scaling factor; (for line-characters: size=1: height=1; width=0.5 for one character; distance = 0.25)
	//! switches to strings drawn by textures (default) or lines
	static void DrawString(const char* text, float fontSizeScaled, const Float3& p, const Float4& color);

	//! draw string with scalable bitmap fonts, using textures
	static void DrawStringWithTextures(const char* text, float fontSizeScaled, const Float3& p, const Float4& color,
		BitmapFont& font, ResizableArray<GLubyte>& charBuffer, GLuint listBase);

	//! create glTexImage2D objects for font characters, stored in textureNumberRGBbitmap
	static void CreateFontTextures();

	//! create glLists for texture with textureNumber
	static void CreateTexturedQuadsLists(GLuint& listBase, GLuint* textureNumber,
		guint nCharacters, guint wCharacter8, guint wCharacter, guint hCharacter, bool itemTags = false);

	//draw string with GLlists, previously created by CreateTexturedQuadsLists
	static void DrawStringWithGLlistTextures(const Float3& p, float fontSizeScaled, GLuint listBase, GLubyte *string, guint stringLen);

	//! OpenGL testing functions for destructor
	static void DeleteFonts();
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

};

extern GlfwRenderer glfwRenderer; //this is the (static) location of the renderer class; could also be made dynamic



#endif //USE_GLFW_GRAPHICS
#endif //include once
