/** ***********************************************************************************************
* @brief		Implentation for computational solver CSolverBase
* @details		Details:
* 				- base classes for computational solver (as compared to main solver, which interacts with Python, etc.)
*               - contains basic solver structures (Evaluation functions, jacobians, initialization, link to linear solvers, 
*				  solver statistics and output, solution files, Newton, nonlinear iteration, ...)
*
* @author		Gerstmayr Johannes
* @date			2019-12-11 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
************************************************************************************************ */

#include <chrono> //#sleep_for
#include <thread> //#sleep_for

#include <pybind11/pybind11.h> //for integrated python connectivity (==>put functionality into separate file ...!!!)
#include <pybind11/eval.h>

#include "Utilities/ExceptionsTemplates.h" //for exceptions in solver steps

#include "System/versionCpp.h"
#include "Linalg/BasicLinalg.h" //for Resizable Vector
#include "Main/CSystem.h"
#include "Autogenerated/CMarkerBodyPosition.h"
#include "Solver/CSolverBase.h" 

#include "Utilities/TimerStructure.h"
#include <fstream>
#include "Main/rendererPythonInterface.h" //for regular call to PyExecuteQueue(...)

namespace py = pybind11;	//for py::object

#ifdef USE_NGSOLVE_TASKMANAGER
#include "ngs-core-master/ngs_core.hpp"
#include <thread>         // std::thread
#include <mutex>          // std::mutex, std::unique_lock, std::defer_lock
using namespace ngstd;
#endif

//! initialize all data,it,conv; set/compute initial conditions (solver-specific!); initialize output files
bool CSolverBase::InitializeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//keep the following order!
	InitCSolverBase(); //reset all data, such that multiple calls to SolveSystem give same results

	PreInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things

	InitializeSolverOutput(computationalSystem, simulationSettings); //first needs to open files
	if (InitializeSolverPreChecks(computationalSystem, simulationSettings))
	{
		InitializeSolverData(computationalSystem, simulationSettings);
		InitializeSolverInitialConditions(computationalSystem, simulationSettings);

		PostInitializeSolverSpecific(computationalSystem, simulationSettings); //do solver specific things
		return true;
	}
	return false;
}

//! initialize output files; called from InitializeSolver(); must be done at the very beginning, as otherwise, no information is written!
void CSolverBase::InitializeSolverOutput(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration;
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;
	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	
	if (IsStaticSolver())
	{
		output.verboseMode = staticSolver.verboseMode;
		output.verboseModeFile = staticSolver.verboseModeFile; //verbose mode of file
		output.stepInformation = staticSolver.stepInformation;
		newton = staticSolver.newton;
		discontinuous = staticSolver.discontinuous;
	} else
	{
		output.verboseMode = timeint.verboseMode;
		output.verboseModeFile = timeint.verboseModeFile; //verbose mode of file
		output.stepInformation = timeint.stepInformation;
		newton = timeint.newton;
		discontinuous = timeint.discontinuous;
	}

	//timer.Reset(simulationSettings.displayComputationTime); //done in SolveSteps

	STDstring solutionFileName = solutionSettings.coordinatesSolutionFileName;
	STDstring solverFileName = solutionSettings.solverInformationFileName;

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solution file
	output.writeToSolutionFile = solutionSettings.writeSolutionToFile;
	if (solutionFileName != "" && output.writeToSolutionFile)
	{
		CheckPathAndCreateDirectories(solutionFileName);

		if (solutionSettings.appendToFile) { file.solutionFile.open(solutionFileName, std::ofstream::app); }
		else { file.solutionFile.open(solutionFileName, std::ofstream::out); }
		if (!file.solutionFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			output.writeToSolutionFile = false;
			SysError(STDstring("failed to open solution file '") + solutionFileName + "'", file.solverFile);
		}
		else
		{
			file.solutionFile.precision(solutionSettings.outputPrecision);
		}
	}
	else { output.writeToSolutionFile = false; }

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open solver information file
	output.writeToSolverFile = false; //default
	if (output.verboseModeFile > 0 && solverFileName != "")
	{
		CheckPathAndCreateDirectories(solverFileName);
		if (solutionSettings.appendToFile) { file.solverFile.open(solverFileName, std::ofstream::app); }
		else { file.solverFile.open(solverFileName, std::ofstream::out); }
		
		if (!file.solverFile.is_open()) //failed to open file ...  e.g. invalid file name
		{
			SysError(STDstring("failed to open solution file '") + solverFileName + "'", file.solverFile);
		}
		else
		{
			output.writeToSolverFile = true;
			file.solverFile.precision(solutionSettings.outputPrecision);
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//open sensor files
	//for every sensor there is an according enty in sensorFileList (may be Null pointer)
	//files need to be closed at any exit point!!!
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		Index cnt = 0;
		if (item->GetWriteToFileFlag() && item->GetFileName().length() != 0)
		{
			std::ofstream* sensorFile = new std::ofstream;
			file.sensorFileList.push_back(sensorFile);
			auto fileMode = std::ofstream::out;
			if (solutionSettings.appendToFile) { fileMode = std::ofstream::app; }

			CheckPathAndCreateDirectories(item->GetFileName());
			sensorFile->open(item->GetFileName(), fileMode);

			if (!sensorFile->is_open()) //failed to open file ...  e.g. invalid file name
			{
				SysError(STDstring("failed to open sensor file '") + item->GetFileName() + "' (sensor number " + EXUstd::ToString(cnt) + ")", file.solverFile);
				file.sensorFileList.back() = nullptr; //mark this ofstream as unwriteable
			}
			else
			{
				sensorFile->precision(solutionSettings.outputPrecision);
			}
			cnt++;
		}
		else
		{
			file.sensorFileList.push_back(nullptr);
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	if (IsVerboseCheck(1))
	{
		VerboseWrite(1, STDstring("+++++++++++++++++++++++++++++++\nEXUDYN V") + EXUstd::ToString(EXUstd::exudynVersion) + " solver: " + GetSolverName() + "\n");
	}

}


//! initialize dense/sparse computation modes
bool CSolverBase::InitializeSolverPreChecks(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//now done separately
	computationalSystem.GetPostProcessData()->SetSolverMessage(STDstring(GetSolverName()) + " started");
	computationalSystem.GetPostProcessData()->SetSolutionMessage(simulationSettings.solutionSettings.solutionInformation);

	//some pre-checks for solver
	if (!computationalSystem.IsSystemConsistent()) { PyError("SolverGeneralizedAlpha: system is inconsistent and cannot be solved (call Assemble() and check error messages, file.solverFile)"); return false; }

	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(data.nODE2, data.nODE1, data.nAE, data.nData);
	data.nSys = data.nODE2 + data.nODE1 + data.nAE;
	data.startAE = data.nODE2 + data.nODE1;
	if (data.startAE == data.nODE2 + data.nODE1 + data.nAE) { data.startAE = 0; } //data.startAE == data.nSys would lead to invalid pointer in LinkedDataVector; can only happen, if data.nAE==0

	//check for static solver, dynamic solver checked in solver specific implementation!
	if (IsStaticSolver() && data.nODE1 != 0) { SysError("StaticSolver cannot solve first order differential equations (ODE1) for now", file.solverFile); }

	if (data.nSys == 0)
	{
		PyError("Solver cannot solve for system size = 0", file.solverFile);
		return false;
	}


	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		Index n = computationalSystem.GetSystemData().GetNumberOfComputationCoordinates();
		if (n > 1000) 
		{ 
			PyWarning("The number of total coordinates (unknowns) is larger than 1000. Consider a sparse solver (SimulationSettings().linearSolverType) to reduce memory consumption and computation time.", file.solverFile);
		}
	}
	else if (simulationSettings.linearSolverType == LinearSolverType::EigenSparse)
	{
		EXUstd::AssignParallelizationParameters(simulationSettings);
	}
	else
	{
		PyError("CSolverBase::InitializeSolverPreChecks: Unsupported simulationSettings.linearSolverType", file.solverFile);
		data.SetLinearSolverType(LinearSolverType::_None);
		return false;
	}

	computationalSystem.GetPostProcessData()->stopSimulation = false;
	computationalSystem.GetSolverData().Reset(); //e.g. set load factor to 1
	computationalSystem.GetPostProcessData()->simulationFinished = false;
	computationalSystem.GetPostProcessData()->postProcessDataReady = false;

	return true;
}


//! initialize all data,it,conv; called from InitializeSolver()
void CSolverBase::InitializeSolverData(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	conv.InitializeData();

	if (simulationSettings.linearSolverType == LinearSolverType::EXUdense)
	{
		data.SetLinearSolverType(LinearSolverType::EXUdense);
	}
	else
	{
		data.SetLinearSolverType(LinearSolverType::EigenSparse);
	}
	
	data.systemMassMatrix->SetNumberOfRowsAndColumns(data.nODE2, data.nODE2);
	data.systemJacobian->SetNumberOfRowsAndColumns(data.nSys, data.nSys);
	data.jacobianAE->SetNumberOfRowsAndColumns(data.nODE2, data.nAE);


	data.systemResidual.SetNumberOfItems(data.nSys);
	data.newtonSolution.SetNumberOfItems(data.nSys);	//temporary vector for Newton
	data.tempODE2.SetNumberOfItems(data.nODE2);			//temporary vector for ODE2 quantities; use in initial accelerations and during Newton
	data.tempODE2F0.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian
	data.tempODE2F1.SetNumberOfItems(data.nODE2);		//temporary vector for ODE2 Jacobian
	data.tempODE1F0.SetNumberOfItems(data.nODE1);		//temporary vector for ODE1 Jacobian
	data.tempODE1F1.SetNumberOfItems(data.nODE1);		//temporary vector for ODE1 Jacobian
	//data.tempODE1.SetNumberOfItems(data.nODE1);			//temporary vector for ODE1 quantities

	data.tempCompData = TemporaryComputationData();		//totally reset; for safety for now!

	//temp. structure to store start of discontinous iteration state:
	//  done in CleanUpMemory(): data.startOfDiscIteration.Reset();
	data.startOfStepStateAAlgorithmic.SetNumberOfItems(data.nODE2);


	it.newtonStepsCount = 0;				//count total number of Newton iterations
	it.newtonJacobiCount = 0;				//count total number of Jacobian computations and factorizations
	it.rejectedModifiedNewtonSteps = 0;		//count number of rejections of modifiedNewtonMethod
	it.discontinuousIterationsCount = 0;	//count total number of discontinuous iterations

	it.newtonSteps = 0;						//consistently initialize
	it.discontinuousIteration = 0;			//consistently initialize

	if (newton.weightTolerancePerCoordinate && data.nSys) { conv.errorCoordinateFactor = sqrt((Real)data.nSys); }
	else { conv.errorCoordinateFactor = 1.; }

	if (newton.newtonResidualMode != 0 && newton.newtonResidualMode != 1) //check residual mode: 0/1, otherwise not implemented by solvers!
	{ 
		PyError("MainSolverBase::InitializeSolverData: NewtonSettings.newtonResidualMode: unsupported mode"); 
	}


}

//! set/compute initial conditions (solver-specific!); called from InitializeSolver()
void CSolverBase::InitializeSolverInitialConditions(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	//cache some variables
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	if (!IsStaticSolver())
	{
		it.numberOfSteps = timeint.numberOfSteps;
		if (it.numberOfSteps == 0)
		{
			PyWarning("SolverInitialConditions: TimeIntegration.numberOfSteps == 0: setting number of steps to 1", file.solverFile);
			it.numberOfSteps = 1;
		}

		it.startTime = timeint.startTime;
		it.endTime = timeint.endTime;

		it.minStepSize = timeint.minimumStepSize;
		it.maxStepSize = (it.endTime - it.startTime) / (Real)(it.numberOfSteps);
		if (timeint.automaticStepSize) 
		{ 
			if (timeint.initialStepSize != 0.) { it.initialStepSize = timeint.initialStepSize; }
			else { it.initialStepSize = it.maxStepSize; } //chose max step size as initial guess if not provided
		}

		it.adaptiveStep = timeint.adaptiveStep;
		it.automaticStepSize = timeint.automaticStepSize;
		it.automaticStepSizeError = 0;			//initialize stored step size error
		it.rejectedAutomaticStepSizeSteps = 0;	//initialize counter for rejected steps
	}
	else
	{
		it.numberOfSteps = staticSolver.numberOfLoadSteps;

		it.startTime = staticSolver.loadStepStart;
		it.endTime = staticSolver.loadStepStart + staticSolver.loadStepDuration;

		it.minStepSize = staticSolver.minimumStepSize;
		it.maxStepSize = staticSolver.loadStepDuration / (Real)(it.numberOfSteps);

		it.adaptiveStep = staticSolver.adaptiveStep;
		it.automaticStepSize = false; //not available for static solver, set false to be safe
		if (staticSolver.loadStepGeometric && staticSolver.adaptiveStep)
		{
			PyWarning("CSolverBase::InitializeSolverPreChecks: staticSolver.adaptiveStep is not possible for staticSolver.loadStepGeometric; adaptiveStep will be ignored", file.solverFile);
			it.adaptiveStep = false;
		}
	}
	if (IsVerbose(3))
	{
		Verbose(3, "number of steps = " + EXUstd::ToString(it.numberOfSteps) + "\n");
		Verbose(3, "start time = " + EXUstd::ToString(it.startTime) + "\n");
		Verbose(3, "end time = " + EXUstd::ToString(it.endTime) + "\n");
		Verbose(3, "minStepSize = " + EXUstd::ToString(it.minStepSize) + "\n");
		Verbose(3, "maxStepSize = " + EXUstd::ToString(it.maxStepSize) + "\n");
		Verbose(3, "adaptiveStep = " + EXUstd::ToString(it.adaptiveStep) + "\n");
	}

	//current values = initial values
	computationalSystem.GetSystemData().GetCData().initialState.time = it.startTime; //hereafter copied to currentState
	it.currentTime = it.startTime;
	computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().initialState;

	if (!IsStaticSolver()) //not needed in static solver
	{
		//set according size of vectors, which are not initialized:
		data.aAlgorithmic.SetNumberOfItems(data.nODE2);
		computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt.SetNumberOfItems(data.nODE2);
		computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t.SetNumberOfItems(data.nODE1);
	}

	//+++++++++++++++++++++++++++++++++++++
	//timer functions: only work in combination with FinalizeSolver
	output.lastSolutionWritten = it.startTime;
	output.lastSensorsWritten = it.startTime;
	output.lastImageRecorded = it.startTime;
	output.cpuStartTime = EXUstd::GetTimeInSeconds();
	output.cpuLastTimePrinted = output.cpuStartTime;

	//+++++++++++++++++++++++++++++++++++++++++

	//do this not earlier than here, because checks need to be done prior to writing the header
	//2021-02-18: moved from end of function InitializeSolverPreChecks(...) to here in order to have current values available:
	WriteSolutionFileHeader(computationalSystem, simulationSettings); 
	WriteSensorsFileHeader(computationalSystem, simulationSettings);

}

//! specific call to the start solver
bool CSolverBase::SolveSystem(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{

#ifdef USE_NGSOLVE_TASKMANAGER
	//Eigen::initParallel(); //with C++11 and eigen 3.3 optional
	Index nThreads = simulationSettings.numberOfThreads;
	if (nThreads > MAX_NUMBER_OF_THREADS)
	{
		pout << "\nmaximum number of threads=" << MAX_NUMBER_OF_THREADS << "\n"; //always printed, as it anyway leads to an exception
		CHECKandTHROW(nThreads <= MAX_NUMBER_OF_THREADS,
			"Solver::SolveSteps(...): number of threads must be smaller or equal to maximum number of threads");
	}
	TaskManager::SetNumThreads(simulationSettings.numberOfThreads);
	//std::cout << "TaskManager::SetNumThreads = " << simulationSettings.numberOfThreads << "\n";
	Index taskmanagerNumthreads = 0;

	//TaskManager::SetPajeTrace(true);
	//PajeTrace::SetMaxTracefileSize(100000000);

	taskmanagerNumthreads = EnterTaskManager();
	//std::cout << "EnterTaskManager = " << taskmanagerNumthreads << "\n";

	size_t n = 100;
	const int m = 10;
	int loop = (int)(1e7 / m);
	double gflop = (1.*n*m*loop) / 1.e9; //number of operations in 10^9 units

							   //for (size_t n = 10; n <= 10000; n *= 10)
	Array<double> res(n);
	std::mutex mtx;           // mutex for critical section

	ngstd::ParallelFor(n, [&res,&m,&mtx,this](size_t i)
		//for (i=1; i <= n; i++)
	{
		//std::unique_lock<std::mutex> lck(mtx, std::defer_lock);
		//lck.lock(); //start critical section
		//std::cout << "i=" << i << "\n";
		//std::cout << "thread=" << ngstd::TaskManager().GetThreadId() << "\n";
		//lck.unlock(); //finish critical section

		double val1 = 1 + 1e-7*i;
		double val2 = 1 + 2e-7*i;
		double val3 = 1 + 3e-7*i;
		double val4 = 1 + 4e-7*i;
		double prod = 1;
		double sum = 1;
		double sum2 = 2;
		this->GetSolverName();
		for (int j = 0; j < m; j++)
		{
			prod *= val1;
			//prod *= val2;
			//prod *= val3;
			//prod *= val4;
			//sum += val1;
			//sum += val2;
			//sum += val3;
			//sum += val4;
			//sum2 += val1;
			//sum2 += val2;
			//sum2 += val3;
			sum2 += val4;
		}
		res[8] += prod + sum + sum2;
	}); //ParallelFor

#endif

	bool success = true; //local success variable
	SolverExceptionHandling([&]
	{
		success = InitializeSolver(computationalSystem, simulationSettings);
	}, "CSolverBase::InitializeSolver");

	globalTimers.Reset();
	timer.Reset(simulationSettings.displayComputationTime);
	timer.total = -EXUstd::GetTimeInSeconds();
//#define maxThreads 16 //leads to crash. Why? atomic variables, visualization/prostprocessdata? python?
//#pragma omp parallel num_threads(maxThreads)

	if (success)
	{
		SolverExceptionHandling([&]
		{
			success = SolveSteps(computationalSystem, simulationSettings);
		}, "CSolverBase::SolveSteps");
	}
	timer.total += EXUstd::GetTimeInSeconds();

	SolverExceptionHandling([&]
	{
		FinalizeSolver(computationalSystem, simulationSettings);
	}, "CSolverBase::FinalizeSolver");

	output.finishedSuccessfully = success;

#ifdef USE_NGSOLVE_TASKMANAGER
	//std::cout << "ExitTaskManager\n";
	ExitTaskManager(taskmanagerNumthreads);
#endif

	return success;
}


//! write concluding information (timer statistics, messages) and close files
//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
void CSolverBase::FinalizeSolver(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (IsVerboseCheck(1))
	{
		if (computationalSystem.GetPostProcessData()->stopSimulation)
		{
			VerboseWrite(1, STDstring("solver stopped by user after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}
		else
		{
			//if (simulationSettings.displayComputationTime) { VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n"); }
			VerboseWrite(1, STDstring("solver finished after ") + EXUstd::ToString(timer.total) + " seconds.\n");
		}

		if (simulationSettings.displayComputationTime) //computation statistics
		{
			VerboseWrite(1, timer.ToString());
#ifdef USEGLOBALTIMERS
			STDstring sGlobal;
			sGlobal = globalTimers.ToString();
			if (sGlobal.size())
			{
				sGlobal = "global timings:\n" + sGlobal + "\n";
				VerboseWrite(1, sGlobal);
			}
#endif
		}
		if (simulationSettings.displayStatistics)
		{
			VerboseWrite(1, it.ToString());
		}
	}

	if (simulationSettings.solutionSettings.writeFileFooter && output.writeToSolutionFile)
	{
		file.solutionFile << "#simulation finished=" << EXUstd::GetDateTimeString() << "\n";
		file.solutionFile << "#Solver Info:";
		file.solutionFile << " stepReductionFailed(or step failed)=" << conv.stepReductionFailed;
		file.solutionFile << ",discontinuousIterationSuccessful=" << conv.discontinuousIterationSuccessful;
		file.solutionFile << ",newtonSolutionDiverged=" << conv.newtonSolutionDiverged;
		file.solutionFile << ",massMatrixNotInvertible=" << conv.massMatrixNotInvertible;
		file.solutionFile << ",total time steps=" << it.currentStepIndex-1; //initial step is also counted in it.currentStepIndex
		file.solutionFile << ",total Newton iterations=" << it.newtonStepsCount;
		file.solutionFile << ",total Newton jacobians=" << it.newtonJacobiCount << "\n";
	}

	computationalSystem.GetPostProcessData()->simulationFinished = true; //signal that last step should be rendered

	//clean up memory of large matrices
	if (simulationSettings.cleanUpMemory) { data.CleanUpMemory(); }

	if (!conv.stepReductionFailed)
	{
		computationalSystem.GetPostProcessData()->SetSolverMessage("Solver finished successfully");
	}
	else { computationalSystem.GetPostProcessData()->SetSolverMessage("Solver finished with errors"); }

	//++++++++++++++++++++++++++++++++++
	//final finalize: close files (NO EARLIER!)
	if (file.solutionFile.is_open()) { file.solutionFile.close(); }
	if (file.solverFile.is_open()) { file.solverFile.close(); }

	//close sensor files:
	for (auto* item : file.sensorFileList)
	{
		if (item != nullptr)
		{
			item->close();
			delete item;
			item = nullptr;
		}
	}
	file.sensorFileList.clear();
	//pout << "sensor list length=" << file.sensorFileList.size() << "\n";
}

//! main solver part: calls multiple InitializeStep(...)/PerformStep(...); do step reduction if necessary; return true if success, false else
bool CSolverBase::SolveSteps(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	if (IsVerbose(2)) { Verbose(2, "\nStart steps solving loop\n"); }

	if (it.automaticStepSize) { it.currentStepSize = it.initialStepSize; }
	else { it.currentStepSize = it.maxStepSize; }//initial value for step size

	it.currentStepIndex = 0;
	conv.stepReductionFailed = false;
	conv.jacobianUpdateRequested = true;	//for modified Newton, only request Newton at first step

	Index stepsSinceLastStepSizeReduction = 0;

	if (IsVerbose(2)) { Verbose(2, "\nWrite initial step to solution file and visualize ...\n"); }
	//perform initialization for initial values (write to file, show solution, ...); 
	FinishStep(computationalSystem, simulationSettings); //visualization, console output, file output, ...


	bool simulationEndTimeReached = false; //signals that end time has been reached (tEnd in time integration, loadFactor=1 in static solver)
	it.currentStepIndex++; //first step starts with stepIndex = 1

	while (!conv.stepReductionFailed && !simulationEndTimeReached &&
		!computationalSystem.GetPostProcessData()->stopSimulation)
	{
		computationalSystem.GetSystemData().GetCData().startOfStepState = computationalSystem.GetSystemData().GetCData().currentState; //for step reduction, disc. iteration, python functions, etc.
		data.startOfStepStateAAlgorithmic.CopyFrom(data.aAlgorithmic);

		//Real t = it.currentStepIndex * it.currentStepSize + it.startTime;
		//computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

		bool stepAccomplished = false;
		//do step size reduction
		while (!stepAccomplished && !conv.stepReductionFailed)
		{

			//python linking, visualization, output, ... for every step
			InitializeStep(computationalSystem, simulationSettings);

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//Post Newton iteration for one time step
			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			if (newton.modifiedNewtonJacUpdatePerStep) { conv.jacobianUpdateRequested = true; }
			it.lastStepSize = it.currentStepSize; //store step size to check if automatic step size and adaptive step size fit
			
			if (!DiscontinuousIteration(computationalSystem, simulationSettings))
			{
				//try to reduce step size

				if (it.adaptiveStep || it.automaticStepSize)
				{
					computationalSystem.GetSystemData().GetCData().currentState = computationalSystem.GetSystemData().GetCData().startOfStepState; //completely reset state including data variables and time

					if (!ReduceStepSize(computationalSystem, simulationSettings, 1, it.recommendedStepSize)) //only for adaptiveStep; automaticStepSize already done in Newton()
					{
						conv.stepReductionFailed = true;
						if (IsVerboseCheck(1))
						{
							VerboseWrite(1, "Solve steps: adaptive step reduction reached minimum step size; stop solver\n");
						}
					}
					else
					{
						if (IsVerboseCheck(1) && !it.automaticStepSize)
						{
							VerboseWrite(1, STDstring("  Solve steps: adaptive step reduction to size = ") + EXUstd::ToString(it.currentStepSize) + "\n");
						}
						stepsSinceLastStepSizeReduction = 0;
					}
				}
				else
				{
					conv.stepReductionFailed = true;
				}
			}
			else
			{
				stepAccomplished = true;
				FinishStep(computationalSystem, simulationSettings); //visualization, console output, file output, ...

				//in case of good Newton convergence, increase step size
				stepsSinceLastStepSizeReduction++;
				Index recoverySteps = simulationSettings.timeIntegration.adaptiveStepRecoverySteps;
				if (IsStaticSolver()) { recoverySteps = simulationSettings.staticSolver.adaptiveStepRecoverySteps; }

				//OLD: if ((stepsSinceLastStepSizeReduction >= 10 || (IsStaticSolver() && stepsSinceLastStepSizeReduction > 3)) &&
				if ((stepsSinceLastStepSizeReduction >= recoverySteps) &&
						it.newtonSteps + it.discontinuousIteration < 6) //small iteration numbers needed to increase step ...
				{
					IncreaseStepSize(computationalSystem, simulationSettings);
					stepsSinceLastStepSizeReduction = 0;
				}
			}
		}

		it.currentStepIndex++; //increment iteration count
		if (it.currentTime >= it.endTime - 1e-10) { simulationEndTimeReached = true; } //accept small tolerance
	}//time integration loop

	return !conv.stepReductionFailed; //return success (true) or fail (false)
}


bool cSolverBaseInitializeStepPreStepFunctionWarned = false;

//! initialize static step / time step: do some outputs, checks, etc.
void CSolverBase::InitializeStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	UpdateCurrentTime(computationalSystem, simulationSettings);

	computationalSystem.GetSystemData().GetCData().currentState.time = it.currentTime; //update time in state --> also available in Python for user-defined functions

	if (IsVerbose(2)) {
		Real t = it.currentTime; // computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();
		STDstring str;
		str += "+++++++++++++++ COMPUTE STEP +++++++++++++++\n";
		if (!IsStaticSolver())
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", t = " + EXUstd::ToString(t);
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}
		else
		{
			str += "STEP" + EXUstd::ToString(it.currentStepIndex) + ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings));
			if (t != ComputeLoadFactor(simulationSettings)) { str += ", t = " + EXUstd::ToString(t); }
			if (it.adaptiveStep) { str += ", step size = " + EXUstd::ToString(it.currentStepSize); }
			str += "\n";
		}

		Verbose(2, str);
	}
	if (!IsStaticSolver())
	{
		it.endTime = simulationSettings.timeIntegration.endTime; //update time, which may be updated for long integration time
	}

	STARTTIMER(timer.python);
	if (computationalSystem.GetPythonUserFunctions().preStepFunction)
	{
		bool rvPreStep = false; //initialize to suppress gcc warning
		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			rvPreStep = computationalSystem.GetPythonUserFunctions().preStepFunction(*(computationalSystem.GetPythonUserFunctions().mainSystem),
				it.currentTime);
		}, "CSolverBase::InitializeStep: PythonPreStepUserFunction failed (check code; check return value)");
		if (!rvPreStep)
		{
			if (IsVerbose(1)) { Verbose(1, STDstring("\n++++++++++++++++++++++++++++++\nPreStepUserFunction returned False; simulation is stopped after current step\n\n")); }
			computationalSystem.GetPostProcessData()->stopSimulation = true;
		}
	}

	if (!IsStaticSolver())
	{
		if (simulationSettings.timeIntegration.preStepPyExecute.size()) //if this string is not empty, execute the commands
		{
			if (!cSolverBaseInitializeStepPreStepFunctionWarned)
			{
				cSolverBaseInitializeStepPreStepFunctionWarned = true;
				PyWarning("simulationSettings.timeIntegration.preStepPyExecute and simulationSettings.staticSolver.preStepPyExecute are deprecated! Use mbs.SetPreStepUserFunction(...) instead.");
			}

			py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
			py::exec(simulationSettings.timeIntegration.preStepPyExecute.c_str(), scope);
		}
	}
	else
	{
		if (simulationSettings.staticSolver.preStepPyExecute.size()) //if this string is not empty, execute the commands
		{
			if (!cSolverBaseInitializeStepPreStepFunctionWarned)
			{
				cSolverBaseInitializeStepPreStepFunctionWarned = true;
				PyWarning("simulationSettings.timeIntegration.preStepPyExecute and simulationSettings.staticSolver.preStepPyExecute are deprecated! Use mbs.SetPreStepUserFunction(...) instead.");
			}
			py::object scope = py::module::import("__main__").attr("__dict__"); //use this to enable access to mbs and other variables of global scope within test models suite
			py::exec(simulationSettings.staticSolver.preStepPyExecute.c_str(), scope);
		}
	}
	DoIdleOperations(computationalSystem);
	STOPTIMER(timer.python);
}
//! finish static step / time step; write output of results to file
void CSolverBase::FinishStep(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().GetCurrent().GetTime();

	//output step information to console and solverFile
	bool printFile = ((output.verboseModeFile == 1) && ((EXUstd::GetTimeInSeconds() - output.cpuLastTimePrinted >= 2)
		|| it.currentTime + 1e-10>=it.endTime )) || (output.verboseModeFile >= 2);
	bool printConsole = ((output.verboseMode == 1) && ((EXUstd::GetTimeInSeconds() - output.cpuLastTimePrinted >= 2)
		|| it.currentTime + 1e-10 >= it.endTime)) || (output.verboseMode >= 2);

	if (simulationSettings.timeIntegration.simulateInRealtime)
	{
		Real cpuTimeElapsed = simulationSettings.timeIntegration.realtimeFactor * (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		Real simTimeElapsed = t - it.startTime;
		Index waitMicroSeconds = 1000; //wait time until next computation

		while (cpuTimeElapsed < simTimeElapsed) //no workaround if simTimeElapsed would be much too big
		{
			std::this_thread::sleep_for(std::chrono::microseconds(waitMicroSeconds)); //avoid continuous computation
			cpuTimeElapsed = (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		}
	}

	if (printFile || printConsole)
	{
		STARTTIMER(timer.overhead);
		output.cpuLastTimePrinted += 2;
		Real timeToGo = 0;
		Real cpuTimeElapsed = (EXUstd::GetTimeInSeconds() - output.cpuStartTime);
		Real simTotalTime = it.endTime - it.startTime;
		Real simTimeRemaining = it.endTime - t;
		Real simTimeElapsed = t - it.startTime;

		if (cpuTimeElapsed > 1e-1 && simTimeElapsed > 1e-3*simTotalTime && it.currentStepIndex != 0)
		{
			timeToGo = simTimeRemaining * (cpuTimeElapsed / simTimeElapsed);
			//old: based on steps: timeToGo = (double)(n - it.currentStepIndex) * timeToGo / (double)i;
		}

		STDstring str = "STEP" + EXUstd::ToString(it.currentStepIndex);
		if (!IsStaticSolver()) { str += ", t = " + EXUstd::ToString(t) + " sec"; }
		else { str += ", factor = " + EXUstd::ToString(ComputeLoadFactor(simulationSettings)); }

		if (output.stepInformation >= 1) {
			str += ", timeToGo = " + EXUstd::ToString(timeToGo); 
		}
		if (output.stepInformation >= 2 && it.currentStepIndex != 0) {
			str += " sec, Nit/step = " + EXUstd::ToString(it.newtonStepsCount / (Real)(it.currentStepIndex));
		}
		if (output.stepInformation >= 3 && it.currentStepIndex != 0) {
			str += " Dit/step = " + EXUstd::ToString(it.discontinuousIterationsCount / (Real)(it.currentStepIndex)) +
				" jac/step = " + EXUstd::ToString(it.newtonJacobiCount / (Real)(it.currentStepIndex));
		}
		str += "\n";
		if (printConsole) { pout << str; }
		if (printFile) { file.solverFile << str; }
		if (IsVerbose(2)) { Verbose(2, "+++++++++++++++ STEP FINISHED ++++++++++++++\n\n"); }

		STOPTIMER(timer.overhead);
	}

	if (output.writeToSolutionFile)
	{

		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSolutionWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteCoordinatesToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	if (computationalSystem.GetSystemData().GetCSensors().NumberOfItems() != 0)
	{
		//modify lastSolutionWritten to include last step in output file
		if (fabs(t - it.endTime) <= 1e-10) {
			output.lastSensorsWritten = it.endTime - it.currentStepSize;
		}

		STARTTIMER(timer.writeSolution);
		WriteSensorsToFile(computationalSystem, simulationSettings);
		STOPTIMER(timer.writeSolution);
	}

	STARTTIMER(timer.visualization);

	bool recordImage = false;

	if (simulationSettings.solutionSettings.recordImagesInterval >= 0)
	{
		if (t >= output.lastImageRecorded + simulationSettings.solutionSettings.recordImagesInterval)
		{
			output.lastImageRecorded += simulationSettings.solutionSettings.recordImagesInterval; //keep this interval constant to obtain frames recorded in constant time interval
			recordImage = true;
		}
	}

	//update postprocess data only if visualization is running ...
	if (computationalSystem.GetPostProcessData()->VisualizationIsRunning())
	{
		computationalSystem.UpdatePostProcessData(recordImage);
	}

	if (simulationSettings.pauseAfterEachStep) { computationalSystem.GetPostProcessData()->WaitForUserToContinue(); }
	STOPTIMER(timer.visualization);
}

//! perform discontinuousIteration for static step / time step
bool CSolverBase::DiscontinuousIteration(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{

	conv.discontinuousIterationError = 0;		//error of discontinuous iterations (contact, friction, ...) outside of Newton iteration

	//data.startOfStepStateAAlgorithmic = data.aAlgorithmic; //changed 2019-12-29; moved to SolveSteps(...)
	CSystemState& current = computationalSystem.GetSystemData().GetCData().GetCurrent();

	conv.discontinuousIterationSuccessful = false;
	it.discontinuousIteration = 0;

	while (it.discontinuousIteration < discontinuous.maxIterations && !conv.discontinuousIterationSuccessful)
	{
		if (IsVerbose(2)) { Verbose(2,STDstring("  START discontinuous iteration ")+EXUstd::ToString(it.discontinuousIteration) + ":\n"); }

		if (Newton(computationalSystem, simulationSettings))
		{
			FinalizeNewton(computationalSystem, simulationSettings);
			//conv.discontinuousIterationError = computationalSystem.PostNewtonStep(data.tempCompData);
			conv.discontinuousIterationError = PostNewton(computationalSystem, simulationSettings);


			if (IsVerbose(2))
			{
				STDstring str = STDstring("  discontinuous iteration error = ") + EXUstd::ToString(conv.discontinuousIterationError)
					+ " (disc.it.=" + EXUstd::ToString(it.discontinuousIteration)
					+ ", error goal = " + EXUstd::ToString(discontinuous.iterationTolerance);
				if (conv.discontinuousIterationError <= discontinuous.iterationTolerance)
				{
					str += " ... REACHED";
				}
				str += ")\n";
				Verbose(2, str);
			}
			if (IsVerbose(3)) //print more details about disc. iteration
			{
				STDstring str;
				str += "    disc.it. solU      = " + EXUstd::ToString(current.ODE2Coords) + "\n";
				if (!IsStaticSolver())
				{
					str += "    disc.it. solV      = " + EXUstd::ToString(current.ODE2Coords_t) + "\n";
					str += "    disc.it. solA      = " + EXUstd::ToString(current.ODE2Coords_tt) + "\n";
				}
				str += "    disc.it. solData   = " + EXUstd::ToString(current.dataCoords) + "\n";
				str += "    disc.it. solLambda = " + EXUstd::ToString(current.AECoords) + "\n";
				Verbose(3, str);
			}

			//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			it.discontinuousIteration++; it.discontinuousIterationsCount++;

			if (conv.discontinuousIterationError > discontinuous.iterationTolerance)
			{
				if (it.discontinuousIteration < discontinuous.maxIterations)
				{
					//start NEW DiscontinuousIteration
					//reset states to start of discontinuous iteration, EXCEPT for data variables!:
					current.ODE2Coords = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
					current.ODE2Coords_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
					current.ODE2Coords_tt = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_tt;
					current.ODE1Coords = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords;
					current.ODE1Coords_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords_t;
					current.AECoords = computationalSystem.GetSystemData().GetCData().startOfStepState.AECoords;
					data.aAlgorithmic = data.startOfStepStateAAlgorithmic; //for generalized-alpha

					//check if some hints to reduce step size
					if (it.recommendedStepSize != -1 &&
						it.recommendedStepSize < (1+1e-8)*it.currentStepSize) //allow some tolerance to avoid many switches for linear problems
					{
						conv.discontinuousIterationSuccessful = false;
						return false;
					}
				}
				else
				{
					//MAX iterations reached --> stop
					if (!discontinuous.ignoreMaxIterations) { return false; }

					//continue solver if discontinuous iterations do not converge
					conv.discontinuousIterationSuccessful = true;
				}
			}
			else { conv.discontinuousIterationSuccessful = true; }

		}
		else
		{
			//NEWTON not successful --> terminate disc. iteration
			conv.discontinuousIterationError = discontinuous.iterationTolerance * 2.;
			conv.discontinuousIterationSuccessful = true; //in this case, it is the fault of Newton, not of discontinuous iteration

			return false;
		}
	} //discontinuous (postNewton) iteration
	if (discontinuous.maxIterations == 0) { conv.discontinuousIterationSuccessful = true; } //true because no iterations wanted
	return conv.discontinuousIterationSuccessful; //return success; in case that no discIter. are needed (==0), no error is returned
}

//Index TSfinalizeMatrix;
//TimerStructureRegistrator TSRfinalizeMatrix("finalize matrix", TSfinalizeMatrix, globalTimers);
//Index TSfactorize;
//TimerStructureRegistrator TSRfactorize("factorize", TSfactorize, globalTimers);

//! perform Newton method for given solver method
bool CSolverBase::Newton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	STARTTIMER(timer.overhead);

	//LinkedDataVector ode2Residual(data.systemResidual, 0, data.nODE2); //link ODE2 coordinates
	//LinkedDataVector aeResidual(data.systemResidual, data.startAE, data.nAE); //link ae coordinates
	LinkedDataVector newtonSolutionODE2(data.newtonSolution, 0, data.nODE2); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionODE1(data.newtonSolution, data.nODE2, data.nODE1); //temporary subvector for ODE2 components
	LinkedDataVector newtonSolutionAE(data.newtonSolution, data.startAE, data.nAE); //temporary subvector for ODE2 components

	//link current system vectors for ODE2
	Vector& solutionODE2 = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	Vector& solutionODE2_t = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	Vector& solutionODE2_tt = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	Vector& solutionODE1 = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords;
	Vector& solutionODE1_t = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t;
	Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;
	Vector& solutionAE = computationalSystem.GetSystemData().GetCData().currentState.AECoords;

	conv.linearSolverFailed = false;		//(errorOccurred) signals that linear solver failed ==> abort integration method or reduce step size
	conv.linearSolverCausingRow = -1;
	conv.newtonConverged = false;			//convergence of Newton reached by tolerance criteria
	conv.newtonSolutionDiverged = false;	//shows that solution diverged (e.g. in first step)

	bool ignoreRedundantEquations = false;
	Index redundantEqStart = 0;
	if (simulationSettings.linearSolverSettings.ignoreSingularJacobian || simulationSettings.linearSolverSettings.ignoreRedundantConstraints)
	{
		ignoreRedundantEquations = true;
		if (simulationSettings.linearSolverSettings.ignoreRedundantConstraints && !simulationSettings.linearSolverSettings.ignoreSingularJacobian)
		{
			redundantEqStart = data.startAE;
		}
	}

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//NEWTON method for one time step
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Real absError = -1; //current error
	Real initialResidual;

	
	solutionAE.SetAll(0.);		//use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint
	STOPTIMER(timer.overhead);

	//compute initial residual:
	data.newtonSolution.SetAll(0.); //no update yet
	//solutionODE2_tt must contain initial accelerations!
	ComputeNewtonUpdate(computationalSystem, simulationSettings, true); //for initial computations; better initial guess for Newton for old solver

	initialResidual = ComputeNewtonResidual(computationalSystem, simulationSettings);

	if (newton.newtonResidualMode == 1) { //coordinate update as residual
		initialResidual = 2*newton.relativeTolerance; //use some initial tolerance; if the step returns a higher residual, the initialResidual is reduced hereafter
	}

	if (initialResidual <= newton.absoluteTolerance)
	{
		initialResidual = 2.*newton.absoluteTolerance; //Make at least one Newton step and avoid division by zero! factor 2 is for safety
	}

	if (IsVerbose(2)) { Verbose(2, "Newton: initial residual = " + EXUstd::ToString(initialResidual) +
		"; goals: relTol=" + EXUstd::ToString(newton.relativeTolerance) +
		", absTol=" + EXUstd::ToString(newton.absoluteTolerance) + "\n"); }


	it.newtonSteps = 0; //current number of steps
	conv.residual = initialResidual;				//current residual
	conv.lastResidual = initialResidual;			//to determine contractivity
	conv.contractivity = 0;							//contractivity = geometric decay of error in every step
	bool modifiedNewtonRestarted = false;			//flag, which signals that modified Newton method has already been restarted
	bool fullNewtonRequested = !newton.useModifiedNewton; //in every step, the modified Newton method can switch to full Newton's method
	bool stopNewton = false;						//flag which tells that Newton shall be stopped (Jacobian singular, full Newton not converged, ?)
	//conv.errorCoordinateFactor = 1.;				//2021-02-06: removed, because is treated in InitializeSolverData(...)

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//Newton iterations
	while (!conv.linearSolverFailed && !conv.newtonConverged && 
		!stopNewton && it.newtonSteps < newton.maxIterations)
	{
		if (data.nSys > 200) { 	DoIdleOperations(computationalSystem); } //do this task regularly, specifically in large scale systems

		it.newtonSteps++; it.newtonStepsCount++;
		if (IsVerbose(3)) { Verbose(3, "  Newton: STEP "  + EXUstd::ToString(it.newtonSteps) + ":\n"); }
		if (IsVerbose(4)) { Verbose(4, "    systemResidual = " + EXUstd::ToString(data.systemResidual) + "\n"); }

		//+++++++++++++++++++++++++++++
		//compute JACOBIAN if necessary
		if (conv.jacobianUpdateRequested || fullNewtonRequested || computationalSystem.GetSolverData().signalJacobianUpdate)
		{
			if (newton.useModifiedNewton && IsVerbose(2))
			{
				STDstring str = "  Update Jacobian ... (flags: jacUpdateReq=" + EXUstd::ToString(conv.jacobianUpdateRequested) +
					", fullNewtonReq=" + EXUstd::ToString(fullNewtonRequested) +
					", sigJacUpdate=" + EXUstd::ToString(computationalSystem.GetSolverData().signalJacobianUpdate) + "\n";
				Verbose(2, str);
			}
			ComputeNewtonJacobian(computationalSystem, simulationSettings);

			STARTTIMER(timer.factorization);

			//STARTGLOBALTIMER(TSfinalizeMatrix);
			data.systemJacobian->FinalizeMatrix();
			//STOPGLOBALTIMER(TSfinalizeMatrix);
			//STARTGLOBALTIMER(TSfactorize);

			Index factorizeOutput = data.systemJacobian->FactorizeNew(ignoreRedundantEquations, redundantEqStart);
			if (factorizeOutput != -1)
			{
				//if (IsVerboseCheck(1)) 
				//{
				//	STDstring str = "  Solver (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
				//		"): factorization of system Jacobian failed";
				//	if (IsStaticSolver()) { str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
				//	str += ", time = " + EXUstd::ToString(it.currentTime);
				//	str += "\n";
				//	VerboseWrite(1, str);
				//}
				std::string s = "CSolverBase::Newton: System Jacobian seems to be singular / not invertible!\n";
				s += "  time/load step #" + EXUstd::ToString(it.currentStepIndex);
				if (IsStaticSolver()) { s += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor); }
				s += ", time = " + EXUstd::ToString(it.currentTime) +"\n";

				if (factorizeOutput < data.systemJacobian->NumberOfRows())
				{
					s += "  causing system equation number (coordinate number) = " + EXUstd::ToString(factorizeOutput) + "\n";
				}
				conv.linearSolverFailed = true;
				conv.linearSolverCausingRow = factorizeOutput;
				SysError(s); //this error might not be recoverable
				stopNewton = true;
			}
			//STOPGLOBALTIMER(TSfactorize);
			STOPTIMER(timer.factorization);

			it.newtonJacobiCount++;
			conv.jacobianUpdateRequested = false;
		}

		//+++++++++++++++++++++++++++++
		//perform step
		if (!conv.linearSolverFailed)
		{
			if (IsVerbose(4)) {Verbose(4, "    JacInv = " + EXUstd::ToString(*(data.systemJacobian)) + "\n"); }

			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//now compute descent of acceleration vector with jacobian

			STARTTIMER(timer.newtonIncrement);
			data.systemJacobian->Solve(data.systemResidual, data.newtonSolution);
			STOPTIMER(timer.newtonIncrement);

			ComputeNewtonUpdate(computationalSystem, simulationSettings);


			if (IsVerbose(3)) { Verbose(3, "    newtonIncrement = " + EXUstd::ToString(data.newtonSolution) + "\n    ... compute new residual\n"); }

			//++++++++++++++++++++++++++++++++++++++++++
			//compute residual from static step increment or from integration formula:
			conv.residual = ComputeNewtonResidual(computationalSystem, simulationSettings); 
			//2021-02-06: computation of residual norm moved computation of conv.residual to ComputeNewtonResidual(..); OLDE code:
			//if (newton.newtonResidualMode == 0) 
			//	{conv.residual = data.systemResidual.GetL2Norm() / conv.errorCoordinateFactor;}
			//else
			//	{conv.residual = newtonSolutionODE2.GetL2Norm() / conv.errorCoordinateFactor; } //increment of newton ODE2 coordinates used to determine error
			if (newton.newtonResidualMode == 1) //special case, not treated in ComputeNewtonResidual
			{
				conv.residual = (newtonSolutionODE2.GetL2Norm() + newtonSolutionODE1.GetL2Norm()) / conv.errorCoordinateFactor; //increment of newton ODE2/ODE1 coordinates used to determine error
			} 
			//++++++++++++++++++++++++++++++++++++++++++

			if (IsVerbose(2))
			{
				Verbose(2, "    NEWTON STEP " + EXUstd::ToString(it.newtonSteps) + 
					": residual = " + EXUstd::ToString(conv.residual) +
					": relTol = " + EXUstd::ToString(conv.residual / initialResidual) +
					": contr. = " + EXUstd::ToString(conv.residual / conv.lastResidual) +
					"\n");
			}
			if (IsVerbose(3))
			{
				STDstring str;
				str += "    Newton solU         = " + EXUstd::ToString(solutionODE2) + "\n";
				if (!IsStaticSolver())
				{
					str += "    Newton solV         = " + EXUstd::ToString(solutionODE2_t) + "\n";
					str += "    Newton solA         = " + EXUstd::ToString(solutionODE2_tt) + "\n";
				}
				if (data.nODE1)
				{
					str += "    Newton solODE1      = " + EXUstd::ToString(solutionODE1) + "\n";
					if (!IsStaticSolver())
					{
						str += "    Newton solODE1_t    = " + EXUstd::ToString(solutionODE1_t) + "\n";
					}
				}
				str += "    Newton solData      = " + EXUstd::ToString(solutionData) + "\n";
				str += "    Newton solLambda    = " + EXUstd::ToString(solutionAE) + "\n";
				str += "    Newton RESIDUAL     = " + EXUstd::ToString(data.systemResidual) + "\n";
				Verbose(3, str);
			}
			if (newton.adaptInitialResidual && conv.residual > initialResidual && it.newtonSteps <= 1) {
				initialResidual = conv.residual;
				conv.lastResidual = conv.residual; //for computation of contractivity lateron
				if (IsVerbose(2)) { Verbose(2, "    update initial residual with current residual; initial residual = " + EXUstd::ToString(initialResidual) + "\n"); }
			}

			if (conv.residual / initialResidual <= newton.relativeTolerance)
			{
				conv.newtonConverged = true;
			}
			else if (conv.residual <= newton.absoluteTolerance)
			{
				conv.newtonConverged = true;
				if (IsVerbose(2)) { Verbose(2, "  Newton convergence reached with absolute error = " + EXUstd::ToString(conv.residual) + "\n"); }
			}

			if (!conv.newtonConverged)
			{
				Real normU = solutionODE2.GetL2NormSquared();
				Real normV = 0;
				if (!IsStaticSolver()) { normV = solutionODE2_t.GetL2NormSquared(); }

				Real normLambda = solutionAE.GetL2NormSquared();

				conv.newtonSolutionDiverged = false;
				//check, if solution has diverged
				if (normU >= newton.maximumSolutionNorm || normV >= newton.maximumSolutionNorm ||
					std::isnan(normU) || std::isnan(normV) || std::isnan(normLambda))
				{
					if (fullNewtonRequested)
					{
						stopNewton = true;
						if (IsVerboseCheck(1)) { VerboseWrite(1, "  solution did not converge with full Newton\n"); }
						if (IsVerbose(4))
						{
							Verbose(4, "  Reasons for Newton divergence(maximum value=" + EXUstd::ToString(sqrt(newton.maximumSolutionNorm)) + 
								"): \n    normU = " + EXUstd::ToString(sqrt(normU)) + 
								"\n    normV = " + EXUstd::ToString(sqrt(normV)) +
								"\n    normLambda = " + EXUstd::ToString(sqrt(normLambda)) + "\n");
						}

					}
					else
					{
						if (IsVerbose(2)) { Verbose(2, "    ... full Newton requested because of diverged solution\n"); }
						conv.newtonSolutionDiverged = true; //previously only set in else case
					}
				}

				//bool maxModifiedNewtonStepsReached = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations))
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations
				}

				bool switchToFullNewton = false;
				if (!fullNewtonRequested && (it.newtonSteps > newton.maxModifiedNewtonIterations + newton.maxModifiedNewtonRestartIterations*(1-(int)newton.modifiedNewtonJacUpdatePerStep)))
				{
					fullNewtonRequested = true;
					it.rejectedModifiedNewtonSteps++;
					switchToFullNewton = true;
				}

				//decide on modified Newton based on contractivity
				conv.contractivity = conv.residual / conv.lastResidual; //last residual must always be greater than 0!!!
				if (newton.useModifiedNewton)
				{
					if (IsVerbose(3)) { Verbose(3, "    contractivity = " + EXUstd::ToString(conv.contractivity) + "\n"); }
					if (IsVerbose(3)) { Verbose(3, "    last residual = " + EXUstd::ToString(conv.lastResidual) + "\n"); }
				}

				conv.lastResidual = conv.residual;
				//in case of modified newton try with jacobian update and full newton ...
				
				if (!fullNewtonRequested && newton.useModifiedNewton && (conv.newtonSolutionDiverged || switchToFullNewton || //ADDED switchToFullNewton; but do not enter this loop in case that solely fullNewtonRequested=true
					(conv.contractivity > newton.modifiedNewtonContractivity && it.newtonSteps > 2))) //only check contractivity at third step
				{
					conv.jacobianUpdateRequested = true; //make a simple Jacobian update and continue Newton iterations

					if (modifiedNewtonRestarted && !fullNewtonRequested) //if modified Newton already restarted ==> use full Newton now!
					{
						fullNewtonRequested = true;
						it.rejectedModifiedNewtonSteps++;
						if (IsVerbose(2)) { Verbose(2, "    ... switch to full Newton due to repeated bad contractivity\n"); }
					}

					if (!stopNewton && (conv.newtonSolutionDiverged || conv.contractivity > 2 || fullNewtonRequested))  //this might indicate divergence ==> restart Newton if modified newton is used
					{
						modifiedNewtonRestarted = true;
						conv.jacobianUpdateRequested = true;

						//lastResidual = EXUstd::Maximum(lastResidual, initialResidual)*1.e6; //safety of 1e6 to relieve the contracticity condition of next step

						conv.residual = initialResidual;  //current residual
						conv.lastResidual = initialResidual; //to determine contractivity

						//initialize states with beginning of time step; dataCoords are not changed here, as they are modified only outside Newton
						solutionODE2 = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords;
						if (!IsStaticSolver())
						{
							solutionODE2_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_t;
							//old solver: solutionODE2_tt.SetAll(0.) ==> now done in ComputeNewtonUpdate(..., initial=true) for 

							//new solver: solutionODE2_tt must contain initial accelerations
							solutionODE2_tt = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE2Coords_tt;

							data.aAlgorithmic = data.startOfStepStateAAlgorithmic;
						}
						if (data.nODE1)
						{
							solutionODE1 = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords;
							//done in ComputeNewtonUpdate(..., initial=true): solutionODE1_t = computationalSystem.GetSystemData().GetCData().startOfStepState.ODE1Coords_t;
						}
						solutionAE.SetAll(0.); //use zero Lagrange multipliers as start guess for Newton iterations step ==> does not work for algebraic variables such as in sliding joint

						//++++++++++++++++++++++++++++++++++++++++++++++++++++++
						//compute residual (for beginning of step, which means that delta_acc=0, lambda=0):
						data.newtonSolution.SetAll(0.); //no update yet
						ComputeNewtonUpdate(computationalSystem, simulationSettings, true); //better initial guess for Newton
						ComputeNewtonResidual(computationalSystem, simulationSettings);

						if (IsVerbose(2) && !conv.newtonSolutionDiverged) { Verbose(2, "    ... Newton restarted due to bad contractivity, divergence or iterations count\n"); }
					}
				} //contractivity check
			}//converged
		} //Jacobian invert
	}//Newton iteration
	//double duration = EXUstd::GetTimeInSeconds() - output.cpuStartTime;

	if (stopNewton || !conv.newtonConverged)
	{
		if (IsVerboseCheck(1)) {
			STDstring str = "  Newton (time/load step #" + EXUstd::ToString(it.currentStepIndex) +
				"): convergence failed after " + EXUstd::ToString(it.newtonSteps) +
				" iterations; relative error = " + EXUstd::ToString(conv.residual / initialResidual);
			if (IsStaticSolver()) {str += ", load factor = " + EXUstd::ToString(computationalSystem.GetSolverData().loadFactor);}
			else { str += ", time = " + EXUstd::ToString(it.currentTime); }
			str += "\n";
			VerboseWrite(1, str);
		}
	}
	else
	{
		if (IsVerbose(2)) { Verbose(2, "  Newton: convergenced after " + EXUstd::ToString(it.newtonSteps) +
			" steps; relative error = " + EXUstd::ToString(conv.residual / initialResidual) + "\n"); }
	}

	return !(stopNewton || !conv.newtonConverged); //return success (true) or fail (false)
}


Real CSolverBase::PostNewton(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real discontinuousError = 0;	
	it.recommendedStepSize = -1;
	STARTTIMER(timer.python);
	if (computationalSystem.GetPythonUserFunctions().postNewtonFunction)
	{
		StdVector2D rv = {0,0};
		UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		{
			rv = computationalSystem.GetPythonUserFunctions().postNewtonFunction(*(computationalSystem.GetPythonUserFunctions().mainSystem),
				it.currentTime);
		}, "CSolverBase::InitializeStep: Python PostNewtonUserFunction failed (check code; check return value)");
		discontinuousError = fabs(rv[0]); //only use absolute error, in order to avoid problems, if user returns negative values ...
		if (rv[1] >= 0) //recommended step size \f$h_{recom}\f$ after PostNewton(...): \f$h_{recom} < 0\f$: no recommendation, \f$h_{recom}==0\f$: use minimum step size, \f$h_{recom}>0\f$: use specific step size, if no smaller size requested by other reason
		{
			it.recommendedStepSize = rv[1];
		}
	}
	STOPTIMER(timer.python);

	discontinuousError += computationalSystem.PostNewtonStep(data.tempCompData, it.recommendedStepSize);

	return discontinuousError;
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++



//! write solution file header commonly for static and dynamic solvers
void CSolverBase::WriteSolutionFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	
	if (!output.writeToSolutionFile) { return; }

	const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;
	const TimeIntegrationSettings& timeint = simulationSettings.timeIntegration; //only needed for time integration header
	const StaticSolverSettings& staticSolver = simulationSettings.staticSolver;  //only needed for static solver header

	bool isStatic = IsStaticSolver();

	Index nVel1 = 0;
	Index nVel2 = 0;
	Index nAcc2 = 0;
	Index nAEexported = 0;
	Index nDataExported = 0;

	Index nODE2, nODE1, nAE, nData; //values could also been taken from SolverData ...
	computationalSystem.GetSystemData().GetNumberOfComputationCoordinates(nODE2, nODE1, nAE, nData);
	//Index nSys = nODE2 + nODE1 + nAE;

	if (solutionSettings.exportVelocities && !isStatic) { nVel2 = nODE2; nVel1 = nODE1; }
	if (solutionSettings.exportAccelerations && !isStatic) { nAcc2 = nODE2; }
	if (solutionSettings.exportAlgebraicCoordinates) { nAEexported = nAE; }
	if (solutionSettings.exportDataCoordinates) { nDataExported = nData; }

	std::ofstream& solFile = file.solutionFile;

	if (solutionSettings.writeFileHeader)
	{
		solFile << "#Exudyn " << GetSolverName() << " ";
		if (isStatic) { solFile << "static "; }
		solFile << "solver solution file\n";
		solFile << "#simulation started=" << EXUstd::GetDateTimeString() << "\n";
		solFile << "#columns contain: time, ODE2 displacements";
		if (solutionSettings.exportVelocities) { solFile << ", ODE2 velocities"; }
		if (solutionSettings.exportAccelerations) { solFile << ", ODE2 accelerations"; }
		if (nODE1) { solFile << ", ODE1 coordinates"; } //currently not available, but for future solFile structure necessary!
		if (nVel1) { solFile << ", ODE1 velocities"; }
		if (solutionSettings.exportAlgebraicCoordinates) { solFile << ", AE coordinates"; }
		if (solutionSettings.exportDataCoordinates) { solFile << ", ODE2 velocities"; }
		solFile << "\n";

		solFile << "#number of system coordinates [nODE2, nODE1, nAlgebraic, nData] = [" <<
			nODE2 << "," << nODE1 << "," << nAE << "," << nData << "]\n"; //this will allow to know the system information, independently of coordinates written
		solFile << "#number of written coordinates [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData] = [" << //these are the exported coordinates line-by-line
			nODE2 << "," << nVel2 << "," << nAcc2 << "," << nODE1 << "," << nVel1 << "," << nAEexported << "," << nDataExported << "]\n"; //python convert line with v=eval(line.split('=')[1])

		solFile << "#total columns exported  (excl. time) = " << nODE2 + nVel2 + nAcc2 + nODE1 + nVel1 + nAEexported + nDataExported << "\n";
		if (!isStatic) { solFile << "#number of time steps (planned) = " << timeint.numberOfSteps << "\n"; }
		else { solFile << "#number of load steps (planned) = " << staticSolver.numberOfLoadSteps << "\n"; }
		solFile << "#\n"; //empty line for extension ...

		if (solutionSettings.solutionInformation.length())
		{
			solFile << "#solution information = " << solutionSettings.solutionInformation << "\n";
		}
	}

}


void CSolverBase::WriteCoordinatesToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	const Vector& solutionU = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords;
	const Vector& solutionV = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_t;
	const Vector& solutionA = computationalSystem.GetSystemData().GetCData().currentState.ODE2Coords_tt;
	const Vector& solutionODE1 = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords;
	const Vector& solutionODE1_t = computationalSystem.GetSystemData().GetCData().currentState.ODE1Coords_t;
	const Vector& solutionLambda = computationalSystem.GetSystemData().GetCData().currentState.AECoords;
	const Vector& solutionData = computationalSystem.GetSystemData().GetCData().currentState.dataCoords;

	bool isStatic = IsStaticSolver();

	//OLD timeIntegrationSolver: if (t == startTime || (t - lastSolutionWritten) >= (0 * solutionSettings.GetSolutionWritePeriod() - 1e-10)) //1e-10 because of roundoff errors
	if (t == startTime || (t - output.lastSolutionWritten) >= -1e-10) //1e-10 because of roundoff errors
	{

		std::ofstream& solFile = file.solutionFile;
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSolutionWritten += solutionSettings.solutionWritePeriod;
		output.lastSolutionWritten = EXUstd::Maximum(output.lastSolutionWritten, t); //never accept smaller values ==> for adaptive solver
		solFile << t;

		for (Index k = 0; k < solutionU.NumberOfItems(); k++) {
			solFile << "," << solutionU[k];
		}
		if (solutionSettings.exportVelocities && !isStatic)
		{
			for (Index k = 0; k < solutionV.NumberOfItems(); k++) {
				solFile << "," << solutionV[k];
			}
		}
		if (solutionSettings.exportAccelerations && !isStatic)
		{
			for (Index k = 0; k < solutionA.NumberOfItems(); k++) {
				solFile << "," << solutionA[k];
			}
		}
		//++++++++++++++++++++++++++++++++++++
		//newly added ODE1 coordinates:
		for (Index k = 0; k < solutionODE1.NumberOfItems(); k++) {
			solFile << "," << solutionODE1[k];
		}
		if (solutionSettings.exportODE1Velocities && !isStatic)
		{
			for (Index k = 0; k < solutionODE1_t.NumberOfItems(); k++) {
				solFile << "," << solutionODE1_t[k];
			}
		}
		//++++++++++++++++++++++++++++++++++++
		//algebraic and data coordinates:
		if (solutionSettings.exportAlgebraicCoordinates)
		{
			for (Index k = 0; k < solutionLambda.NumberOfItems(); k++) {
				solFile << "," << solutionLambda[k];
			}
		}
		if (solutionSettings.exportDataCoordinates)
		{
			for (Index k = 0; k < solutionData.NumberOfItems(); k++) {
				solFile << "," << solutionData[k];
			}
		}
		solFile << "\n";
	}
}


//! write unique sensor file header, depending on static/dynamic simulation
void CSolverBase::WriteSensorsFileHeader(CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Index cnt = 0;
	for (auto item : computationalSystem.GetSystemData().GetCSensors())
	{
		if ((Index)file.sensorFileList.size() >= cnt && file.sensorFileList[cnt] != nullptr)
		{
			std::ofstream* sFile = file.sensorFileList[cnt];
			(*sFile) << "#Exudyn " << GetSolverName() << " ";
			if (IsStaticSolver()) { (*sFile) << "static "; }
			(*sFile) << "sensor output file\n";
			STDstring typeStr = GetSensorTypeString(item->GetType());

			if (item->GetType() != SensorType::UserFunction)
			{
				(*sFile) << "#measure " << typeStr << " number = " << item->GetTypeDependentIndex() << "\n";
			}
			else
			{
				(*sFile) << "#measure " << typeStr << "\n"; //no number!
			}
			(*sFile) << "#OutputVariableType = " << GetOutputVariableTypeString(item->GetOutputVariableType()) << "\n";

			(*sFile) << "#simulation started = " << EXUstd::GetDateTimeString() << "\n";
			(*sFile) << "#columns contain: time, comma separated sensor values (e.g, x,y,z position coordinates)\n";

			item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current); //only for checking size of sensor output, computed values not used

			(*sFile) << "#number of sensor values = " << output.sensorValuesTemp.NumberOfItems() << "\n";
			(*sFile) << "#\n";
		}
		cnt++;
	}
}

//! write unique sensor solution file
void CSolverBase::WriteSensorsToFile(const CSystem& computationalSystem, const SimulationSettings& simulationSettings)
{
	Real t = computationalSystem.GetSystemData().GetCData().currentState.time;
	Real startTime = computationalSystem.GetSystemData().GetCData().initialState.time;

	if (t == startTime || (t - output.lastSensorsWritten) >= -1e-10) //1e-10 because of roundoff errors
	{

		//std::ofstream& solFile = file.solutionFile;
		const SolutionSettings& solutionSettings = simulationSettings.solutionSettings;

		output.lastSensorsWritten += solutionSettings.sensorsWritePeriod;
		output.lastSensorsWritten = EXUstd::Maximum(output.lastSensorsWritten, t); //never accept smaller values ==> for adaptive solver

		Index cnt = 0;
		for (auto item : computationalSystem.GetSystemData().GetCSensors())
		{
			if ((Index)file.sensorFileList.size() >= cnt && file.sensorFileList[cnt] != nullptr)
			{
				std::ofstream* sFile = file.sensorFileList[cnt];

				(*sFile) << t;
				
				item->GetSensorValues(computationalSystem.GetSystemData(), output.sensorValuesTemp, ConfigurationType::Current);

				for (auto value : output.sensorValuesTemp)
				{
					(*sFile) << "," << value;
				}
				(*sFile) << "\n";
			}
			cnt++;
		}
	}
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CSolverBase::DoIdleOperations(CSystem& computationalSystem)
{
	PyProcessExecuteQueue(); //execute incoming python tasks if available
	computationalSystem.GetPostProcessData()->ProcessUserFunctionDrawing(); //check if user functions to be drawn and do user function evaluations

	RendererDoSingleThreadedIdleTasks();
}


//! return true, if file or console output is at or above the given level
void CSolverBase::VerboseWrite(Index level, const STDstring& str)
{
	STARTTIMER(timer.overhead);
	if (output.verboseMode >= level)
	{
		pout << str;
	}
	if (output.verboseModeFile >= level)
	{
		file.solverFile << str;
	}
	STOPTIMER(timer.overhead);
}
