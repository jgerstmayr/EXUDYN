/** ***********************************************************************************************
* @brief		Implementation for general contact computation
* @details		Details:
*
* @author		Gerstmayr Johannes
* @date			2021-10-23 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: https://github.com/jgerstmayr/EXUDYN
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Linalg/LinearSolver.h"	//for polynomial solver based on Eigen
#include "Main/CSystemData.h"			//Basics, Vector/Array, OutputVariable, CData, Material, Body, Node, Marker, Load
#include "Main/CSystem.h"	
#include "Linalg/Geometry.h"	
#include "Linalg/RigidBodyMath.h"	

#include "System/CContact.h"
#include "System/CContactHelpers.h"
#include "Utilities/TimerStructure.h" //for local CPU time measurement

#ifdef USE_GENERAL_CONTACT

#include "Utilities/Parallel.h"

#include <typeinfo>   // operator typeid

#include "Autogenerated/CObjectANCFCable2D.h"
//#include "Autogenerated/CObjectALEANCFCable2D.h"

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include "Graphics/VisualizationSystemContainer.h"
#include "Graphics/VisualizationPrimitives.h"

#include "Utilities/AutomaticDifferentiation.h"
typedef EXUmath::AutoDiff<6, Real> DReal6;

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
bool warnedComputeEigenValuesANCFcableCircleContact = false;
Index TScontactANCFCableEig;
TimerStructureRegistrator TSRcontactANCFCableEig("Contact:ANCFCableEig", TScontactANCFCableEig, globalTimers, false);
Index TScontactANCFCable1;
TimerStructureRegistrator TSRcontactANCFCable1("Contact:ANCFCable1", TScontactANCFCable1, globalTimers, false);
Index TScontactANCFCable2;
TimerStructureRegistrator TSRcontactANCFCable2("Contact:ANCFCable2", TScontactANCFCable2, globalTimers, false);
Index TScontactANCFCable3;
TimerStructureRegistrator TSRcontactANCFCable3("Contact:ANCFCable3", TScontactANCFCable3, globalTimers, false);
Index TScontactANCFCable4;
TimerStructureRegistrator TSRcontactANCFCable4("Contact:ANCFCable4", TScontactANCFCable4, globalTimers, false);

//! visualization function to draw some contact information (bounding box, search tree, active contacts etc.)
//! only possible to draw during computation!
void VisuGeneralContact::DrawContacts(const GeneralContact& gContact, const VisualizationSettings& visualizationSettings,
	VisualizationSystem* vSystem)
{
	if (visualizationSettings.contact.showSpheres)
	{
		const ResizableArray<ContactSpheresMarkerBased>& spheres = gContact.GetSpheresMarkerBased();
		Vector3D p(0);
		for (const auto& item : spheres)
		{
			vSystem->systemData->GetCMarker(item.markerIndex).GetPosition(*vSystem->systemData, p,
				ConfigurationType::Visualization);

			vSystem->graphicsData.AddSphere(p, visualizationSettings.contact.colorSpheres,
				itemIDinvalidValue, (float)item.radius, visualizationSettings.contact.tilingSpheres);
		}
	}

	if (visualizationSettings.contact.showTriangles)
	{
		const ResizableArray<ContactTriangleRigidBodyBased>& trigs = gContact.TrigsRigidBodyBased();
		const ResizableArray<ContactRigidBodyMarkerBased>& markers = gContact.RigidBodyMarkerBased();

		MarkerData markerData;

		// set up additional temp visualization list of pos/rot for markers
		ResizableArray<Vector3D> markerPositions(markers.NumberOfItems());
		ResizableArray<Matrix3D> markerRotations(markers.NumberOfItems());
		for (const auto& item : markers)
		{
			vSystem->systemData->GetCMarker(item.markerIndex).ComputeMarkerData(*vSystem->systemData, false, markerData);
			markerPositions.Append(markerData.position);
			if (EXUstd::IsOfType(vSystem->systemData->GetCMarker(item.markerIndex).GetType(), Marker::Orientation))
			{
				markerRotations.Append(markerData.orientation);
			}
			else
			{
				markerRotations.Append(EXUmath::unitMatrix3D);
			}
		}

		std::array<Vector3D, 3> points;
		std::array<Float4, 3> colors;
		for (Index i = 0; i < colors.size(); i++) { colors[i] = visualizationSettings.contact.colorTriangles; }

		for (const auto& item : trigs)
		{
			const ContactRigidBodyMarkerBased& rigidMarker = markers[item.contactRigidBodyIndex];

			Box3D box; //empty box

			for (Index i = 0; i < (Index)item.points.size(); i++)
			{
				points[i] = rigidMarker.orientation * item.points[i] + rigidMarker.position;
			}
			vSystem->graphicsData.AddTriangle(points, colors, itemIDinvalidValue);
		}
	}

	if (visualizationSettings.contact.showSearchTree)
	{
		Box3D box = gContact.GetSearchTree().GetBox();
		EXUvis::DrawOrthoCube(box.Center(), box.PMax() - box.PMin(), visualizationSettings.contact.colorSearchTree,
			vSystem->graphicsData, 0, false, true);
	}
	if (visualizationSettings.contact.showSearchTreeCells)
	{
		const SearchTree& ST = gContact.GetSearchTree();
		Float4 color = 0.5*(visualizationSettings.contact.colorSearchTree + Float4({0.7f,0.7f,0.7f,1.f}));
		Float4 colorFilled = 0.5*(visualizationSettings.contact.colorSearchTree + Float4({ 0.9f,0.1f,0.1f,1.f }));

		Box3D box = gContact.GetSearchTree().GetBox();
		Real sx = box.SizeX() / (Real)ST.SizeX();
		Real sy = box.SizeY() / (Real)ST.SizeY();
		Real sz = box.SizeZ() / (Real)ST.SizeZ();
		ArrayIndex items;

		for (Index ix = 0; ix < ST.SizeX(); ix++)
		{
			Real x = ix *sx + box.PMinX();
			for (Index iy = 0; iy < ST.SizeY(); iy++)
			{
				Real y = iy * sy + box.PMinY();
				for (Index iz = 0; iz < ST.SizeZ(); iz++)
				{
					Real z = iz * sz + box.PMinZ();
					Index boxIndex = ST.GlobalIndex(ix, iy, iz);
					ST.GetItemsOfBox(boxIndex, items);
					if (items.NumberOfItems() != 0)
					{
						//draws used box with smaller size and alternative color
						EXUvis::DrawOrthoCube(Vector3D({ x + 0.5*sx,y + 0.5*sy,z + 0.5*sz }), Vector3D({ 0.8*sx,0.8*sy,0.8*sz }),
							colorFilled, vSystem->graphicsData, 0, false, true);
					}
					else
					{
						EXUvis::DrawOrthoCube(Vector3D({ x + 0.5*sx,y + 0.5*sy,z + 0.5*sz }), Vector3D({ sx,sy,sz }),
							color, vSystem->graphicsData, 0, false, true);
					}

				}
			}
		}

	}
	if (visualizationSettings.contact.showBoundingBoxes)
	{
		Float4 color = visualizationSettings.contact.colorBoundingBoxes;
		for (const Box3D& box : gContact.GetAllBoundingBoxes())
		{
			//std::cout << "draw=" << box.Center() << "\n";
			EXUvis::DrawOrthoCube(box.Center(), box.PMax() - box.PMin(), color,
				vSystem->graphicsData, 0, false, true);
		}
	}
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! perform operations in case that number of threads have been changed or initialize arrays
void GeneralContact::SetNumberOfThreads(Index nThreads)
{
	//assume that all arrays have same size!
	if (addedObjects.NumberOfItems() != nThreads)
	{
		for (Index i = 0; i < addedObjects.NumberOfItems(); i++)
		{
			delete addedObjects[i];
			delete addedObjectsFlags[i];
			delete foundTrianglesRigidBodyBased[i];
			delete foundPlanesTrianglesRigidBodyBased[i];
			delete foundEdgesTrianglesRigidBodyBased[i];
		}

		addedObjects.SetNumberOfItems(nThreads);
		addedObjectsFlags.SetNumberOfItems(nThreads);
		foundTrianglesRigidBodyBased.SetNumberOfItems(nThreads);
		foundPlanesTrianglesRigidBodyBased.SetNumberOfItems(nThreads);
		foundEdgesTrianglesRigidBodyBased.SetNumberOfItems(nThreads);

		for (Index i = 0; i < addedObjects.NumberOfItems(); i++)
		{
			addedObjects[i] = new ArrayIndex();
			addedObjectsFlags[i] = new ResizableArray<bool>();

			foundTrianglesRigidBodyBased[i] = new ResizableArray<ContactTrianglesRigidBodyBasedTemp>();
			foundPlanesTrianglesRigidBodyBased[i] = new ArrayIndex();
			foundEdgesTrianglesRigidBodyBased[i] = new ArrayIndex();

			addedObjects[i]->SetNumberOfItems(0);
			addedObjectsFlags[i]->SetNumberOfItems(TotalContactObjects());
			addedObjectsFlags[i]->SetAll(false); //need to initialize all to false; list must contain all false between operations

		}
	}
}

void GeneralContact::Reset(bool freeMemory)
{
	visualization.Reset();
	isActive = true;
	verboseMode = 0;
	initializeData = true;
	searchTreeUpdateCounter = 0;

	contactIsFinalized = false;

	if (freeMemory)
	{

		searchTree.Flush();
		allBoundingBoxes.Flush();
		globalContactIndexOffsets.Flush();

		CallOnAllContacts(Flush, EXU_NOARG, EXU_NOARG);
		for (Index i = 0; i < allActiveContacts.NumberOfItems(); i++)
		{
			if (allActiveContacts[i] != nullptr)
			{
				delete allActiveContacts[i];
				delete allActiveContactsVector[i];
			}
		}
		allActiveContacts.Flush();
		allActiveContactsVector.Flush();

		for (Index i = 0; i < allPositionJacobians.NumberOfItems(); i++)
		{
			if (allPositionJacobians[i] != nullptr)
			{
				delete allPositionJacobians[i];
			}
		}
		allPositionJacobians.Flush();

		for (Index i = 0; i < allRotationJacobians.NumberOfItems(); i++)
		{
			if (allPositionJacobians[i] != nullptr)
			{
				delete allRotationJacobians[i];
			}
		}
		allRotationJacobians.Flush();

		for (Index i = 0; i < allLTGs.NumberOfItems(); i++)
		{
			if (allLTGs[i] != nullptr)
			{
				delete allLTGs[i];
			}
		}
		allLTGs.Flush();

		SetNumberOfThreads(0); //erases all thread-related arrays
	}
	else
	{
		allActiveContacts.SetNumberOfItems(0);
		allActiveContactsVector.SetNumberOfItems(0);
		allBoundingBoxes.SetNumberOfItems(0);
		searchTree.ClearItems();
		globalContactIndexOffsets.SetNumberOfItems(0);

		CallOnAllContacts(SetNumberOfItems, 0, EXU_NOARG);
	}

}

Index TSboundingBoxes;
TimerStructureRegistrator TSRboundingBoxes("Contact:BoundingBoxes", TSboundingBoxes, globalTimers, true);

Index TSsearchTree;
TimerStructureRegistrator TSRsearchTree("Contact:SearchTree", TSsearchTree, globalTimers, true);

Index TScontactODE2RHS;
TimerStructureRegistrator TSRcontactODE2RHS("Contact:ODE2RHS", TScontactODE2RHS, globalTimers, true);

Index TScontactJacobian;
TimerStructureRegistrator TSRcontactJacobian("Contact:Jacobian", TScontactJacobian, globalTimers, true);

Index TScontactPostNewton;
TimerStructureRegistrator TSRcontactPostNewton("Contact:PostNewton", TScontactPostNewton, globalTimers, true);

Index TScontactANCFCable;
TimerStructureRegistrator TSRcontactANCFCable("Contact:ANCFCable", TScontactANCFCable, globalTimers, true);


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//! add contact object using a marker (Position or Rigid), radius and contact/friction parameters; 
//contact is possible between spheres (if intraSphereContact = true) and between sphere (=circle) and ANCFCable2D or sphere and line
Index GeneralContact::AddSphereWithMarker(Index markerIndex, Real radius, Real contactStiffness, Real contactDamping, Index frictionMaterialIndex)
{
	contactIsFinalized = false;

	ContactSpheresMarkerBased item;
	item.markerIndex = markerIndex;
	item.radius = radius;
	item.contactStiffness = contactStiffness;
	item.contactDamping = contactDamping;
	item.frictionMaterialIndex = frictionMaterialIndex;

	if (contactStiffness <= 0)
	{
		PyWarning("GeneralContact: AddSphereWithMarker(...): contactStiffness should be non-zero and positive (markerIndex=" +
			EXUstd::ToString(markerIndex) + ")");
	}

	spheresMarkerBased.Append(item);
	return spheresMarkerBased.NumberOfItems() - 1;
}

//! add contact object for ANCFCable element; currently only possible for ANCFCable2D elements
//contact is possible between sphere (circle) and ANCFCable2D
Index GeneralContact::AddANCFCable(Index objectIndex, Real halfHeight, Real contactStiffness, Real contactDamping, 
	Index frictionMaterialIndex)
{
	contactIsFinalized = false;

	ContactANCFCable2D item;

	item.isALE = false;
	item.coordinates.SetNumberOfItems(0);
	item.coordinates_t.SetNumberOfItems(0);
	//item.L to be filled in FinalizeContact, where systemData is available

	item.objectIndex = objectIndex;
	item.halfHeight = halfHeight;
	item.contactStiffness = contactStiffness;
	item.contactDamping = contactDamping;
	item.frictionMaterialIndex = frictionMaterialIndex;

	if (contactStiffness <= 0)
	{
		PyWarning("GeneralConact: AddANCFCable(...): contactStiffness should be non-zero and positive (objectIndex=" +
			EXUstd::ToString(objectIndex) + ")");
	}

	ancfCable2D.Append(item);
	return ancfCable2D.NumberOfItems() - 1;
}

//! add contact object for ANCFCable element; currently only possible for ANCFCable2D elements
//contact is possible between sphere (circle) and ANCFCable2D
Index GeneralContact::AddTrianglesRigidBodyBased(Index rigidBodyMarkerIndex, Real contactStiffness, Real contactDamping,
	Index frictionMaterialIndex, ResizableArray<Vector3D> pointList, ResizableArray<Index3> triangleList)
{
	contactIsFinalized = false;

	ContactRigidBodyMarkerBased itemRB;

	itemRB.markerIndex = rigidBodyMarkerIndex;
	itemRB.contactStiffness = contactStiffness;
	itemRB.contactDamping = contactDamping;
	itemRB.frictionMaterialIndex = frictionMaterialIndex;

	Index contactRigidBodyIndex = rigidBodyMarkerBased.Append(itemRB); //add only one rigid body item
	if (contactStiffness <= 0)
	{
		PyError("GeneralConact: AddTrianglesRigidBodyBased(...): contactStiffness should be non-zero and positive (rigidBodyMarkerIndex=" +
			EXUstd::ToString(rigidBodyMarkerIndex) + ")");
	}

	Index startIndex = trigsRigidBodyBased.NumberOfItems();
	//now add triangles as single items
	ContactTriangleRigidBodyBased itemTrig;
	itemTrig.contactRigidBodyIndex = contactRigidBodyIndex; //always same ...
	Index cnt = 0;
	for (auto trig : triangleList)
	{
		for (Index i = 0; i < trig.NumberOfItems(); i++)
		{
			if (!pointList.IsValidIndex(trig[i])) { 
				PyError("GeneralConact: AddTrianglesRigidBodyBased(...): triangle " + EXUstd::ToString(cnt) + 
					" has invalid point index " + EXUstd::ToString(trig[i])); }
			itemTrig.points[i] = pointList[trig[i]];
		}

		itemTrig.normal = HGeometry::ComputeTriangleNormal(itemTrig.points);

		trigsRigidBodyBased.Append(itemTrig); //only add points; in future also add weight ...?
		cnt++;
	}
	return startIndex;
}



//! set up necessary parameters for contact: friction, SearchTree, etc.; done after all contacts have been added
//! at this point, can also be checked if something is wrong (illegal pairings or frictionMaterial coeffs, etc.)
//! empty box will autocompute size!
void GeneralContact::FinalizeContact(const CSystem& cSystem)//, Index3 searchTreeSize, const Matrix& frictionPairingsInit, Vector3D searchTreeBoxMin, Vector3D searchTreeBoxMax)
{
	initializeData = true; //will be set false after first call to ComputeContactDataAndBoundingBoxes
	//check if frictionPairings matrix is large enough:
	maxFrictionMaterialIndex = 0;
	//**ICI individual contact implementation; order irrelevant
	ComputeMaximumFrictionIndex(spheresMarkerBased); Index maxFricIndexSpheres = maxFrictionMaterialIndex;
	ComputeMaximumFrictionIndex(ancfCable2D);
	ComputeMaximumFrictionIndex(rigidBodyMarkerBased);
	//CallOnAllContacts(This, EXU_NOARG, ComputeMaximumFrictionIndex);

	if (maxFrictionMaterialIndex >= settings.frictionPairings.NumberOfRows())
	{
		//pout << "maxFric=" << maxFrictionMaterialIndex << "\n";
		PyError("Assemble() / GeneralContact::FinalizeContact(...): frictionMaterialIndex is larger than size of frictionPairings matrix; you need to initialize frictionPairings!");
	}
	if (settings.ancfCableNumberOfContactSegments > DANCFselectedSegmentsLength)
	{
		//pout << "maxFric=" << maxFrictionMaterialIndex << "\n";
		PyWarning("Assemble() / GeneralContact::FinalizeContact(...): ancfCableNumberOfContactSegments may not be larger than " + EXUstd::ToString(DANCFselectedSegmentsLength) + ", using max size!");
		settings.ancfCableNumberOfContactSegments = DANCFselectedSegmentsLength;
	}

	//! check if sphere markers and friction is consistent; just for some warnings later
	Real maxFrictionCoeff = 0.;
	for (Index i=0; i < maxFricIndexSpheres +1; i++)
	{
		for (Index j = 0; j < maxFricIndexSpheres +1; j++)
		{
			maxFrictionCoeff = EXUstd::Maximum(settings.frictionPairings(i, j), maxFrictionCoeff);
		}
	}

	searchTreeUpdateCounter = 0;
	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//create relation between local and global contact indices
	globalContactIndexOffsets.Flush();
	globalContactIndexOffsets.Append(0); //first entry is first offset
	//**ICI individual contact implementation; order of calls must agree with according ...Index variable in GeneralContact
	globalContactIndexOffsets.Append(spheresMarkerBased.NumberOfItems() + globalContactIndexOffsets.Last());
	globalContactIndexOffsets.Append(ancfCable2D.NumberOfItems() + globalContactIndexOffsets.Last());
	globalContactIndexOffsets.Append(trigsRigidBodyBased.NumberOfItems() + globalContactIndexOffsets.Last());

	//jacobians have different offset lists:
	globalJacobianIndexOffsets.Flush();
	globalJacobianIndexOffsets.Append(0); //first entry is first offset
	//**ICI individual contact implementation; order of calls must agree with according ...Index variable in GeneralContact
	globalJacobianIndexOffsets.Append(spheresMarkerBased.NumberOfItems() + globalJacobianIndexOffsets.Last());
	globalJacobianIndexOffsets.Append(ancfCable2D.NumberOfItems() + globalJacobianIndexOffsets.Last()); //ANCF has no jacobians, but LTG!!!
	globalJacobianIndexOffsets.Append(rigidBodyMarkerBased.NumberOfItems() + globalJacobianIndexOffsets.Last());

	//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//do everything for contact objects:
	allBoundingBoxes.SetNumberOfItems(TotalContactObjects());
	allActiveContacts.SetNumberOfItems(TotalContactObjects());
	allActiveContactsVector.SetNumberOfItems(TotalContactObjects());
	for (Index gi = 0; gi < TotalContactObjects(); gi++)
	{
		allActiveContacts[gi] = new ArrayIndex();
		allActiveContactsVector[gi] = new ResizableArray<Vector3D>();
	}


	//do everything for jacobians:
	allPositionJacobians.SetNumberOfItems(TotalJacobians());
	allRotationJacobians.SetNumberOfItems(TotalJacobians());
	allLTGs.SetNumberOfItems(TotalJacobians());
	//compute jacobians and LTGs for marker-based and other contact objects where jacobian is needed
	//pout << "initialize data, total objects=" << TotalContactObjects() << "\n";
	//pout << globalContactIndexOffsets << "\n";
	bool hasPositionMarker = false; //check if there is any (possibly wrong) positionMarker

	for (Index gi = 0; gi < TotalJacobians(); gi++)
	{
		//**ICI individual contact implementation: add LTGs for according element
		//pout << "gi=" << gi << ", max(i)=" << globalContactIndexOffsets[spheresMarkerBasedIndex + 1] << "\n";
		//pout << "globalJacobianIndexOffsets[spheresMarkerBasedIndex + 1]=" << globalJacobianIndexOffsets[spheresMarkerBasedIndex + 1] << "\n";
		
		if (gi < globalJacobianIndexOffsets[spheresMarkerBasedIndex + 1]) //first are the spheres
		{
			Index i = gi - globalJacobianIndexOffsets[spheresMarkerBasedIndex];
			allPositionJacobians[gi] = new ResizableMatrix();
			allRotationJacobians[gi] = new ResizableMatrix();
			allLTGs[gi] = new ArrayIndex();
			Index markerNumber = spheresMarkerBased[i].markerIndex;
			if (markerNumber >= cSystem.GetSystemData().GetCMarkers().NumberOfItems())
			{
				PyError("Assemble() / FinalizeContact: illegal marker Number of sphereMarkerBased / circle " + EXUstd::ToString(i));
			}
			else if (!EXUstd::IsOfType(cSystem.GetSystemData().GetCMarkers()[markerNumber]->GetType(), Marker::Position))
			{
				PyError("Assemble() / FinalizeContact: sphereMarkerBased / circle " + EXUstd::ToString(i) + " has invalid marker: must be of Position or Position+Orientation");
			}

			if (!EXUstd::IsOfType(cSystem.GetSystemData().GetCMarkers()[markerNumber]->GetType(), Marker::Orientation)) { hasPositionMarker = true; }

			cSystem.GetSystemData().ComputeMarkerODE2LTGarray(markerNumber, *(allLTGs[gi]), true); //true=reset list before appending
			//pout << "marker=" << markerNumber << ", LTG" << gi << ":" << *allLTGs[gi] << "\n";
		}
		else if (gi < globalJacobianIndexOffsets[ancfCable2DIndex + 1])
		{
			Index i = gi - globalJacobianIndexOffsets[ancfCable2DIndex];
			allPositionJacobians[gi] = nullptr; //ANCF does not need jacobian, it just provides the shape matrix ...
			allRotationJacobians[gi] = nullptr;
			allLTGs[gi] = new ArrayIndex();

			auto& item = ancfCable2D[(Index)i];

			Index objectIndex = item.objectIndex;
			if (objectIndex < 0 || objectIndex >= cSystem.GetSystemData().GetCObjects().NumberOfItems())
			{
				PyError("Assemble() / FinalizeContact: ancfCable " + EXUstd::ToString(i) + " has illegal object index " + EXUstd::ToString(objectIndex));
			}
			if (typeid(*cSystem.GetSystemData().GetCObjects()[objectIndex]) != typeid(CObjectANCFCable2D))
			{
				PyError("Assemble() / FinalizeContact: ancfCable " + EXUstd::ToString(i) + " is not a valid ANCFCable2D");
			}
			else
			{
				item.L = ((CObjectANCFCable2D*)(cSystem.GetSystemData().GetCObjects()[objectIndex]))->GetLength();
			}

			allLTGs[gi]->CopyFrom(cSystem.GetSystemData().GetLocalToGlobalODE2()[item.objectIndex]);
			if (verboseMode>=2){
				pout << "ancfLTG" << gi << "=" << *allLTGs[gi] << "\n";}
		}
		else if (gi < globalJacobianIndexOffsets[rigidBodyMarkerBasedIndex + 1])
		{
			Index i = gi - globalJacobianIndexOffsets[rigidBodyMarkerBasedIndex];

			allPositionJacobians[gi] = new ResizableMatrix();
			allRotationJacobians[gi] = new ResizableMatrix();
			allLTGs[gi] = new ArrayIndex();

			Index markerNumber = rigidBodyMarkerBased[i].markerIndex;
			if (markerNumber >= cSystem.GetSystemData().GetCMarkers().NumberOfItems())
			{
				PyError("Assemble() / FinalizeContact: illegal marker Number of rigidBodyMarkerBased " + EXUstd::ToString(i));
			}
			else if (!EXUstd::IsOfType((Index)cSystem.GetSystemData().GetCMarkers()[markerNumber]->GetType(), (Index)Marker::Position+(Index)Marker::Orientation))
			{
				PyError("Assemble() / FinalizeContact: rigidBodyMarkerBased " + EXUstd::ToString(i) + " has invalid marker: must be of Position+Orientation");
			}

			cSystem.GetSystemData().ComputeMarkerODE2LTGarray(markerNumber, *(allLTGs[gi]), true); //true=reset list before appending
			//pout << "RBM" << i << ", marker=" << markerNumber << ", LTG=" << *(allLTGs[gi]) << "\n";
		}
		else
		{
			CHECKandTHROWstring("FinalizeContact: case not implemented!");
			//Index i = gi - globalJacobianIndexOffsets[spheresMarkerBasedIndex];
			//allPositionJacobians[gi] = nullptr;
			//allRotationJacobians[gi] = nullptr;
			//allLTGs[gi] = nullptr;
		}
	}

	//for spheres, some warning
	if (maxFrictionCoeff > 0. && hasPositionMarker)
	{
		PyWarning("FinalizeContact(...): sphereMarkerBased: friction coefficients are != 0, but some sphere/circle markers contain position based markers (no orientation), which will not work as intended with friction!");
	}

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//search tree autocompute must be done after creation of bounding boxes and initializations of jacobians
	Box3D searchTreeBox;
	searchTreeBox.SetPMin(settings.searchTreeBoxMinInit); //this initialization gives Empty()=true or the specified value
	searchTreeBox.SetPMax(settings.searchTreeBoxMaxInit); //this initialization gives Empty()=true or the specified value

	TemporaryComputationDataArray tempArray; //will allocate memory, but just done in finalize contact
    //data.tempCompDataArray.EraseData();		//totally reset; for safety for now!
    Index nThreads = exuThreading::TaskManager::GetNumThreads();
    tempArray.SetNumberOfItems(nThreads);
    SetNumberOfThreads(nThreads);

    if (searchTreeBox.Empty())
	{
		//pout << "auto compute searchTree box\n";
		//CHECKandTHROWstring("GeneralContact::FinalizeContact(...): autocompute searchTreeBox not implemented (specify a valid range!)");
		ComputeContactDataAndBoundingBoxes(cSystem, tempArray, true, false); //compute initial bounding boxes for auto-compute searchTree size

		for (const Box3D& box : allBoundingBoxes)
		{
			//pout << "add box " << box << " ==> " << searchTreeBox << "\n";
			searchTreeBox.Add(box);
		}
		if (verboseMode >= 1) { pout << "auto computed searchTree box=" << searchTreeBox << "\n"; }
	}
	if (verboseMode >= 2) { pout << "FinalizeContact: reset searchtree\n"; }
	searchTree.ResetSearchTree(settings.searchTreeSizeInit[0], settings.searchTreeSizeInit[1], settings.searchTreeSizeInit[2], searchTreeBox);
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	Real recommendedStepSize = 1; //not used
	//if (verboseMode >= 2) { pout << "FinalizeContact: call PostNewtonStep\n"; }
	PostNewtonStep(cSystem, tempArray, recommendedStepSize);
	if (settings.computeContactForces)
	{
		systemODE2RhsContactForces.SetNumberOfItems(cSystem.GetSystemData().GetNumberOfCoordinatesODE2());
		systemODE2RhsContactForces.SetAll(0.);
	}
	//if (verboseMode >= 2) { pout << "FinalizeContact: finish\n"; }
	contactIsFinalized = true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! unified function to compute contact forces, in particular for unification to compute derivatives for jacobians
template<Index opMode, typename TReal>
TReal GeneralContact::ComputeContactForces(TReal gap, const SlimVectorBase<TReal,3>& n0, 
	TReal deltaVnormal, const SlimVectorBase<TReal,3>& deltaVji,
	TReal kContact, TReal dContact, TReal dryFriction, bool frictionRegularizedRegion, const SlimVectorBase<TReal,3>& storedFFriction,
	SlimVectorBase<TReal,3>& fVec, SlimVectorBase<TReal,3>& fFriction)
{
	//compute scalar force:
	TReal contactForce = kContact * gap + dContact * deltaVnormal; //in case of contact, must be negative

	fVec = contactForce * n0; //this is the force pointing from sphereJ to sphereI
	if (dryFriction != 0.)
	{
		//global sphere velocity at contact point:
		SlimVectorBase<TReal,3> deltaVtangent = deltaVji - deltaVnormal * n0;	//tangent velocity
		TReal relVel;
		if (opMode != CCode2rhsFromActiveSets) //most important for explicit integrators
		{
			frictionRegularizedRegion = ContactHelper::ComputeFrictionForce<SlimVectorBase<TReal,3>, TReal, false>(fFriction, deltaVtangent, -contactForce,
				dryFriction, settings.frictionProportionalZone, relVel);
		}
		else
		{
			//friction mode is given from frictionRegularizedRegion!
			ContactHelper::ComputeFrictionForce<SlimVectorBase<TReal,3>, TReal, true>(fFriction, deltaVtangent, -contactForce, dryFriction,
				settings.frictionProportionalZone, relVel, frictionRegularizedRegion);

			/*
			//assure that sign is preserved over Newton iterations:
			if (!frictionRegularizedRegion && (fFriction * (*allActiveContactsVector[gi])[contactCnt] < 0)) { fFriction *= -1.; }
			*/

			//the following option helps to avoid Newton problems for switching friction sign:
			//==> but leads to unphysical effects!
			if (!frictionRegularizedRegion && settings.sphereSphereFrictionRecycle) { fFriction = storedFFriction; }

		}
		fVec += fFriction;
	}
	return contactForce;
}


//! general function to compute the jacobian for a regularized frictional contact between two points
inline void ComputeContactForceJacobian(
	const GeneralContactSettings& settings,
	Real dryFriction, Real factorODE2, Real factorODE2_t, bool computeFrictionTerms, Real factNormalContact,
	Real Linv, const Vector3D& n0, const Vector3D& deltaVJI, Real dContact, Real contactForce,
	const Vector3D& deltaVtangent, Real& factRegularizedFriction, Matrix3D& JacFc)
{

	//compute stiffness matrix in direction of contact, analogously to SpringDamper
	//Jj = d(k*deltaP^T*dp/dqj)/dqj, Ji = d(-k*deltaP^T*dp/dqi)/dqi
	//Jj = k*(dp/dqj)^T*dp/dqj, ...

	//rows of jacobian = dimension of position = always 3
	//columns of jacobians = coordinates, may be different

	//special matrix needed several times (without factor 1/L):
	Matrix3D IsubNN;
	IsubNN.SetWithDiadicProduct(-n0, n0);
	IsubNN(0, 0) += 1.;
	IsubNN(1, 1) += 1.;
	IsubNN(2, 2) += 1.;
	//+++++++++++++++++++++++++++++++++++++++++++++++
	//d(fc)/dq + d(fc)/dq_t:
	//Real factNormal = factorODE2 * kContact + factorODE2_t * dContact; //normal direction gives same terms for stiffness and velocity

	Vector3D n0mu = n0;
	if (computeFrictionTerms) //second check not necessary, but used for safety!
	{
		n0mu -= dryFriction / settings.frictionProportionalZone * deltaVtangent;
	}
	JacFc.SetWithDiadicProduct(factNormalContact * n0mu, n0);


	//add d_c*d(v_n)/dq:
	Matrix3D JacFcAdd;
	Vector3D vAdd = (factorODE2 * dContact * Linv) * deltaVJI; //no difference if center velocity or tangent vel.
	JacFcAdd.SetWithDiadicProduct(n0mu, vAdd * IsubNN);
	JacFc += JacFcAdd;
	//+++++++++++++++++++++++++++++++++++++++++++++++
	//Matrix3D JacFcFriction; //factor*(I - n0 x n0)

	if (computeFrictionTerms)
	{
		factRegularizedFriction = factorODE2_t * contactForce * dryFriction / settings.frictionProportionalZone;

		//negative sign checked:
		JacFc += (-factRegularizedFriction) * IsubNN;
	}

	//++++++++++++++++++++++++++++++++++++++++
	//added terms: f_c * d(n_0)/dq (influence is small ...)
	// factorODE*f_c*1/L (I - diad(n0,n0) )
	JacFc += (Linv * factorODE2 * contactForce) * IsubNN;
}


//! function to add jacobian terms to triplets in unified way
inline void AddJacobianTerms(TemporaryComputationData& tempArrayThreadID,
	Index columnsi, Index columnsj, const ResizableMatrix& JACi, const ResizableMatrix& JACj,
	Index rotColumnsi, Index rotColumnsj, const ResizableMatrix& rotJACi, const ResizableMatrix& rotJACj,
 	const ArrayIndex& allLTGsGi, const ArrayIndex& allLTGsGj,
	const Matrix3D& rTildeNI, const Matrix3D& rTildeNJ, bool computeFrictionTerms, Real factRegularizedFriction,
	const Matrix3D& JacFc, const Matrix3D& JacTorqueFc,
	SparseTripletVector& triplets)
{
	ResizableMatrix& m = tempArrayThreadID.localJacobian;
	ResizableMatrix& temp = tempArrayThreadID.localJacobian_t; //used as temporary matrix
	ResizableMatrix& temp2 = tempArrayThreadID.loadJacobian;   //used as temporary matrix

	if (columnsj) //in case of ground elements ...
	{
		//force part jj:
		//JposJ.T*d(Fc)/dposJ*JposJ 
		EXUmath::MultMatrixMatrixTemplate(JacFc, JACj, temp);

		if (computeFrictionTerms && rotColumnsj != 0)
		{
			//JposJ.T*d(Fc)/drotJ*JrotJ
			EXUmath::MultMatrixMatrixTemplate(-factRegularizedFriction * rTildeNJ, rotJACj, temp2);

			temp += temp2;
		}
		EXUmath::MultMatrixTransposedMatrixTemplate(JACj, temp, m);

		//torque part jj:
		if (computeFrictionTerms && rotColumnsj != 0)
		{
			//JrotJ.T*(d(TcJ)/drotJ*JrotJ + d(Tc)/dposJ*JposJ)
			Matrix3D JacTorqueJ; //JacFcFriction includes factorODE2_t
			JacTorqueJ = factRegularizedFriction * rTildeNJ;
			EXUmath::MultMatrixMatrixTemplate(JacTorqueJ * rTildeNJ, rotJACj, temp2);

			EXUmath::MultMatrixMatrixTemplate(JacTorqueJ + rTildeNJ * JacTorqueFc, JACj, temp);
			temp2 += temp;
			EXUmath::MultMatrixTransposedMatrixTemplate(rotJACj, temp2, temp);
			m += temp;
		}
		EXUmath::AddMatrixToSparseTripletVector(triplets, m, allLTGsGj, allLTGsGj);

		if (columnsi)
		{
			//force part ji: //negative sign added to JacFc term and removed from rnA term
			//JposJ.T*d(Fc)/dposI*JposI
			EXUmath::MultMatrixMatrixTemplate(-1. * JacFc, JACi, temp);

			if (computeFrictionTerms && rotColumnsi != 0)
			{
				//JposJ.T*d(Fc)/drotI*JrotI
				EXUmath::MultMatrixMatrixTemplate(-factRegularizedFriction * rTildeNI, rotJACi, m);

				temp += m;
			}
			EXUmath::MultMatrixTransposedMatrixTemplate(JACj, temp, m);

			//torque part ji:
			//JrotJ.T*(d(TcJ)/drotI*JrotI + d(Tc)/dposI*JposI)
			if (computeFrictionTerms && rotColumnsi != 0)
			{
				Matrix3D JacTorqueJ; //JacFcFriction includes factorODE2_t
				JacTorqueJ = factRegularizedFriction * rTildeNJ;
				EXUmath::MultMatrixMatrixTemplate(JacTorqueJ * rTildeNI, rotJACi, temp2);
				EXUmath::MultMatrixMatrixTemplate(JacTorqueJ + rTildeNJ * JacTorqueFc, JACi, temp);
				temp2 -= temp;
				EXUmath::MultMatrixTransposedMatrixTemplate(rotJACj, temp2, temp);
				m += temp;
			}

			EXUmath::AddMatrixToSparseTripletVector<ResizableMatrix, false>(triplets, m, allLTGsGj, allLTGsGi, 1.);

			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//force part ij: 
			//JposI.T*d(Fc)/dposJ*JposJ
			EXUmath::MultMatrixMatrixTemplate(-1. * JacFc, JACj, temp);

			if (computeFrictionTerms && rotColumnsj != 0)
			{
				//JposI.T*d(Fc)/drotJ*JrotJ //additional *(-1) due to -Jaci compensates negative sign
				EXUmath::MultMatrixMatrixTemplate(factRegularizedFriction * rTildeNJ, rotJACj, m);

				temp += m;
			}
			EXUmath::MultMatrixTransposedMatrixTemplate(JACi, temp, m);

			//torque part ij:
			//JrotI.T*(d(TcI)/drotJ*JrotJ + d(Tc)/dposJ*JposJ)
			if (computeFrictionTerms && rotColumnsj != 0)
			{
				Matrix3D JacTorqueI; //JacFcFriction includes factorODE2_t
				JacTorqueI = factRegularizedFriction * rTildeNI;
				EXUmath::MultMatrixMatrixTemplate(JacTorqueI * rTildeNJ, rotJACj, temp2);
				EXUmath::MultMatrixMatrixTemplate(JacTorqueI + rTildeNI * JacTorqueFc, JACj, temp);
				temp2 += temp;
				EXUmath::MultMatrixTransposedMatrixTemplate(rotJACi, temp2, temp);
				m += temp;
			}

			EXUmath::AddMatrixToSparseTripletVector<ResizableMatrix, false>(triplets, m, allLTGsGi, allLTGsGj, 1.);

		}
	}

	if (columnsi)
	{
		//force part ii:
		EXUmath::MultMatrixMatrixTemplate(JacFc, JACi, temp);

		if (computeFrictionTerms && rotColumnsi != 0)
		{
			//JposI.T*d(Fc)/drotI*JrotI
			//SIGN change due to JposI
			EXUmath::MultMatrixMatrixTemplate(factRegularizedFriction * rTildeNI, rotJACi, temp2);

			temp += temp2;
		}
		EXUmath::MultMatrixTransposedMatrixTemplate(JACi, temp, m);

		//torque part ii:
		if (computeFrictionTerms && rotColumnsi != 0)
		{
			//JrotI.T*(d(TcJ)/drotI*JrotI + d(Tc)/dposI*JposI)
			Matrix3D JacTorqueI; //JacFcFriction includes factorODE2_t
			JacTorqueI = factRegularizedFriction * rTildeNI;
			EXUmath::MultMatrixMatrixTemplate(JacTorqueI * rTildeNI, rotJACi, temp2);
			EXUmath::MultMatrixMatrixTemplate(JacTorqueI + rTildeNI * JacTorqueFc, JACi, temp);
			temp2 -= temp;  //SIGN as in theDoc
			EXUmath::MultMatrixTransposedMatrixTemplate(rotJACi, temp2, temp);
			m += temp;
		}
		EXUmath::AddMatrixToSparseTripletVector(triplets, m, allLTGsGi, allLTGsGi);

	}
}









//! compute temporary data and bounding boxes
void GeneralContact::ComputeContactDataAndBoundingBoxes(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, 
	bool updateBoundingBoxes, bool addToSearchTree)
{
	STARTGLOBALTIMERmain(TSboundingBoxes);

	if (verboseMode >= 2) pout << "  **update Data, BB=" << updateBoundingBoxes << ", ST=" << addToSearchTree << "\n";
	Index nThreads = exuThreading::TaskManager::GetNumThreads(); //must agree with tempArray
    tempArray.SetNumberOfItems(nThreads);
    SetNumberOfThreads(nThreads);
    //CHECKandTHROW(tempArray.NumberOfItems() == nThreads, "GeneralContact::ComputeContactDataAndBoundingBoxes: inconsistent tempArray and number of threads; try to restart kernel!");


	ComputeDataAndBBmarkerBasedSpheres(cSystem.GetSystemData(), tempArray, nThreads, updateBoundingBoxes);
	ComputeDataAndBBancfCable2D(cSystem.GetSystemData(), tempArray, nThreads, updateBoundingBoxes);
	ComputeDataAndBBtrigsRigidBodyBased(cSystem.GetSystemData(), tempArray, nThreads, updateBoundingBoxes);

	STOPGLOBALTIMERmain(TSboundingBoxes);

	if (updateBoundingBoxes && addToSearchTree)
	{
		STARTGLOBALTIMERmain(TSsearchTree);
		searchTreeUpdateCounter++;
		if (searchTreeUpdateCounter > settings.resetSearchTreeInterval)
		{
			searchTree.FlushCells(); //keeps search tree in general, but flushes sub-cell memory
			searchTreeUpdateCounter = 0;
		}
		searchTree.ClearItems();
		Index gi = 0;
		for (const auto& box : allBoundingBoxes)
		{
			searchTree.AddItem(box, gi++);
		}
		if (verboseMode >= 2)
		{
			Index gi = 0;
			for (const auto& box : allBoundingBoxes)
			{
				pout << "bounding box " << gi++ << ": " << box << "\n";
			}
		}
		STOPGLOBALTIMERmain(TSsearchTree);
	}
	initializeData = false; //initialized in FinalizeContact
}

void GeneralContact::ComputeDataAndBBmarkerBasedSpheres(const CSystemData& systemData, TemporaryComputationDataArray& tempArray,
	Index nThreads, bool updateBoundingBoxes)
{
	NGSsizeType nItems = (NGSsizeType)spheresMarkerBased.NumberOfItems();
	//pout << "n spheres=" << nItems << "\n";
	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems > 400 * nThreads) { taskSplit = 100 * nThreads; }

	exuThreading::ParallelFor(nItems, [this, &systemData, &tempArray, &updateBoundingBoxes, &nItems](NGSsizeType j) //(NGSsizeType j)
	//for (auto& item : spheresMarkerBased)
	{
		const bool computeJacobian = true; //good question, if jacobians should be precomputed; if many active contacts, this is better
		auto& item = spheresMarkerBased[(Index)j];
		Index threadID = exuThreading::TaskManager::GetThreadId();

		MarkerData& markerData = tempArray[threadID].markerDataStructure.GetMarkerData(0);
		Index gi = (Index)j + globalJacobianIndexOffsets[spheresMarkerBasedIndex]; //
		//temporary data:
		systemData.GetCMarker(item.markerIndex).ComputeMarkerData(systemData, computeJacobian, markerData);
		item.position = markerData.position;
		item.velocity = markerData.velocity;
		this->allPositionJacobians[gi]->CopyFrom(markerData.positionJacobian);
		if (EXUstd::IsOfType(systemData.GetCMarker(item.markerIndex).GetType(), Marker::Orientation))
		{
			item.orientation = markerData.orientation;
			item.angularVelocity = markerData.angularVelocityLocal;
			this->allRotationJacobians[gi]->CopyFrom(markerData.rotationJacobian);
		}
		else
		{
			//use size from position jacobian (has same dimension 3 x n, independent of rotation parameterization):
			if (this->allRotationJacobians[gi]->NumberOfRows() != markerData.positionJacobian.NumberOfRows() ||
				this->allRotationJacobians[gi]->NumberOfColumns() != markerData.positionJacobian.NumberOfColumns())
			{
				//just done once, hereafter it should be always correct!
				this->allRotationJacobians[gi]->SetNumberOfRowsAndColumns(markerData.positionJacobian.NumberOfRows(), markerData.positionJacobian.NumberOfColumns());
			}
			if (initializeData)
			{
				item.orientation = EXUmath::unitMatrix3D;
				item.angularVelocity.SetAll(0.);
				this->allRotationJacobians[gi]->SetAll(0.);
			}
		}

		if (updateBoundingBoxes)
		{
			//bounding box:
			Vector3D vr({ item.radius, item.radius, item.radius });
			//pout << "update=" << item.position << "\n";
			this->allBoundingBoxes[gi].SetPMin(item.position - vr);
			this->allBoundingBoxes[gi].SetPMax(item.position + vr);
		}
	}, taskSplit); //nTasksPerThread
}

//! compute bounding boxes for ANCFCable2D (no data necessary)
void GeneralContact::ComputeDataAndBBancfCable2D(const CSystemData& systemData, TemporaryComputationDataArray& tempArray,
	Index nThreads, bool updateBoundingBoxes)
{
	NGSsizeType nItems = (NGSsizeType)ancfCable2D.NumberOfItems();
	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems > 400 * nThreads) { taskSplit = 100 * nThreads; }

	exuThreading::ParallelFor(nItems, [this, &systemData, &tempArray, &updateBoundingBoxes, &nItems](NGSsizeType j) //(NGSsizeType j)
	//for (auto& item : spheresMarkerBased)
	{
		auto& item = ancfCable2D[(Index)j];
		//Index threadID = exuThreading::TaskManager::GetThreadId();

		//MarkerData& markerData = tempArray[threadID].markerDataStructure.GetMarkerData(0);
		Index gj = (Index)j + globalJacobianIndexOffsets[ancfCable2DIndex]; //

		const CObjectANCFCable2DBase& ancf = (const CObjectANCFCable2DBase&)systemData.GetCObjectBody(item.objectIndex);
		ConstSizeVector<8> ancfCoords;
		ancf.ComputeCurrentObjectVelocities(ancfCoords);
		item.coordinates_t.CopyFrom(ancfCoords);
		ancf.ComputeCurrentObjectCoordinates(ancfCoords);
		item.coordinates.CopyFrom(ancfCoords);

		item.L = ancf.GetLength();
		item.isALE = false;
		CHECKandTHROW(ancf.GetODE2Size() == 8, "GeneralContact::ComputeDataAndBBancfCable2D: ALEANCF not implemented!");

		if (updateBoundingBoxes)
		{
			ConstSizeVector<4> c4x;
			ConstSizeVector<4> c4y;
			Real fMinX, fMaxX;
			Real fMinY, fMaxY;
			CObjectANCFCable2DBase::ComputePolynomialCoeffs<ConstSizeVector<8>>(ancfCoords, item.L, c4x, c4y);
			ContactHelper::ComputePoly3rdOrderMinMax(c4x, item.L, fMinX, fMaxX);
			ContactHelper::ComputePoly3rdOrderMinMax(c4y, item.L, fMinY, fMaxY);

			Box3D box(Vector3D({fMinX, fMinY, 0.}), Vector3D({fMaxX, fMaxY, 0.}));
			box.Increase(item.halfHeight* 1.414213562373096, item.halfHeight* 1.414213562373096, 0.); //in all directions, worst case is 45°
			this->allBoundingBoxes[gj] = box;

			/*
			Vector3D pos0({ item.coordinates[0], item.coordinates[1], 0. });
			Vector3D pos1({ item.coordinates[4], item.coordinates[5], 0. });
			//bounding box:
			Vector3D vr({ item.L, item.L, 0. });
			//pout << "update=" << item.position << "\n";
			Box3D box(pos0 - vr, pos0 + vr);
			box.Add(pos1 - vr);
			box.Add(pos1 + vr);
			this->allBoundingBoxes[gj]=box;
			*/
		}
	}, taskSplit); //nTasksPerThread
}

//! compute Data for rigidBodyMarkerBased and bounding boxes for trigsRigidBodyBased
void GeneralContact::ComputeDataAndBBtrigsRigidBodyBased(const CSystemData& systemData, TemporaryComputationDataArray& tempArray,
	Index nThreads, bool updateBoundingBoxes)
{
	//CHECKandTHROWstring("GeneralContact::ComputeDataAndBBtrigsRigidBodyBased: not implemented");

	//compute marker data; assume only small number of rigid bodies (<1000) with large number of triangles ==> done serially
	MarkerData& markerData = tempArray[0].markerDataStructure.GetMarkerData(0);
	for (Index j = 0; j < rigidBodyMarkerBased.NumberOfItems(); j++)
	{
		auto& item = rigidBodyMarkerBased[j];
		Index gi = (Index)j + globalJacobianIndexOffsets[rigidBodyMarkerBasedIndex]; //
		//temporary data:
		const bool computeJacobian = true; //good question, if jacobians should be precomputed; if many active contacts, this is better
		systemData.GetCMarker(item.markerIndex).ComputeMarkerData(systemData, computeJacobian, markerData);

		item.position = markerData.position;
		item.velocity = markerData.velocity;
		this->allPositionJacobians[gi]->CopyFrom(markerData.positionJacobian);

		//rigid body works also without orientation ...
		if (EXUstd::IsOfType(systemData.GetCMarker(item.markerIndex).GetType(), Marker::Orientation))
		{
			item.orientation = markerData.orientation;
			item.angularVelocity = markerData.angularVelocityLocal;
			this->allRotationJacobians[gi]->CopyFrom(markerData.rotationJacobian);
		}
		else
		{
			//use size from position jacobian (has same dimension 3 x n, independent of rotation parameterization):
			this->allRotationJacobians[gi]->SetNumberOfRowsAndColumns(markerData.positionJacobian.NumberOfRows(), markerData.positionJacobian.NumberOfColumns());
			this->allRotationJacobians[gi]->SetAll(0.);
			if (initializeData) //only done once
			{
				item.orientation = EXUmath::unitMatrix3D;
				item.angularVelocity.SetAll(0.);
				this->allRotationJacobians[gi]->SetAll(0.);
			}
		}

	}

	//bounding boxes computed in parallel:
	if (updateBoundingBoxes)
	{
		NGSsizeType nItems = (NGSsizeType)trigsRigidBodyBased.NumberOfItems();
		Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
		if ((Index)nItems > 400 * nThreads) { taskSplit = 100 * nThreads; }

		exuThreading::ParallelFor(nItems, [this, &systemData, &tempArray, &updateBoundingBoxes, &nItems](NGSsizeType j) //(NGSsizeType j)
		{
			const ContactTriangleRigidBodyBased& item = trigsRigidBodyBased[(Index)j];
			//Index threadID = exuThreading::TaskManager::GetThreadId();
			Index gi = (Index)j + globalJacobianIndexOffsets[trigsRigidBodyBasedIndex]; //

			const ContactRigidBodyMarkerBased& rigidMarker = rigidBodyMarkerBased[item.contactRigidBodyIndex];

			Box3D box; //empty box

			for (Index i = 0; i < (Index)item.points.size(); i++)
			{
				box.Add(rigidMarker.orientation * item.points[i] + rigidMarker.position);
			}
			this->allBoundingBoxes[gi] = box;

		}, taskSplit); //nTasksPerThread
	}
}




//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
template<Index opMode>
void GeneralContact::ComputeContact(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
    Index nThreads = exuThreading::TaskManager::GetNumThreads(); //must agree with tempArray
    tempArray.SetNumberOfItems(nThreads);
    SetNumberOfThreads(nThreads);
    CHECKandTHROW(tempArray.NumberOfItems() == nThreads, "GeneralContact::ComputeContact: inconsistent tempArray and number of threads; try to restart kernel!");

	if (verboseMode >= 2) { pout << "ComputeContact: start\n"; }

	//not needed if CCode2rhsFromActiveSets:
	if (opMode & (CCode2rhsFull + CCactiveSets))
	{
		ComputeContactDataAndBoundingBoxes(cSystem, tempArray, true, true);
	}
	else
	{
		ComputeContactDataAndBoundingBoxes(cSystem, tempArray, false, false);
	}

	//only in case of ODE2rhs computation:
	if (opMode & (CCode2rhsFull + CCode2rhsFromActiveSets))
	{
		//if (verboseMode >= 2) { pout << "ComputeContact: initialize sparse vectors\n"; }
		for (Index i = 0; i < nThreads; i++)
		{
			tempArray[i].sparseVector.SetAllZero();
		}
	}

	if (opMode & CCactiveSets)
	{
		if (verboseMode >= 2) pout  << "** clear active contacts **\n";
		EXUstd::ArrayOfArraysSetNumberOfItems0(allActiveContacts);
		EXUstd::ArrayOfArraysSetNumberOfItems0(allActiveContactsVector);
	}

	//**ICI individual contact implementation
	if (settings.sphereSphereContact)
	{
		if (verboseMode >= 2) { pout << "ComputeContact: ComputeContactMarkerBasedSpheres\n"; }
		ComputeContactMarkerBasedSpheres<opMode>(tempArray, nThreads);
	}
	if (ancfCable2D.NumberOfItems())
	{
		if (verboseMode >= 2) { pout << "ComputeContact: ComputeContactANCFCable2D\n"; }
		ComputeContactANCFCable2D<opMode>(cSystem, tempArray, nThreads);
	}
	if (verboseMode >= 2) { pout << "ComputeContact: ComputeContactTrigsRigidBodyBased\n"; }
	ComputeContactTrigsRigidBodyBased<opMode>(tempArray, nThreads);

	if (opMode & (CCode2rhsFull + CCode2rhsFromActiveSets))
	{
		if (verboseMode >= 2) { pout << "ComputeContact: systemODE2Rhs\n"; }
		//serial section for writing into system vector
		if (settings.computeContactForces)
		{
			systemODE2RhsContactForces.CopyFrom(systemODE2Rhs);
			systemODE2RhsContactForces *= -1.;
		}
		for (Index i = 0; i < nThreads; i++)
		{
			for (const EXUmath::IndexValue& item : tempArray[i].sparseVector.GetSparseIndexValues())
			{
				systemODE2Rhs[item.GetIndex()] -= item.GetValue(); //minus: LHS->RHS
			}
		}
		if (settings.computeContactForces)
		{
			systemODE2RhsContactForces += systemODE2Rhs;
		}
	}
}


//! specific Data and bounding box computation
template<Index opMode>
void GeneralContact::ComputeContactMarkerBasedSpheres(TemporaryComputationDataArray& tempArray, Index nThreads)
{
	//loop over all contact spheres:
	NGSsizeType nItems = (NGSsizeType)spheresMarkerBased.NumberOfItems();

	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems >= 32 * nThreads)
	{
		if ((Index)nItems < 128 * nThreads) { taskSplit = 16 * nThreads; }
		else { taskSplit = 128 * nThreads; }
	}


	exuThreading::ParallelFor(nItems, [this, &tempArray, &nItems](NGSsizeType i)
		//for (Index i = 0; i < spheresMarkerBased.NumberOfItems(); i++)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();
		ResizableVector& ode2Lhs = tempArray[threadID].localODE2LHS;
		Index index2JacIndex = globalJacobianIndexOffsets[spheresMarkerBasedIndex] - globalContactIndexOffsets[spheresMarkerBasedIndex];

		//+++++++++++++++++++++++++++++

		Index gi = (Index)i + globalContactIndexOffsets[spheresMarkerBasedIndex]; //i is local, gi is global index (which is the same for the first contact objects)
		const ContactSpheresMarkerBased& sphereI = spheresMarkerBased[(Index)i];

		ResizableArray<Index>* contactObjects;
		if (opMode == CCode2rhsFromActiveSets)
		{
			contactObjects = allActiveContacts[gi];
		}
		else
		{
			contactObjects = addedObjects[threadID];
			//determine potential contacts using bounding boxes:
			//if boundingBoxes are pre-checked, this is faster for over-filled search tree boxes
			searchTree.GetSingleItemsInBoxMaxMinIndex(allBoundingBoxes[gi], *contactObjects, *addedObjectsFlags[threadID], allBoundingBoxes,
				globalContactIndexOffsets[spheresMarkerBasedIndex+1], gi);
		}

		bool frictionRegularizedRegion;

		//check if there is really contact:
		for (Index contactCnt = 0; contactCnt < contactObjects->NumberOfItems(); contactCnt++)
		//for (Index gjSign : *contactObjects)
		{
			Index gj;
			if (opMode == CCode2rhsFromActiveSets) { 
				ActiveContact2IndexRegularizedFriction(contactObjects->GetItem(contactCnt), gj, frictionRegularizedRegion); }
			else {gj = contactObjects->GetItem(contactCnt); frictionRegularizedRegion = true;}

			if (!EXUstd::IndexIsInRange(gj, globalContactIndexOffsets[spheresMarkerBasedIndex], 
				globalContactIndexOffsets[spheresMarkerBasedIndex + 1])) { continue; } //run loop only for sphere-sphere!

			const ContactSpheresMarkerBased& sphereJ = spheresMarkerBased[gj - globalContactIndexOffsets[spheresMarkerBasedIndex]];
			Vector3D deltaP(sphereJ.position - sphereI.position); //points from sphereI to sphereJ
			Real dist = deltaP.GetL2Norm();
			Real gap = dist - (sphereI.radius + sphereJ.radius); //gap = -penetration

			//in active set strategy, we always compute the contact, even if there is separation
			if (((opMode == CCode2rhsFromActiveSets) || (gap < 0.)) && dist != 0.)
			{ //now we have contact! sqrt and other functions are slow, but only called for contacts
				//Real dist = sqrt(dist2); //distance of midpoints
				Vector3D n0 = (1. / dist)*deltaP;
				if (verboseMode >= 2) pout << "  ** inside contact computation\n";

				Vector3D vSphereI = sphereI.velocity;
				Vector3D vSphereJ = sphereJ.velocity;
				Real deltaVnormal = n0 * (vSphereJ - vSphereI); //relative velocity in normal direction; to be consistent with jacobian

				Real dryFriction = settings.frictionPairings(sphereI.frictionMaterialIndex, sphereJ.frictionMaterialIndex);
				if (dryFriction != 0.)
				{
					//add gap, as we need to use a common point for the velocity, otherwise we generate an additional torque (e.g. on clusters...)!
					vSphereI += (sphereI.orientation * sphereI.angularVelocity).CrossProduct(( sphereI.radius + 0.5*gap)*n0);
					vSphereJ += (sphereJ.orientation * sphereJ.angularVelocity).CrossProduct((-sphereJ.radius - 0.5*gap)*n0);
					//these two points are identical up to 16 digits:
					//pout << "pi=" << sphereI.position + (sphereI.radius + 0.5 * gap) * n0;
					//pout << ", pj=" << sphereJ.position - (sphereJ.radius + 0.5 * gap) * n0 << "\n";
				}

				Real kContact = sphereI.contactStiffness * sphereJ.contactStiffness / (sphereI.contactStiffness + sphereJ.contactStiffness);

				//damping acts parallel, otherwise if one sphere has 0 damping, the other damping had no influence
				Real dContact = sphereI.contactDamping + sphereJ.contactDamping;

				Real contactForce;
				Vector3D fVec;
				Vector3D fFriction;

				contactForce = ComputeContactForces<opMode, Real>(gap, n0, deltaVnormal, (vSphereJ - vSphereI), kContact, dContact,
					dryFriction, frictionRegularizedRegion, (*allActiveContactsVector[gi])[contactCnt],
					fVec, fFriction);

				if (opMode != CCactiveSets)
				{
					//note that there are small roundoff errors, which causes slight non-symmetry in forces and accumulated errors in time integration!
					if ((opMode == CCode2rhsFromActiveSets) || contactForce < 0.)
					{
						//add generalized forces:
						//marker J (positive):    (according to computation of relative position)
						if (allPositionJacobians[gj + index2JacIndex]->NumberOfColumns() != 0) //special case: COGround has (0,0) Jacobian
						{
							EXUmath::MultMatrixTransposedVector(*allPositionJacobians[gj + index2JacIndex], fVec, ode2Lhs);
							if (dryFriction != 0. && allRotationJacobians[gj + index2JacIndex]->NumberOfColumns() != 0)
							{
								//add torque
								EXUmath::MultMatrixTransposedVectorAdd(*allRotationJacobians[gj + index2JacIndex], (( -sphereJ.radius - 0.5*gap)*n0).CrossProduct(fVec), ode2Lhs);
							}
							//pout << "lhs j=" << ode2Lhs << "\n";
							//add to systemvector:
							for (Index k = 0; k < ode2Lhs.NumberOfItems(); k++)
							{
								tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[gj + index2JacIndex]->GetItem(k), ode2Lhs[k]); //added positive (LHS)
								//systemODE2Rhs[allLTGs[gj]->GetItem(k)] -= ode2Lhs[k]; //minus: LHS->RHS
							}
						}

						//marker I (negative):
						if (allPositionJacobians[gi + index2JacIndex]->NumberOfColumns() != 0) //special case: COGround has (0,0) Jacobian
						{
							EXUmath::MultMatrixTransposedVector(*allPositionJacobians[gi + index2JacIndex], -fVec, ode2Lhs);
							if (dryFriction != 0. && allRotationJacobians[gi + index2JacIndex]->NumberOfColumns() != 0)
							{
								//add torque
								EXUmath::MultMatrixTransposedVectorAdd(*allRotationJacobians[gi + index2JacIndex], (( -sphereI.radius - 0.5*gap)*n0).CrossProduct(fVec), ode2Lhs);
							}
							//pout << "lhs i=" << ode2Lhs << "\n";
							//add to systemvector:
							for (Index k = 0; k < ode2Lhs.NumberOfItems(); k++)
							{
								tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[gi + index2JacIndex]->GetItem(k), ode2Lhs[k]); //added positive (LHS)
								//systemODE2Rhs[allLTGs[gi]->GetItem(k)] -= ode2Lhs[k]; //minus: LHS->RHS
							}
						}
					}
				}
				else //compute active sets/PostNewton
				{
					if (contactForce < 0.) //may be positive because of velocity term
					{
						frictionRegularizedRegion = true;
						if (dryFriction != 0.)
						{
							Vector3D deltaVtangent = (vSphereJ - vSphereI) - deltaVnormal * n0;	//tangent velocity
							frictionRegularizedRegion = (deltaVtangent.GetL2Norm() < settings.frictionProportionalZone);
							//if (gj > 2) pout << "PN: j=" << gjSign << ", fricReg=" << frictionRegularizedRegion << ", n0=" << n0 << ", vN=" << deltaVnormal << ", dV(J-I)=" << (vSphereJ - vSphereI) << ", deltaVtang=" << deltaVtangent << "\n";

							allActiveContactsVector[gi]->AppendPure(fFriction); //only in case of friction!

							if (verboseMode >= 2) pout << "  ** add active contact sphere " << gj - globalContactIndexOffsets[spheresMarkerBasedIndex] << " to sphere " << i << "\n";
						}
						allActiveContacts[gi]->AppendPure(IndexRegularizedFriction2ActiveContact(gj, frictionRegularizedRegion));
					}
				}
			}
		}
		if (opMode != CCode2rhsFromActiveSets)
		{
			(addedObjects[threadID])->SetNumberOfItems(0);
		}
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems
}



template<Index opMode>
void GeneralContact::ComputeContactANCFCable2D(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, Index nThreads)
{
	STARTGLOBALTIMER(TScontactANCFCable);
	//loop over all contact spheres:
	NGSsizeType nItems = (NGSsizeType)ancfCable2D.NumberOfItems();

	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems	
	if ((Index)nItems >= 32 * nThreads) //slower split factor because larger computation effort as compared to spheres
	{
		if ((Index)nItems < 128 * nThreads) { taskSplit = 16 * nThreads; }
		else { taskSplit = 64 * nThreads; }
	}


	//run over all ancf elements (precomputation for some parts possible if there is contact...)
	exuThreading::ParallelFor(nItems, [this, &tempArray, &cSystem, &nItems](NGSsizeType i)
	//for (Index i = 0; i < ancfCable2D.NumberOfItems(); i++)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();
		//Index threadID = 0;

		ResizableVector& ode2Lhs = tempArray[threadID].localODE2LHS;

		//+++++++++++++++++++++++++++++

		Index gi = (Index)i + globalContactIndexOffsets[ancfCable2DIndex]; //i is local, gi is global index (which is the same for the first contact objects)
		Index jgi = (Index)i + globalJacobianIndexOffsets[ancfCable2DIndex];
		const ContactANCFCable2D& ancfI = ancfCable2D[(Index)i];

		ResizableArray<Index>* contactObjects;
		//STARTGLOBALTIMER(TScontactANCFCable1);
		if (opMode == CCode2rhsFromActiveSets)
		{
			contactObjects = allActiveContacts[gi];
		}
		else
		{
			contactObjects = addedObjects[threadID];
			//determine potential contacts using bounding boxes; search only for spheres==circles:
			searchTree.GetSingleItemsInBoxMaxMinIndex(allBoundingBoxes[gi], *contactObjects, *addedObjectsFlags[threadID], allBoundingBoxes,
				globalContactIndexOffsets[spheresMarkerBasedIndex+1], globalContactIndexOffsets[spheresMarkerBasedIndex]);
			//pout << "found: " << *contactObjects << "\n";
		}
		//STOPGLOBALTIMER(TScontactANCFCable1);

		//here we could do some precomputation for ancf, if there is contact with several spheres ...
		ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> qANCF;
		ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> qANCF_t;
		ConstSizeVector<ContactANCFCable2DData::ANCFcirclePolynomialDegree+1> coeffs;
		ConstSizeVectorBase<RealC, ContactANCFCable2DData::ANCFcirclePolynomialDegree> complexRoots;
		ConstSizeVectorBase<Vector2D, DANCFselectedSegmentsLength> selectedSegments;
		ConstSizeVectorBase<Real, DANCFselectedSegmentsLength> contactForces; //returned by ComputeContactForcesANCFcableCircleContact, helps to determine if contact or not
		ConstSizeVectorBase<Real, DANCFselectedSegmentsLength> maxRelFrictionVels; //prescribed or returned by ComputeContactForcesANCFcableCircleContact
		//ConstSizeVector<DANCFselectedSegmentsLength> selectedSegmentsRelFrictionVel; //not needed, because there is only one segment in activeSet

		Index nDOFancf = cSystem.GetSystemData().GetCObjects()[ancfI.objectIndex]->GetODE2Size();

		for (Index k = 0; k < ContactANCFCable2DData::ANCFshapeCoordinates; k++)
		{
			qANCF[k] = ancfI.coordinates[k];
			qANCF_t[k] = ancfI.coordinates_t[k];
		}


		//check if there is really contact:
		//for (Index gj : *contactObjects)
		//{
		for (Index contactCnt = 0; contactCnt < contactObjects->NumberOfItems(); contactCnt++)
		{
			Index gj = contactObjects->GetItem(contactCnt);
			//bool frictionRegularizedRegion;
			//if (opMode == CCode2rhsFromActiveSets) {
			//	ActiveContact2IndexRegularizedFriction(contactObjects->GetItem(contactCnt), gj, frictionRegularizedRegion);
			//}
			//else { gj = contactObjects->GetItem(contactCnt); frictionRegularizedRegion = true; }

			if (!EXUstd::IndexIsInRange(gj, globalContactIndexOffsets[spheresMarkerBasedIndex],
				globalContactIndexOffsets[spheresMarkerBasedIndex + 1])) {
				continue;
			} //run loop only for ANCF-circle!

			//pout << "gi=" << gi << ", cobjs=" << *contactObjects << "\n";
			const ContactSpheresMarkerBased& sphereJ = spheresMarkerBased[gj - globalContactIndexOffsets[spheresMarkerBasedIndex]];
			//pout << "spheres C=" << spheresMarkerBased.NumberOfItems() << "\n";

			Vector2D circlePos({ sphereJ.position[0], sphereJ.position[1] });
			//Real maxRelFrictionVel=0.; //value to be stored in activeContactsVector

			if (opMode == CCode2rhsFromActiveSets)
			{
				//segment is stored in allActiveContactsVector
				selectedSegments.SetNumberOfItems(0);
				maxRelFrictionVels.SetNumberOfItems(0);
				CHECKandTHROW(contactCnt < allActiveContactsVector[gi]->NumberOfItems(), "allActiveContactsVector[gi] has not enough items");
				Vector3D data = allActiveContactsVector[gi]->GetItem(contactCnt); //contains 1 segment
				selectedSegments.AppendItem(Vector2D({ data[0],data[1] }));
				//maxRelFrictionVel = data[2];
				maxRelFrictionVels.AppendItem(data[2]);
			}
			else
			{
				if (settings.ancfCableUseExactMethod)
				{
					//check if there is contact:
					//STARTGLOBALTIMER(TScontactANCFCable2);
					ContactHelper::ANCFCable2DcontactCircleCoeffs(qANCF, ancfI.L, circlePos, sphereJ.radius + ancfI.halfHeight, coeffs);
					//STOPGLOBALTIMER(TScontactANCFCable2);

					//STARTGLOBALTIMER(TScontactANCFCableEig);
					ContactHelper::ComputeRootsANCFcableCircleContact(coeffs, complexRoots);
					//STOPGLOBALTIMER(TScontactANCFCableEig);

					//STARTGLOBALTIMER(TScontactANCFCable3);
					ContactHelper::ComputeContactSegmentsANCFcableCircleContact(coeffs, complexRoots, ancfI.L, selectedSegments);
					//STOPGLOBALTIMER(TScontactANCFCable3);
				}
				else
				{
					//STARTGLOBALTIMER(TScontactANCFCable3);
					ContactHelper::ComputeContactSegmentsANCFcableCircleContactApprox(qANCF, ancfI.L, ancfI.halfHeight,
						circlePos, sphereJ.radius, selectedSegments, settings.ancfCableNumberOfContactSegments);
					//STOPGLOBALTIMER(TScontactANCFCable3);
				}
			}

			//in active set strategy, we always compute the contact, even if there is separation
			if ((opMode == CCode2rhsFromActiveSets) || (selectedSegments.NumberOfItems() != 0))
			{ //now we have contact and need to compute contact forces!
				//pout << "spheres C=" << spheresMarkerBased.NumberOfItems() << "\n";
				//STARTGLOBALTIMER(TScontactANCFCable4);

				ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> fANCF; //generalized forces on ANCF
				Vector2D fCircle;	//force on circle
				Real tCircle;		//torque on circle
				Real kContact = ancfI.contactStiffness * sphereJ.contactStiffness / (ancfI.contactStiffness + sphereJ.contactStiffness);
				Real dContact = ancfI.contactDamping + sphereJ.contactDamping;

				Vector3D vSphereJ = sphereJ.velocity;

				Real dryFriction = settings.frictionPairings(ancfI.frictionMaterialIndex, sphereJ.frictionMaterialIndex);
				//if (dryFriction != 0.)
				//{
				//	Vector3D contactPoint = sphereI.position + sphereI.radius*n0;
				//	vSphereI += (sphereI.orientation * sphereI.angularVelocity).CrossProduct(contactPoint - sphereI.position);
				//	vSphereJ += (sphereJ.orientation * sphereJ.angularVelocity).CrossProduct(contactPoint - sphereJ.position);
				//}

				//depends on type of ANCF element:
				
				bool forceFrictionMode = (opMode == CCode2rhsFromActiveSets); //in this case, maxRelFrictionVel prescribes if frictionProportional zone or static friction
				fANCF.SetNumberOfItems(nDOFancf);
				ContactHelper::ComputeContactForcesANCFcableCircleContact(qANCF, qANCF_t, ancfI.L, ancfI.halfHeight, 
					circlePos, sphereJ, selectedSegments, kContact, dContact, dryFriction, 
					fANCF, fCircle, tCircle, contactForces, maxRelFrictionVels, settings, forceFrictionMode);

				if (opMode != CCactiveSets)
				{
					//pout << "fCircle=" << fCircle << ", fANCF=" << fANCF << ", ltg=" << *allLTGs[jgi] << "\n";
					Vector3D fVec({ fCircle[0], fCircle[1], 0.}); //switched sign in Python user function example (in Python RHS)!
					//add generalized forces:
					//marker J (negative):    (according to computation of d irForce)
					Index jgj = gj - globalContactIndexOffsets[spheresMarkerBasedIndex] + globalJacobianIndexOffsets[spheresMarkerBasedIndex];
					if (allPositionJacobians[jgj]->NumberOfColumns() != 0) //special case: COGround has (0,0) Jacobian
					{
						EXUmath::MultMatrixTransposedVector(*allPositionJacobians[jgj], -fVec, ode2Lhs);
						if (dryFriction != 0. && allRotationJacobians[jgj]->NumberOfColumns() != 0)
						{
							//add torque
							EXUmath::MultMatrixTransposedVectorAdd(*allRotationJacobians[jgj], Vector3D({ 0.,0.,-tCircle }), ode2Lhs);
						}
						//add to systemvector:
						for (Index k = 0; k < ode2Lhs.NumberOfItems(); k++)
						{
							tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[jgj]->GetItem(k), ode2Lhs[k]); //added positive (LHS)
						}
					}

					//add forces to ANCF (directly via LTG) and circle (via Jacobian)
					//marker I (negative, ANCF):
					//find ANCF element in cSystemData and use LTG
					if (allLTGs[jgi]->NumberOfItems() != 0) 
					{
						//add to systemvector:
						for (Index k = 0; k < fANCF.NumberOfItems(); k++)
						{
							tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[jgi]->GetItem(k), fANCF[k]); //added positive (LHS)
						}
					}

					//STOPGLOBALTIMER(TScontactANCFCable4);

				}
				else //compute active sets/PostNewton
				{
					Index cnt = 0;
					for (const Vector2D& seg : selectedSegments)
					{
						if (contactForces[cnt] < 0)
						{
							//add every segment separately:
							if (verboseMode >= 2) pout << "  ** add active contact circle "
								<< gj - globalContactIndexOffsets[spheresMarkerBasedIndex]
								<< " to ancfCable2D " << i
								<< " with segment=" << seg << "\n";
							allActiveContacts[gi]->AppendPure(gj);
							allActiveContactsVector[gi]->AppendPure(Vector3D({ seg[0],seg[1],maxRelFrictionVels[cnt] }));
							//allActiveContactsVector[gi]->AppendPure(Vector3D({ seg[0],seg[1],1.1 }));
						}
						cnt++;
					}
				}
			}
		}
		if (opMode != CCode2rhsFromActiveSets)
		{
			(addedObjects[threadID])->SetNumberOfItems(0);
		}
	//}
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems
	STOPGLOBALTIMER(TScontactANCFCable);

}

//Index TScontactTrigsSpheres;
//TimerStructureRegistrator TSRcontactTrigsSpheres("Contact:TrigsSpheres", TScontactTrigsSpheres, globalTimers, false);


template<Index opMode>
void GeneralContact::ComputeContactTrigsRigidBodyBased(TemporaryComputationDataArray& tempArray, Index nThreads)
{
	//loop over all contact trigs, compute contact with spheres:
	NGSsizeType nItems = (NGSsizeType)spheresMarkerBased.NumberOfItems();

	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems >= 32 * nThreads) //slower split factor because larger computation effort as compared to spheres
	{
		if ((Index)nItems < 256 * nThreads) { taskSplit = 16 * nThreads; }
		else { taskSplit = 128 * nThreads; }
	}


	//pout << "compute contact **********\n";
	//run through all spheres; spheres may contact with planes (trigs or with edges);
	exuThreading::ParallelFor(nItems, [this, &tempArray, &nItems](NGSsizeType i)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();
		ResizableVector& ode2Lhs = tempArray[threadID].localODE2LHS;

        std::array<Vector3D, 3> trigPoints; //global triangle points
		Vector3D trigPP; //point at shortest distance on triangle or triangle edges
		Index inside;

		//+++++++++++++++++++++++++++++
		//sphereI may come in contact with trigJ
		Index gi = (Index)i + globalContactIndexOffsets[spheresMarkerBasedIndex];
		const ContactSpheresMarkerBased& sphereI = spheresMarkerBased[(Index)i];

		Index minIndex = globalContactIndexOffsets[trigsRigidBodyBasedIndex]; //we are only search for trigs!
		Index maxIndex = globalContactIndexOffsets[trigsRigidBodyBasedIndex + 1];

		ResizableArray<Index>* contactObjects;
		if (opMode == CCode2rhsFromActiveSets)
		{
			//CASE 1: operate with the given contact objects ...
			contactObjects = allActiveContacts[gi];
		}
		else
		{
			//CASE 2: compute new contact objects
			contactObjects = addedObjects[threadID];
			//determine potential contacts using bounding boxes, only finding triangles!:
			searchTree.GetSingleItemsInBoxMaxMinIndex(allBoundingBoxes[gi], *contactObjects, *addedObjectsFlags[threadID],
				allBoundingBoxes, maxIndex, minIndex);

			foundTrianglesRigidBodyBased[threadID]->SetNumberOfItems(0);          //stored data of found triangles
			foundPlanesTrianglesRigidBodyBased[threadID]->SetNumberOfItems(0);    //local index in foundTrianglesRigidBodyBased
			foundEdgesTrianglesRigidBodyBased[threadID]->SetNumberOfItems(0);     //local index in foundTrianglesRigidBodyBased

			//find all triangles with minimum distance; for duplicates, only check duplicates on same rigid body
			for (Index gj : *contactObjects)
			{
				Index j = gj - globalContactIndexOffsets[trigsRigidBodyBasedIndex];
				const ContactTriangleRigidBodyBased& trigJ = trigsRigidBodyBased[j];
				const ContactRigidBodyMarkerBased& rigid = rigidBodyMarkerBased[trigJ.contactRigidBodyIndex];

				//compute global points
				for (Index k = 0; k < (Index)trigPoints.size(); k++)
				{
					trigPoints[k] = rigid.orientation * trigJ.points[k] + rigid.position;
				}
				Vector3D normal = rigid.orientation * trigJ.normal;

				HGeometry::MinDistTP(trigPoints[0], trigPoints[1], trigPoints[2], sphereI.position, trigPP, inside);

				Vector3D deltaP(sphereI.position - trigPP);
				//Real dist = (sphereI.position - trigPP).GetL2Norm() - sphereJ.radius;
				Real distSquared = (sphereI.position - trigPP).GetL2NormSquared();
				if (distSquared < EXUstd::Square(sphereI.radius) && 
					(deltaP*normal > 0) && //triangle normal must point outwards!
					distSquared >= EXUstd::Square(settings.minRelDistanceSpheresTriangles*sphereI.radius)) //ignore if sphere directly attached to trig!
				{
					//Real lam1, lam2;
					//HGeometry::LocalTriangleCoordinates(trigPoints[1] - trigPoints[0], trigPoints[2] - trigPoints[0], sphereI.position - trigPoints[0], lam1, lam2);
					//pout << "  contact sphere " << i << " - Trig " << gj << ", deltaP=" << deltaP << ", inside=" << inside << ", lam1=" << lam1 << ", lam2=" << lam2 << "\n";
					Index n = foundTrianglesRigidBodyBased[threadID]->NumberOfItems();
					if (inside) { foundPlanesTrianglesRigidBodyBased[threadID]->AppendPure(n); }
					else { foundEdgesTrianglesRigidBodyBased[threadID]->AppendPure(n);}

					foundTrianglesRigidBodyBased[threadID]->SetNumberOfItems(n + 1);
					ContactTrianglesRigidBodyBasedTemp& temp = foundTrianglesRigidBodyBased[threadID]->Last();
					temp.pointInPlane = trigPP;
					temp.rigidID = trigJ.contactRigidBodyIndex;
					temp.trigGID = gj;
					temp.inside = inside;
					if (inside) { temp.planeNormal = HGeometry::ComputeTriangleNormal(trigPoints); }

				}

			}
			contactObjects->SetNumberOfItems(0);

			//now check, if some triangles have contact on edge which is also on another triangle-plane (inside=1 or 2)
			// this would lead to artificial contact forces that are avoided herein:
			for (const ContactTrianglesRigidBodyBasedTemp& trigFound : *foundTrianglesRigidBodyBased[threadID])
			{
				//pout << "trig found=" << trigFound.trigGID << "\n";
				bool excludeContact = false;
				if (trigFound.inside != 1) //check if contact is on edge (or close to edge!)
				{
					//go through all planes; usually this should be 1 or max. very few planes (except that a sphere lives inside a meshed sphere with same radius ...!!!)
					for (Index planeID : *foundPlanesTrianglesRigidBodyBased[threadID])
					{
						const ContactTrianglesRigidBodyBasedTemp& planeTemp = foundTrianglesRigidBodyBased[threadID]->GetItem(planeID);
						if (planeTemp.rigidID == trigFound.rigidID && planeTemp.trigGID != trigFound.trigGID && //only relevant on same rigid body, exclude trig itself
							(!(trigFound.inside == 2 && planeTemp.trigGID > trigFound.trigGID) || (planeTemp.inside == 1 && settings.excludeOverlappingTrigSphereContacts)) )//if both trigs are in plane (1 or 2), then only exclude trig with larger GID
						{
							if (HGeometry::DistanceToPlaneNormalized(trigFound.pointInPlane, planeTemp.planeNormal, planeTemp.pointInPlane) <= settings.tolEquivalentPoints)
							{
								//pout << "  ** found plane, trig=" << trigFound.trigGID << " (inside=" << trigFound.inside << "), planeGID=" << planeTemp.trigGID << " (inside=" << planeTemp.inside << ")\n";
								excludeContact = true; 
								break; //we only search for one other triangle, then we exclude this contact
							}
						}
					}
					//this is the costly part: if contact happens at two convex edges (usual case) or 
					//at a convex vertex (very exceptional, but very costly), then we need to check all edges:
					//we do not consider different rigid bodies, because assuming that there will be no duplicated points between different rigid bodies
					if (!excludeContact && settings.excludeDuplicatedTrigSphereContactPoints)
					{
						for (const ContactTrianglesRigidBodyBasedTemp& trigOther : *foundTrianglesRigidBodyBased[threadID])
						{
							//const ContactTrianglesRigidBodyBasedTemp& trigOther = 
							if ((trigOther.trigGID < trigFound.trigGID) &&
								//(trigOther.inside != 1) &&
								(trigFound.pointInPlane - trigOther.pointInPlane).GetL2NormSquared() <= settings.tolEquivalentPointsSquared)
							{
								//pout << "exclude " << trigFound.trigGID << "-" << trigOther.trigGID << "\n";
								excludeContact = true;
								break;
							}
						}

					}
				}

				if (!excludeContact) //if triangle is in no other plane or is a plane itself, add it!
				{
					//pout << "  ** add active contact Sphere-Trig: " << gi << " - " << trigFound.trigGID << "\n";
					if (verboseMode >= 2) pout << "  ** add active contact Sphere-Trig: " << gi << " - " << trigFound.trigGID << "\n";

					contactObjects->AppendPure(trigFound.trigGID);
					//if (opMode != CCactiveSets)
					//{
					//	//contactObjects will then be used in contact computation below
					//	contactObjects->AppendPure(trigFound.trigGID);
					//}
					//else
					//{
					//	//activate this contact for ODE2RHS
					//	allActiveContacts[gi]->AppendPure(trigFound.trigGID);
					//}
				}
			}

		}

		bool frictionRegularizedRegion;
		//compute contact with all triangles (now this may also include sphere-sphere indices if coming from active sets!!!)
		for (Index gjSign : *contactObjects)
		{
			Index gj;
			if (opMode == CCode2rhsFromActiveSets) {
				ActiveContact2IndexRegularizedFriction(gjSign, gj, frictionRegularizedRegion);
			}
			else { gj = gjSign; frictionRegularizedRegion = true; }

			if (!EXUstd::IndexIsInRange(gj, globalContactIndexOffsets[trigsRigidBodyBasedIndex],
				globalContactIndexOffsets[trigsRigidBodyBasedIndex + 1])) {
				continue; //break would not work appropriately
			} //run loop only for sphere-trig!

				//compute triangle contact, pp
			Index j = gj - globalContactIndexOffsets[trigsRigidBodyBasedIndex];
			const ContactTriangleRigidBodyBased& trigJ = trigsRigidBodyBased[j];
			const ContactRigidBodyMarkerBased& rigid = rigidBodyMarkerBased[trigJ.contactRigidBodyIndex];

			//compute global points
			for (Index k = 0; k < (Index)trigPoints.size(); k++)
			{
				trigPoints[k] = rigid.orientation * trigJ.points[k] + rigid.position;
			}

			HGeometry::MinDistTP(trigPoints[0], trigPoints[1], trigPoints[2], sphereI.position, trigPP, inside);

			Vector3D deltaP(trigPP - sphereI.position); //points from sphereI to trigJ!!!
			Real dist = deltaP.GetL2Norm();
			if (dist == 0) { continue; } //should never happen, but also no warning!
			//compute contact forces
			Vector3D n0 = (1. / dist) * deltaP;

			//compute velocities
			//global trig velocity at contact point
			Vector3D vTrigJ = (rigid.orientation * rigid.angularVelocity).CrossProduct(trigPP - rigid.position) + rigid.velocity;
			//global sphere velocity at contact point:
			Vector3D vSphereI = (sphereI.orientation * sphereI.angularVelocity).CrossProduct(trigPP - sphereI.position) + sphereI.velocity;
			Real deltaVnormal = n0 * (vTrigJ - vSphereI); // -n0 * (vTrigJ - vSphereI);		//penetration velocity

			Real gap = dist - sphereI.radius; //gap is negative

			Real kContact = sphereI.contactStiffness * rigid.contactStiffness / (sphereI.contactStiffness + rigid.contactStiffness);

			//damping acts parallel, otherwise if the sphere has 0 damping, the trig damping had no influence
			Real dContact = sphereI.contactDamping + rigid.contactDamping;

			//compute scalar force (pressure is negative):
			Real contactForce = kContact * gap + dContact * deltaVnormal;

			if (!inside && !settings.excludeDuplicatedTrigSphereContactPoints)
			{
				contactForce *= 0.5;
			} //always at least two edges at same time!

			Vector3D fVec = contactForce * n0;

			Real dryFriction = settings.frictionPairings(sphereI.frictionMaterialIndex, rigid.frictionMaterialIndex);
			Vector3D fFriction;
			//if (dryFriction != 0.)
			//{
			//	Vector3D deltaVtangent = (vTrigJ - vSphereI) - deltaVnormal * n0;	//tangent velocity
			//	Real relVel;
			//	ContactHelper::ComputeFrictionForce<Vector3D>(fFriction, deltaVtangent, -contactForce, dryFriction,
			//		settings.frictionProportionalZone, relVel);
			//	fVec += fFriction;
			//}

			if (dryFriction != 0.)
			{
				//global sphere velocity at contact point:
				Vector3D deltaVtangent = (vTrigJ - vSphereI) - deltaVnormal * n0;	//tangent velocity
				Real relVel;
				if (opMode != CCode2rhsFromActiveSets) //most important for explicit integrators
				{
					frictionRegularizedRegion = ContactHelper::ComputeFrictionForce<Vector3D>(fFriction, deltaVtangent, -contactForce, dryFriction,
						settings.frictionProportionalZone, relVel);
				}
				else
				{
					//friction mode is given from frictionRegularizedRegion!
					frictionRegularizedRegion = ContactHelper::ComputeFrictionForce<Vector3D, Real, true>(fFriction, deltaVtangent, -contactForce, dryFriction,
						settings.frictionProportionalZone, relVel, frictionRegularizedRegion);

					//if (!frictionRegularizedRegion && settings.sphereSphereFrictionRecycle) { fFriction = storedFFriction; }
				}
				fVec += fFriction;
			}


			if (opMode != CCactiveSets) //from here, we do not need to compute for active set determination
			{

				//if (verboseMode >= 3) pout  << "contact f=" << fVec << "\n";

				//apply forces to trig (via rigid body)
				//Index index2JacIndexTrigs = globalJacobianIndexOffsets[trigsRigidBodyBasedIndex] - globalContactIndexOffsets[trigsRigidBodyBasedIndex];
				Index trigJacIndex = trigJ.contactRigidBodyIndex + globalJacobianIndexOffsets[trigsRigidBodyBasedIndex];
				Index sphereJacIndex = (Index)i + globalJacobianIndexOffsets[spheresMarkerBasedIndex];


				//marker J (positive):    (according to computation of relative position)
				if (allPositionJacobians[trigJacIndex]->NumberOfColumns() != 0) //special case: COGround has (0,0) Jacobian
				{
					EXUmath::MultMatrixTransposedVector(*allPositionJacobians[trigJacIndex], fVec, ode2Lhs);
					if (dryFriction != 0. && allRotationJacobians[trigJacIndex]->NumberOfColumns() != 0)
					{
						//add torque
						EXUmath::MultMatrixTransposedVectorAdd(*allRotationJacobians[trigJacIndex],
							(trigPP - rigid.position).CrossProduct(fVec), ode2Lhs);
					}
					//pout << "  sphere-Trig" << gi << " - " << gj << ": Trig" << ", rbim=" << trigJ.contactRigidBodyIndex << ", ode2Lhs=" << ode2Lhs 
					//	<< ", index2JacIndexTrigs=" << index2JacIndexTrigs << ", LTG=" << *allLTGs[trigJ.contactRigidBodyIndex + index2JacIndexTrigs] << "\n";
					//add to systemvector:
					for (Index k = 0; k < ode2Lhs.NumberOfItems(); k++)
					{
						tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[trigJacIndex]->GetItem(k), ode2Lhs[k]); //added positive (LHS)
					}
				}
				//apply forces to sphere (as in sphere-sphere)
				//marker I (negative):
				if (allPositionJacobians[sphereJacIndex]->NumberOfColumns() != 0) //special case: COGround has (0,0) Jacobian
				{
					EXUmath::MultMatrixTransposedVector(*allPositionJacobians[sphereJacIndex], -fVec, ode2Lhs);
					if (dryFriction != 0. && allRotationJacobians[sphereJacIndex]->NumberOfColumns() != 0)
					{
						//pout << "n=" << ((-sphereI.radius) * n0) << "fVec=" << fVec << "\n";
						//pout << "torque=" << ((-sphereI.radius) * n0).CrossProduct(fVec)[1] << "\n";
						//add torque
						EXUmath::MultMatrixTransposedVectorAdd(*allRotationJacobians[sphereJacIndex],
							//this is not fully symmetric regarding torques (contact calculation point at trigPP): 
							(sphereI.position - trigPP).CrossProduct(fVec), ode2Lhs);

					}
					//pout << "  sphere-Trig" << gi << " - " << gj << ": Sphere ode2Lhs=" << ode2Lhs << ", LTG=" << *allLTGs[gi + index2JacIndexSpheres] << "\n";
					//add to systemvector:
					for (Index k = 0; k < ode2Lhs.NumberOfItems(); k++)
					{
						tempArray[threadID].sparseVector.AddIndexAndValue(allLTGs[sphereJacIndex]->GetItem(k), ode2Lhs[k]); //added positive (LHS)
					}
				}
			}
			else
			{
				//allActiveContacts[gi]->AppendPure(gj);
				if (contactForce < 0.) //may be positive because of velocity term
				{
					frictionRegularizedRegion = true;
					if (dryFriction != 0.)
					{
						Vector3D deltaVtangent = (vTrigJ - vSphereI) - deltaVnormal * n0;	//tangent velocity
						frictionRegularizedRegion = (deltaVtangent.GetL2Norm() < settings.frictionProportionalZone);
						//if (gj > 2) pout << "PN: j=" << gjSign << ", fricReg=" << frictionRegularizedRegion << ", n0=" << n0 << ", vN=" << deltaVnormal << ", dV(J-I)=" << (vSphereJ - vSphereI) << ", deltaVtang=" << deltaVtangent << "\n";

						allActiveContactsVector[gi]->AppendPure(fFriction); //only in case of friction!
						
						if (verboseMode >= 2) pout << "  ** add contact trig (" << frictionRegularizedRegion << "):" << gj - globalContactIndexOffsets[trigsRigidBodyBasedIndex] << " to sphere " << i << "\n";
					}
					allActiveContacts[gi]->AppendPure(IndexRegularizedFriction2ActiveContact(gj, frictionRegularizedRegion));
				}
			}
		}

		//now clear the addedObjects for next iteration
		if (opMode != CCode2rhsFromActiveSets)
		{
			(addedObjects[threadID])->SetNumberOfItems(0);
		}
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems
}


//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//! compute contact forces and add to global system vector
void GeneralContact::ComputeODE2RHS(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, Vector& systemODE2Rhs)
{
	//if (verboseMode >= 3) pout  << "computeODE2RHS\n";
	if (!isActive) { return; }
	//pout << "t=" << cSystem.GetSystemData().GetCData().GetCurrent().GetTime() << "\n";

	STARTGLOBALTIMERmain(TScontactODE2RHS);
	//pout << "doPostNewton=" << cSystem.GetSolverData().doPostNewtonIteration << "\n";
	if (cSystem.GetSolverData().doPostNewtonIteration)
	{
		ComputeContact<CCode2rhsFromActiveSets>(cSystem, tempArray, systemODE2Rhs);
		if (verboseMode >= 2) pout << "  systemODE2RhsActiveSet=" << systemODE2Rhs << ", c=" << cSystem.GetSystemData().GetCData().currentState.GetODE2Coords() << "\n";
	}
	else
	{
		ComputeContact<CCode2rhsFull>(cSystem, tempArray, systemODE2Rhs);
		if (verboseMode >= 2) pout << "  systemODE2RhsFull=" << systemODE2Rhs << ", c=" << cSystem.GetSystemData().GetCData().currentState.GetODE2Coords() << "\n";
	}
	STOPGLOBALTIMERmain(TScontactODE2RHS);


}

//! compute LHS jacobian of ODE2RHS w.r.t. ODE2 and ODE2_t quantities; 
//! multiply (before added to jacobianGM) ODE2 with factorODE2 and ODE2_t with factorODE2_t
//! only sparse option available
void GeneralContact::JacobianODE2LHS(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, const NumericalDifferentiationSettings& numDiff,
	GeneralMatrix& jacobianGM, Real factorODE2, Real factorODE2_t)
{
	//if (verboseMode >= 3) pout  << "computeODE2RHS\n";
	if (!isActive) { return; }

    STARTGLOBALTIMERmain(TScontactJacobian);
    ComputeContactDataAndBoundingBoxes(cSystem, tempArray, false, false);

	Index nThreads = exuThreading::TaskManager::GetNumThreads();
	SetNumberOfThreads(nThreads);

	tempArray.SetNumberOfItems(nThreads); //only affected if changed; will be moved to CSystem!

	for (auto item : tempArray) {item->sparseTriplets.SetNumberOfItems(0);}

	//loop over all contact spheres:
	NGSsizeType nItems = (NGSsizeType)spheresMarkerBased.NumberOfItems();
	if (!settings.sphereSphereContact) { nItems = 0; }


	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//SPHERE-SPHERE

	Index taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems > 400 * nThreads) { taskSplit = 100 * nThreads; }
	exuThreading::ParallelFor(nItems, [this, &cSystem, &tempArray, &factorODE2, &factorODE2_t, &nItems](NGSsizeType i)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();

		//Index threadID = 0;
		Index index2JacIndex = globalJacobianIndexOffsets[spheresMarkerBasedIndex] - globalContactIndexOffsets[spheresMarkerBasedIndex];
		//ResizableVector& ode2Lhs = tempArray[threadID].localODE2LHS;
		SparseTripletVector& triplets = tempArray[threadID].sparseTriplets;
		//+++++++++++++++++++++++++++++

		Index gi = (Index)i + globalContactIndexOffsets[spheresMarkerBasedIndex]; //i is local, gi is global index (which is the same for the first contact objects)
		const ContactSpheresMarkerBased& sphereI = spheresMarkerBased[(Index)i];

		////determine potential contacts using bounding boxes:
		//run through all active contacts of sphere i
		for (Index gjSign : *(allActiveContacts[gi]))
		{
			Index gj;
			bool frictionRegularizedRegion;
			ActiveContact2IndexRegularizedFriction(gjSign, gj, frictionRegularizedRegion);

			if (!EXUstd::IndexIsInRange(gj, globalContactIndexOffsets[spheresMarkerBasedIndex], globalContactIndexOffsets[spheresMarkerBasedIndex+1]))
			{continue;}

			//we assume contact!
			const ContactSpheresMarkerBased& sphereJ = spheresMarkerBased[gj - globalContactIndexOffsets[spheresMarkerBasedIndex]];

			Vector3D deltaP(sphereJ.position - sphereI.position);

			Real dist = deltaP.GetL2Norm(); //distance of midpoints
			//Real deltaV = (1. / dist)*deltaP * (sphereI.velocity - sphereJ.velocity); //penetration velocity, = -(v.J-v.I) !
			Real gap = dist - (sphereI.radius + sphereJ.radius); //gap = -penetration

			if (dist == 0.) { continue; } //except this case, as it causes div by zero! could be particles at same location (for some strange reasons ...)
			Real Linv = 1. / dist;

			Vector3D n0(deltaP);
			n0*=Linv;

			Real dryFriction = settings.frictionPairings(sphereI.frictionMaterialIndex, sphereJ.frictionMaterialIndex);
			bool computeFrictionTerms = (dryFriction != 0.);
			//computeFrictionTerms = false;

			Vector3D vSphereI = sphereI.velocity;
			Vector3D vSphereJ = sphereJ.velocity;

			//compute this without the tangential part, to be fully consistent with gap
			Real deltaVnormal = n0 * (vSphereJ - vSphereI); //penetration velocity, = -(v.J-v.I) !

			if (computeFrictionTerms)
			{
				vSphereI += (sphereI.orientation * sphereI.angularVelocity).CrossProduct(sphereI.radius*n0);
				vSphereJ += (sphereJ.orientation * sphereJ.angularVelocity).CrossProduct((-sphereJ.radius)*n0);
				//Vector3D contactPoint = sphereI.position + sphereI.radius*n0;
				//vSphereI += (sphereI.orientation * sphereI.angularVelocity).CrossProduct(contactPoint - sphereI.position);
				//vSphereJ += (sphereJ.orientation * sphereJ.angularVelocity).CrossProduct(contactPoint - sphereJ.position);
			}

			Real kContact = sphereI.contactStiffness * sphereJ.contactStiffness / (sphereI.contactStiffness + sphereJ.contactStiffness);

			//damping acts parallel, otherwise if one sphere has 0 damping, the other damping had no influence
			Real dContact = sphereI.contactDamping + sphereJ.contactDamping;


			//++++++++++++++++++++++++++++++++++++++++++++++++++
			//at this point, we could also use automatic differentiation, giving a simpler implementation
			Real factNormalContact = factorODE2 * kContact + factorODE2_t * dContact; //normal direction gives same terms for stiffness and velocity
			Vector3D deltaVJI = (vSphereJ - vSphereI);
			Matrix3D JacFc;

			//compute scalar force:
			Real contactForce = kContact * gap + dContact * deltaVnormal;

			Vector3D fVec = contactForce * n0; //this is the force pointing from sphereJ to sphereI
			Vector3D deltaVtangent(0.);

			if (computeFrictionTerms)
			{
				//global sphere tangent velocity at contact point:
				deltaVtangent = deltaVJI - deltaVnormal * n0;	//tangent velocity

				if (!(frictionRegularizedRegion && settings.frictionProportionalZone != 0.)) { computeFrictionTerms = false; }
			}

			Real factRegularizedFriction = 0.;
			ComputeContactForceJacobian(settings, dryFriction, factorODE2, factorODE2_t, computeFrictionTerms, factNormalContact,
				Linv, n0, deltaVJI, dContact, contactForce, deltaVtangent, 
				factRegularizedFriction, JacFc); //last line are return values

			//ResizableVector& vecTemp = tempArray[threadID].localODE2LHS; //used as temporary vector
			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//position/forces:
			const ResizableMatrix& JACj = *allPositionJacobians[gj + index2JacIndex];
			const ResizableMatrix& JACi = *allPositionJacobians[gi + index2JacIndex];
			Index columnsj = JACj.NumberOfColumns();
			Index columnsi = JACi.NumberOfColumns();

			const ResizableMatrix& rotJACj = *allRotationJacobians[gj + index2JacIndex];
			const ResizableMatrix& rotJACi = *allRotationJacobians[gi + index2JacIndex];
			Index rotColumnsj = rotJACj.NumberOfColumns();
			Index rotColumnsi = rotJACi.NumberOfColumns();

			Matrix3D rTildeNJ = RigidBodyMath::Vector2SkewMatrix((sphereJ.radius)*n0);
			Matrix3D rTildeNI = RigidBodyMath::Vector2SkewMatrix((sphereI.radius)*n0);

			//compute additional term in Torque jacobian
			Matrix3D JacTorqueFc(3, 3, 0.);
			if (computeFrictionTerms)
			{
				JacTorqueFc.SetWithDiadicProduct(deltaVtangent, (factNormalContact * dryFriction / settings.frictionProportionalZone) * n0);
			}

			AddJacobianTerms(tempArray[threadID],
				columnsi, columnsj, JACi, JACj,rotColumnsi, rotColumnsj, rotJACi, rotJACj,
				*allLTGs[gi + index2JacIndex], *allLTGs[gj + index2JacIndex], rTildeNI, rTildeNJ, computeFrictionTerms, factRegularizedFriction, JacFc, JacTorqueFc,
				triplets);

		}
	//}//serial
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems



	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//CIRCLE-ANCF
	NGSsizeType nItemsANCF = (NGSsizeType)ancfCable2D.NumberOfItems();
	taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItemsANCF > 8 * nThreads) { taskSplit = 8 * nThreads; }
	exuThreading::ParallelFor(nItemsANCF, [this, &cSystem, &tempArray, &factorODE2, &factorODE2_t, &nItems](NGSsizeType i)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();

	//for (NGSsizeType i = 0; i < nItemsANCF; i++)
	//{
	//	Index threadID = 0;
		//Index index2JacIndex = globalJacobianIndexOffsets[ancfCable2DIndex] - globalContactIndexOffsets[ancfCable2DIndex];
		//ResizableVector& ode2Lhs = tempArray[threadID].localODE2LHS;
		//auto& triplets = tempArray[threadID].sparseTriplets;
		//+++++++++++++++++++++++++++++

		Index gi = (Index)i + globalContactIndexOffsets[ancfCable2DIndex]; //i is local, gi is global index (which is the same for the first contact objects)
		//Index jgi = (Index)i + globalJacobianIndexOffsets[ancfCable2DIndex];
		const ContactANCFCable2D& ancfI = ancfCable2D[(Index)i];


		//here we could do some precomputation for ancf, if there is contact with several spheres ...
		ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> qANCF;
		ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> qANCF_t;
		ConstSizeVector<ContactANCFCable2DData::ANCFcirclePolynomialDegree + 1> coeffs;
		ConstSizeVectorBase<RealC, ContactANCFCable2DData::ANCFcirclePolynomialDegree> complexRoots;
		ConstSizeVectorBase<Vector2D, DANCFselectedSegmentsLength> selectedSegments;

		//Index nDOFancf = cSystem.GetSystemData().GetCObjects()[ancfI.objectIndex]->GetODE2Size();

		//only copy the shape coordinates, also for ALE cables
		for (Index k = 0; k < ContactANCFCable2DData::ANCFshapeCoordinates; k++)
		{
			qANCF[k] = ancfI.coordinates[k];
			qANCF_t[k] = ancfI.coordinates_t[k];
		}

		//for (Index gjSign : *(allActiveContacts[gi]))
		for (Index contactCnt = 0; contactCnt < allActiveContacts[gi]->NumberOfItems(); contactCnt++)
		{
			Index gj = allActiveContacts[gi]->GetItem(contactCnt);
			//bool frictionRegularizedRegion;
			//ActiveContact2IndexRegularizedFriction(allActiveContacts[gi]->GetItem(contactCnt), gj, frictionRegularizedRegion);

			//we assume contact!
			const ContactSpheresMarkerBased& sphereJ = spheresMarkerBased[gj - globalContactIndexOffsets[spheresMarkerBasedIndex]];

			Vector2D circlePos({ sphereJ.position[0], sphereJ.position[1] });

			//segment is stored in allActiveContactsVector
			selectedSegments.SetNumberOfItems(0);
			const Vector3D& data = allActiveContactsVector[gi]->GetItem(contactCnt); //contains 1 segment
			Vector2D selectedSegment({ data[0],data[1] });
			bool frictionRegularizedRegion = (data[2] < 1.);

			ConstSizeVector<ContactANCFCable2DData::ANCFmaxCoordinates> fANCF; //generalized forces on ANCF
			//Vector2D fCircle;	//force on circle
			//Real tCircle;		//torque on circle
			Real kContact = ancfI.contactStiffness * sphereJ.contactStiffness / (ancfI.contactStiffness + sphereJ.contactStiffness);
			Real dContact = ancfI.contactDamping + sphereJ.contactDamping;

			Real dryFriction = settings.frictionPairings(ancfI.frictionMaterialIndex, sphereJ.frictionMaterialIndex);

			//compute jacobians for integration points (added up):
			ComputeContactJacobianANCFcableCircleContact(gi, gj, 
				tempArray[threadID], factorODE2, factorODE2_t, 
				cSystem.GetSystemData().GetCObjects()[ancfI.objectIndex],
				qANCF, qANCF_t, ancfI.L, ancfI.halfHeight,
				circlePos, sphereJ, selectedSegment, kContact, dContact, dryFriction, frictionRegularizedRegion);



		}
	//}//serial
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems

	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//SPHERE-TRIG; issue #837

#define JAC_SPHERE_TRIG

#ifdef JAC_SPHERE_TRIG
	taskSplit = nThreads; //shall be multiple of number of treads (Default=nThreads), but better 8*nThreads or larger for large problems
	if ((Index)nItems > 400 * nThreads) { taskSplit = 100 * nThreads; }
	exuThreading::ParallelFor(nItems, [this, &cSystem, &tempArray, &factorODE2, &factorODE2_t, &nItems](NGSsizeType i)
	{
		//+++++++++++++++++++++++++++++
		//went inside parallel loop:
		Index threadID = exuThreading::TaskManager::GetThreadId();

		Index index2JacIndex = globalJacobianIndexOffsets[spheresMarkerBasedIndex] - globalContactIndexOffsets[spheresMarkerBasedIndex];
		SparseTripletVector& triplets = tempArray[threadID].sparseTriplets;
		//+++++++++++++++++++++++++++++

		std::array<Vector3D, 3> trigPoints; //global triangle points
		Vector3D trigPP; //point at shortest distance on triangle or triangle edges
		Index inside;

		Index gi = (Index)i + globalContactIndexOffsets[spheresMarkerBasedIndex]; //i is local, gi is global index (which is the same for the first contact objects)
		const ContactSpheresMarkerBased& sphereI = spheresMarkerBased[(Index)i];

		Index minIndex = globalContactIndexOffsets[trigsRigidBodyBasedIndex]; //we are only search for trigs!
		Index maxIndex = globalContactIndexOffsets[trigsRigidBodyBasedIndex + 1];

		////determine potential contacts using bounding boxes:
		//run through all active contacts of sphere i
		for (Index gjSign : *(allActiveContacts[gi]))
		{
			Index gj;
			bool frictionRegularizedRegion;
			ActiveContact2IndexRegularizedFriction(gjSign, gj, frictionRegularizedRegion);

			//only consider contact with trigs
			if (!EXUstd::IndexIsInRange(gj, globalContactIndexOffsets[trigsRigidBodyBasedIndex], globalContactIndexOffsets[trigsRigidBodyBasedIndex + 1]))
			{
				continue;
			}
			
			//compute triangle contact, pp
			Index j = gj - globalContactIndexOffsets[trigsRigidBodyBasedIndex];
			const ContactTriangleRigidBodyBased& trigJ = trigsRigidBodyBased[j];
			const ContactRigidBodyMarkerBased& rigid = rigidBodyMarkerBased[trigJ.contactRigidBodyIndex];

			//compute global points
			for (Index k = 0; k < (Index)trigPoints.size(); k++)
			{
				trigPoints[k] = rigid.orientation * trigJ.points[k] + rigid.position;
			}

			HGeometry::MinDistTP(trigPoints[0], trigPoints[1], trigPoints[2], sphereI.position, trigPP, inside);

			Vector3D deltaP(trigPP - sphereI.position); //points from sphereI to trigJ!!!
			Real dist = deltaP.GetL2Norm();
			if (dist == 0.) { continue; } //except this case, as it causes div by zero! could be particles at same location (for some strange reasons ...)

			Real Linv = 1. / dist;
			Vector3D n0(deltaP);
			n0 *= Linv;

			Real gap = dist - sphereI.radius; //gap is negative
			//compute velocities
			//global trig velocity at contact point
			Vector3D vTrigJ = (rigid.orientation * rigid.angularVelocity).CrossProduct(trigPP - rigid.position) + rigid.velocity;
			//global sphere velocity at contact point:
			Vector3D vSphereI = (sphereI.orientation * sphereI.angularVelocity).CrossProduct(trigPP - sphereI.position) + sphereI.velocity;
			Real deltaVnormal = n0 * (vTrigJ - vSphereI); // -n0 * (vTrigJ - vSphereI);		//penetration velocity

			Real kContact = sphereI.contactStiffness * rigid.contactStiffness / (sphereI.contactStiffness + rigid.contactStiffness);

			//damping acts parallel, otherwise if the sphere has 0 damping, the trig damping has no influence
			Real dContact = sphereI.contactDamping + rigid.contactDamping;

			//compute scalar force:
			Real contactForce = kContact * gap + dContact * deltaVnormal;

			if (!inside && !settings.excludeDuplicatedTrigSphereContactPoints)
			{
				contactForce *= 0.5;
			} //always at least two edges at same time!

			Vector3D fVec = contactForce * n0;

			Real dryFriction = settings.frictionPairings(sphereI.frictionMaterialIndex, rigid.frictionMaterialIndex);
			bool computeFrictionTerms = (dryFriction != 0.);

			//++++++++++++++++++++++++++++++++++++++++++++++++++
			//at this point, we could also use automatic differentiation, giving a simpler implementation
			Real factNormalContact = factorODE2 * kContact + factorODE2_t * dContact; //normal direction gives same terms for stiffness and velocity
			Vector3D deltaVJI = (vTrigJ - vSphereI);
			Matrix3D JacFc;

			Real factRegularizedFriction = 0.;
			Vector3D deltaVtangent(0.);

			if (computeFrictionTerms)
			{
				//global sphere tangent velocity at contact point:
				deltaVtangent = deltaVJI - deltaVnormal * n0;	//tangent velocity

				if (!(frictionRegularizedRegion && settings.frictionProportionalZone != 0.)) { computeFrictionTerms = false; }
			}
			//computeFrictionTerms = false;

			ComputeContactForceJacobian(settings, dryFriction, factorODE2, factorODE2_t, computeFrictionTerms, factNormalContact,
				Linv, n0, deltaVJI, dContact, contactForce, deltaVtangent, 
				factRegularizedFriction, JacFc); //last line are return values

			//ResizableVector& vecTemp = tempArray[threadID].localODE2LHS; //used as temporary vector
			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
			Index trigJjacIndex = trigJ.contactRigidBodyIndex + globalJacobianIndexOffsets[trigsRigidBodyBasedIndex];
			Index sphereIjacIndex = (Index)i + globalJacobianIndexOffsets[spheresMarkerBasedIndex];

			//position/forces:
			const ResizableMatrix& JACj = *allPositionJacobians[trigJjacIndex];
			const ResizableMatrix& JACi = *allPositionJacobians[sphereIjacIndex];
			Index columnsj = JACj.NumberOfColumns();
			Index columnsi = JACi.NumberOfColumns();

			const ResizableMatrix& rotJACj = *allRotationJacobians[trigJjacIndex];
			const ResizableMatrix& rotJACi = *allRotationJacobians[sphereIjacIndex];
			Index rotColumnsj = rotJACj.NumberOfColumns();
			Index rotColumnsi = rotJACi.NumberOfColumns();

			Vector3D pJ = (rigid.position - trigPP);
			//vectors 
			Matrix3D rTildeNJ = RigidBodyMath::Vector2SkewMatrix(pJ); //(skew) vector from contact point to ref. point J
			Matrix3D rTildeNI = RigidBodyMath::Vector2SkewMatrix((sphereI.radius) * n0); //(skew) vector from I to contact point

			//compute additional term in Torque jacobian
			Matrix3D JacTorqueFc(3, 3, 0.);
			if (computeFrictionTerms)
			{
				JacTorqueFc.SetWithDiadicProduct(deltaVtangent, (factNormalContact * dryFriction / settings.frictionProportionalZone) * n0);
			}

			AddJacobianTerms(tempArray[threadID],
				columnsi, columnsj, JACi, JACj, rotColumnsi, rotColumnsj, rotJACi, rotJACj,
				*allLTGs[sphereIjacIndex], *allLTGs[trigJjacIndex], rTildeNI, rTildeNJ, computeFrictionTerms, factRegularizedFriction, JacFc, JacTorqueFc,
				triplets);

		}
		//}//serial
	}, taskSplit); //must be multiple of number of treads, but better 8*nThreads or larger for large problems
#endif


	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
	//serial section for writing all triplets into Jacobian
	for (Index i = 0; i < nThreads; i++)
	{
		jacobianGM.AddSparseTriplets(tempArray[i].sparseTriplets);
	}

	if (verboseMode >= 3) pout  << "  jac=" << jacobianGM.GetEXUdenseMatrix() <<"\n";

	STOPGLOBALTIMERmain(TScontactJacobian);
}


//! helper function to compute jacobian of contact forces for given segments on ANCF cable, using numerical integration
void GeneralContact::ComputeContactJacobianANCFcableCircleContact(Index gi, Index gj, 
	TemporaryComputationData& tempData, Real factorODE2, Real factorODE2_t, const CObject* cObject,
	const ConstSizeVector<DANCFmaxCoordinates>& q, const ConstSizeVector<DANCFmaxCoordinates>& q_t,
	Real L, Real halfHeight, const Vector2D& circlePos, const ContactSpheresMarkerBased& sphere,
	Vector2D& segment, Real stiffness, Real damping, Real dryFriction, bool frictionRegularizedRegion)
{
	Real r = sphere.radius;

	Index index2JacIndexI = globalJacobianIndexOffsets[ancfCable2DIndex] - globalContactIndexOffsets[ancfCable2DIndex];
	Index index2JacIndexJ = globalJacobianIndexOffsets[spheresMarkerBasedIndex] - globalContactIndexOffsets[spheresMarkerBasedIndex];
	Index jgi = index2JacIndexI + gi;
	Index jgj = index2JacIndexJ + gj;

	SparseTripletVector& triplets = tempData.sparseTriplets;

	ConstSizeVector<4> cx;
	ConstSizeVector<4> cy;
	CObjectANCFCable2DBase::ComputePolynomialCoeffs(q, L, cx, cy);

	ConstSizeVector<4> cx_t;
	ConstSizeVector<4> cy_t;
	CObjectANCFCable2DBase::ComputePolynomialCoeffs(q_t, L, cx_t, cy_t);

	//const Index dim = 2;
	//const Index ns = 4;

	ConstSizeVector<4> integrationPoints;
	ConstSizeVector<4> integrationWeights;
	//if (exactPolynomial)
	{
		integrationPoints.CopyFrom(EXUmath::lobattoRuleOrder3Points);
		integrationWeights.CopyFrom(EXUmath::lobattoRuleOrder3Weights);
	}

	Vector2D p0, p1;
	Vector2D v0, v1;


	const Vector2D& seg = segment;
	if (!settings.ancfCableUseExactMethod)
	{
		Real x = 0.5*(seg[0] + seg[1]);
		Index segI = (Index)((x*settings.ancfCableNumberOfContactSegments) / L);
		Real lSeg = L / (Real)settings.ancfCableNumberOfContactSegments;
		Real seg0 = segI * lSeg;
		Real seg1 = (segI + 1) * lSeg;
		//due to small round off errors, leads to warnings, but correct otherwise:
		//if (seg0 > seg[0] || seg1 < seg[1])
		//{
		//	pout << "WARNING: seg0,seg[0]=" << seg0 << "," << seg[0] << ", seg1,seg[1]" << seg1 << "," << seg[1] << "\n";
		//}
		Vector2D p0s, p1s; //position at segment boundaries
		Vector2D v0s, v1s;
		p0s = Vector2D({ EXUmath::EvaluatePolynomial(cx, seg0), EXUmath::EvaluatePolynomial(cy, seg0) });
		p1s = Vector2D({ EXUmath::EvaluatePolynomial(cx, seg1), EXUmath::EvaluatePolynomial(cy, seg1) });
		v0s = Vector2D({ EXUmath::EvaluatePolynomial(cx_t, seg0), EXUmath::EvaluatePolynomial(cy_t, seg0) });
		v1s = Vector2D({ EXUmath::EvaluatePolynomial(cx_t, seg1), EXUmath::EvaluatePolynomial(cy_t, seg1) });
		Real divlSeg = 1. / lSeg;
		p0 = divlSeg * ((seg[0] - seg0)*p1s + (seg1 - seg[0])*p0s);
		p1 = divlSeg * ((seg[1] - seg0)*p1s + (seg1 - seg[1])*p0s);
		v0 = divlSeg * ((seg[0] - seg0)*v1s + (seg1 - seg[0])*v0s);
		v1 = divlSeg * ((seg[1] - seg0)*v1s + (seg1 - seg[1])*v0s);
	}

	ResizableMatrix& locJac = tempData.localJacobian;
	ResizableMatrix& temp = tempData.localJacobian_t; //used as temporary matrix
	ResizableMatrix& temp2 = tempData.loadJacobian;   //used as temporary matrix

	for (Index i = 0; i < integrationPoints.NumberOfItems(); i++)
	{
		Real intFact = 0.5*(seg[1] - seg[0])*integrationWeights[i];

		Real x = 0.5*(seg[1] - seg[0])*integrationPoints[i] + 0.5*(seg[1] + seg[0]);
		Vector4D SV = CObjectANCFCable2DBase::ComputeShapeFunctions(x, L);
		Vector2D rANCF;
		Vector2D rANCF_t;
		if (settings.ancfCableUseExactMethod)
		{
			rANCF = Vector2D({ EXUmath::EvaluatePolynomial(cx, x), EXUmath::EvaluatePolynomial(cy, x) });
			rANCF_t = Vector2D({ EXUmath::EvaluatePolynomial(cx_t, x), EXUmath::EvaluatePolynomial(cy_t, x) });
		}
		else
		{
			rANCF = 0.5*((1 - integrationPoints[i])*p0 + (1 + integrationPoints[i])*p1);
			rANCF_t = 0.5*((1 - integrationPoints[i])*v0 + (1 + integrationPoints[i])*v1);
		}
		Vector2D dirForce = rANCF - circlePos;
		Vector2D vSphereJ({ sphere.velocity[0], sphere.velocity[1] });

		Real deltaVnormal = dirForce * (rANCF_t - vSphereJ); //penetration velocity, compute without tangential part for consistency reasons!

		if (dryFriction != 0.)
		{
			vSphereJ += sphere.angularVelocity[2] * Vector2D({ -dirForce[1], dirForce[0] }); //here, dirForce is still the relative vector; local angular velocity, but in 2D does not matter
		}
		Real dist = dirForce.GetL2Norm();
		Real gap = dist - (r + halfHeight);
		if (dist != 0.) { dirForce *= 1. / dist; } //otherwise, no action ... because dirForce=0

		Real contactForce = (stiffness * gap + damping * deltaVnormal);
		//Vector2D fContact = contactForce * dirForce;
		//pout << "fContact = " << fContact << "\n";
		//add friction: just on/off per segment?
		bool computeFrictionTerms = false;
		Vector2D deltaVtangent(0.);
		if (dryFriction != 0.)
		{
			//global relative velocity at contact point:
			deltaVtangent = (rANCF_t - vSphereJ) - deltaVnormal * dirForce;	//tangent velocity

			//Vector2D frictionAdd;
			//Real relVel;
			////negative contactForce, because it is a pressure
			//ContactHelper::ComputeFrictionForce<Vector2D, true>(frictionAdd, deltaVtangent, -contactForce, dryFriction,
			//	settings.frictionProportionalZone, relVel, frictionRegularizedRegion);

			//fContact += frictionAdd;
			//pout << "I=" << i << ", fContact=" << fVec << ", Ffric=" << fVec - f0 << ", dP0=" << n0 << ", vN=" << deltaVnormal << ", dV(I-J)=" << (vSphereI - vSphereJ) << ", deltaVtang=" << deltaVtangent << "\n";

#ifndef ANCFuseFrictionPenalty
			if (settings.frictionProportionalZone != 0) 
#endif
			{
				computeFrictionTerms = frictionRegularizedRegion;
			}

			//if (!frictionRegularizedRegion) { pout << "dry friction: vt=" << deltaVtangent << "\n"; }

		}

		//include intFact in every factorODE2/ODE2_t term; normal direction gives same terms for stiffness and velocity
		Real factNormal = intFact*(factorODE2 * stiffness + factorODE2_t * damping); 

		Vector3D d0({ dirForce[0], dirForce[1], 0. });

		Matrix3D JacFcPos; //this is the position-Jacobian (or velocity, but not rotation!)
		//JacFc.SetWithDiadicProduct(factNormal*d0, d0);
		Vector3D d0mu = d0;
#ifndef ANCFuseFrictionPenalty
		if (computeFrictionTerms) //second check not necessary, but used for safety!
		{
			d0mu -= dryFriction / settings.frictionProportionalZone * Vector3D({ deltaVtangent[0],deltaVtangent[1], 0. });
		}
#endif
		JacFcPos.SetWithDiadicProduct(factNormal*d0mu, d0);


		Matrix3D IsubDD; //(d0 x d0 - I)
		IsubDD.SetWithDiadicProduct(-d0, d0);
		IsubDD(0, 0) += 1.;
		IsubDD(1, 1) += 1.;
		IsubDD(2, 2) += 1.;
		Real factRegularizedFriction = 0.; //only non-zero in case of friction-regularized
		if (computeFrictionTerms) //second check not necessary, but used for safety!
		{

#ifndef ANCFuseFrictionPenalty
			factRegularizedFriction = intFact*factorODE2_t * contactForce * dryFriction / settings.frictionProportionalZone;
#else
			factRegularizedFriction = -1.*intFact * factorODE2_t * settings.frictionVelocityPenalty; //negative sign, because contactForce not included!
#endif
			JacFcPos += (-factRegularizedFriction)*IsubDD;
		}

		//if (true && dist != 0.) //this term seems not to be significant
		//{
		//	JacFcPos += (intFact*factorODE2*contactForce*1. / dist)*IsubDD;
		//}


		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

		const ResizableMatrix& JACj = *allPositionJacobians[jgj];
		
		//ANCF jacobian is computed manually-> use CSystem interface in future!
		ConstSizeMatrix<3* DANCFmaxCoordinates> JACi; // *allPositionJacobians[gi + index2JacIndexI];
		((CObjectBody*)cObject)->GetAccessFunctionBody(AccessFunctionType::TranslationalVelocity_qt,
			Vector3D({x,0.,0.}), temp);
		CHECKandTHROW(temp.NumberOfColumns()*temp.NumberOfRows() <= 3 * DANCFmaxCoordinates,
			"GeneralContact::JacobianODE2LHS: illegal jacobian of ANCF cable element");
		JACi.CopyFrom(temp);

		Index columnsj = JACj.NumberOfColumns();
		Index columnsi = JACi.NumberOfColumns();

		const ResizableMatrix& rotJACj = *allRotationJacobians[jgj];
		Index rotColumnsj = rotJACj.NumberOfColumns();

		//const ResizableMatrix& rotJACi = *allRotationJacobians[gi + index2JacIndexI];
		//Index rotColumnsi = rotJACi.NumberOfColumns();

//#define debugJac
#ifdef debugJac
		Index s = columnsi + columnsj;
		Matrix jac(s, s, 0.);
#endif
		Matrix3D rTildeD0;
		rTildeD0 = RigidBodyMath::Vector2SkewMatrix((sphere.radius + halfHeight)*d0);
		if (columnsj) //in case of ground elements ...
		{
			//force part sphere jj: 
			//Jposm1*d(f_circ)/dposm1*Jposm1
			EXUmath::MultMatrixMatrixTemplate(JacFcPos, JACj, temp);

			if (computeFrictionTerms && rotColumnsj != 0)
			{
				//Jposm1*d(f_circ)/drotm1*Jrotm1
				EXUmath::MultMatrixMatrixTemplate(factRegularizedFriction  * rTildeD0, rotJACj, temp2);

				temp += temp2;
			}
			EXUmath::MultMatrixTransposedMatrixTemplate(JACj, temp, locJac);

			//torque part jj:
			if (computeFrictionTerms && rotColumnsj != 0)
			{
				////reuse temp2 = d\fv_k /dq m1
				//Jrotm1*d(t_circ)/drotm1*Jrotm1
				EXUmath::MultMatrixMatrixTemplate(rTildeD0, temp, temp2);

				EXUmath::MultMatrixTransposedMatrixTemplate(rotJACj, temp2, temp);
				locJac += temp;
				//EXUmath::MultMatrixMatrixTemplate(rTildeD0, temp2, temp); //without all f_k terms
				//EXUmath::MultMatrixTransposedMatrixTemplate(rotJACj, temp, temp2);
				//locJac += temp2;
			}
#ifdef debugJac
			jac.SetSubmatrix(locJac, columnsi, columnsi, 1.);
#endif

			EXUmath::AddMatrixToSparseTripletVector(triplets, locJac, *allLTGs[jgj], *allLTGs[jgj]);

			if (columnsi)
			{
				//force part ji: 
				EXUmath::MultMatrixMatrixTemplate(-1.*JacFcPos, JACi, temp);

				EXUmath::MultMatrixTransposedMatrixTemplate(JACj, temp, locJac);

				//torque part ji:
				if (computeFrictionTerms && rotColumnsj != 0)
				{
					Matrix3D JacTorque; //JacFcPos includes factorODE2_t and intFact

					//negative term checked with pure regularized case; agrees with theDoc:
					RigidBodyMath::ApplySkewMatrixTemplate((sphere.radius+ halfHeight)*d0, -1.*JacFcPos, JacTorque);

					EXUmath::MultMatrixMatrixTemplate(JacTorque, JACi, temp);

					EXUmath::MultMatrixTransposedMatrixTemplate(rotJACj, temp, temp2); 
					locJac += temp2; 
				}

				EXUmath::AddMatrixToSparseTripletVector<ResizableMatrix, true>(triplets, locJac, *allLTGs[jgj], *allLTGs[jgi], 1.);
#ifdef debugJac
				jac.SetSubmatrix(locJac, columnsi, 0, 1.);
#endif


				//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
				//force part ANCFij: //negative sign added to JacFcPos term
				EXUmath::MultMatrixMatrixTemplate(-1.*JacFcPos, JACj, temp);

				EXUmath::MultMatrixTransposedMatrixTemplate(JACi, temp, locJac);

				//EXUmath::AddMatrixToSparseTripletVector<ResizableMatrix, false>(triplets, locJac, *allLTGs[jgi], *allLTGs[jgj], 1.);
#ifdef debugJac
				jac.SetSubmatrix(locJac.GetTransposed(), 0, columnsi, 1.);
#endif

			}
		}

		if (columnsi)
		{
			//only force part ANCF ii:
			EXUmath::MultMatrixMatrixTemplate(JacFcPos, JACi, temp);
			EXUmath::MultMatrixTransposedMatrixTemplate(JACi, temp, locJac);


			EXUmath::AddMatrixToSparseTripletVector(triplets, locJac, *allLTGs[jgi], *allLTGs[jgi]);

#ifdef debugJac
			jac.SetSubmatrix(locJac, 0, 0, 1.);
#endif
		}

#ifdef debugJac
		pout << "jac=" << jac << "\n";
#endif






		//++++++++++++++++++++++++++++++++++
		//now add forces to circle and ANCF:
		//tCircle += (r*dirForce).CrossProduct2D(fContact);
		//fCircle += fContact; //-= in Python!

		//for (Index i = 0; i < dim; i++)
		//{
		//	for (Index j = 0; j < ns; j++)
		//	{
		//		fANCF[j*dim + i] += SV[j] * fContact[i];
		//	}
		//}

	}
}



//! PostNewtonStep: update active sets for contact
//! recommended step size \f$h_{recom}\f$ after PostNewton(...): \f$h_{recom} < 0\f$: no recommendation, \f$h_{recom}==0\f$: use minimum step size, \f$h_{recom}>0\f$: use specific step size, if no smaller size requested by other reason
Real GeneralContact::PostNewtonStep(const CSystem& cSystem, TemporaryComputationDataArray& tempArray, Real& recommendedStepSize)
{
	if (verboseMode >= 2) { pout << "\n****************\n  Post Newton\nt=" << cSystem.GetSystemData().GetCData().currentState.GetTime() << "\n"; }

	if (cSystem.GetSolverData().doPostNewtonIteration)
	{
		STARTGLOBALTIMERmain(TScontactPostNewton);
		Index oldCnt = EXUstd::ArrayOfArraysTotalCount(allActiveContacts);
		Vector systemODE2Rhs; //dummy, unused

		ComputeContact<CCactiveSets>(cSystem, tempArray, systemODE2Rhs);

		STOPGLOBALTIMERmain(TScontactPostNewton);
		return fabs(EXUstd::ArrayOfArraysTotalCount(allActiveContacts) - oldCnt); //use change of total size of active sets for now
	}
	return 0.;
}

//! convert global contact index / bounding box index into local item index (e.g. markerBasedSpheres) and type
void GeneralContact::GlobalToLocalItemAndTypeIndex(Index globalIndex, Index& localIndex, Contact::TypeIndex& itemType)
{
	Index typeIndex = 0;
	while (typeIndex < Contact::IndexEndOfEnumList)
	{
		if (globalIndex < globalContactIndexOffsets[typeIndex+1])
		{
			localIndex = globalIndex - globalContactIndexOffsets[typeIndex];
			itemType = (Contact::TypeIndex)typeIndex;

			return;
		}
		typeIndex++;
	}
	itemType = Contact::IndexEndOfEnumList;
	localIndex = -1;
}

Index GeneralContact::GetItemsInBox(const Box3D& box,
	ArrayIndex& arrayMarkerBasedSpheres, ArrayIndex& arrayTrigsRigidBodyBased, ArrayIndex& arrayANCFCable2D)
{
	ArrayIndex& tempArray = *(addedObjects[0]); //thread 0 always exists
	ResizableArray<bool>& tempIndexFlags = *(addedObjectsFlags[0]); //thread 0 always exists

	searchTree.GetSingleItemsInBox(box, tempArray, tempIndexFlags);

	ArrayIndex* listArrays[(Index)Contact::IndexEndOfEnumList];
	listArrays[Contact::IndexSpheresMarkerBased] = &arrayMarkerBasedSpheres;
	listArrays[Contact::IndexANCFCable2D] = &arrayANCFCable2D;
	listArrays[Contact::IndexTrigsRigidBodyBased] = &arrayTrigsRigidBodyBased;

	Index localIndex;
	Contact::TypeIndex typeIndex;
	//now sort items into different kinds;
	for (Index gi : tempArray)
	{
		GlobalToLocalItemAndTypeIndex(gi, localIndex, typeIndex);
		CHECKandTHROW(typeIndex < Contact::IndexEndOfEnumList, "GeneralContact::GetItemsInBox: invalid typeIndex");
		listArrays[typeIndex]->AppendPure(localIndex);
	}
	return tempArray.NumberOfItems();
}

//! measure shortest distance to object along line with start point and direction; return false, if no item found inside given min/max distance
//! only points accepted in range [minDistance, maxDistance] including min, but excluding maxDistance
bool GeneralContact::ShortestDistanceAlongLine(const Vector3D& pStart, const Vector3D& direction, Real minDistance, Real maxDistance,
	Index& foundLocalIndex, Contact::TypeIndex& foundTypeIndex, Real& foundDistance, Real& foundVelocityAlongLine, Real cylinderRadius, Contact::TypeIndex selectedTypeIndex)
{
	if (maxDistance <= minDistance) { PyError("GeneralContact::ShortestDistanceAlongLine: minDistance must be smaller than maxDistance"); }

	//decide along which axis to search:
	Real dirLen = direction.GetL2Norm();
	if (dirLen == 0.) { PyError("GeneralContact::ShortestDistanceAlongLine: direction vector may not be [0,0,0]"); }

	Vector3D dir0 = direction * (1. / dirLen);
	
	//select along which axis to search (X, Y, Z)
	Index searchAxis = 0;
	if (fabs(dir0[1]) > fabs(dir0[0])) { searchAxis = 1; }
	if (fabs(dir0[2]) > fabs(dir0[1]) && fabs(dir0[2]) > fabs(dir0[0])) { searchAxis = 2; }
	//pout << "dir0=" << dir0 << ", searchAxis=" << searchAxis << "\n";

	CHECKandTHROW(dir0[searchAxis] != 0., "GeneralContact::ShortestDistanceAlongLine: search dir axis length should not be zero");

	Box3D boxST = searchTree.GetBox();
	Real minVal = boxST.PMin()[searchAxis];
	Real maxVal = boxST.PMax()[searchAxis];
	
	Real dAxis = dir0[searchAxis];
	Real pAxis = pStart[searchAxis];
	Real sizeAxis = maxVal - minVal;

	////find start and end values for searching in search tree box / min dist to cells
	Real minDistCells = (minVal - pAxis) / dAxis;
	Real maxDistCells = (maxVal - pAxis) / dAxis;
	//Index sign = (dAxis >= 0) ? 1 : -1;
	//if (maxDistCells < minDistCells)
	//if (pAxis > maxVal)
	//{
	//	EXUstd::Swap(minDistCells, maxDistCells); //check if minDistCells fits below: make drawing for pos/neg dir0!
	//}
	//Real minDistCells = 0.; //offset if sensor point placed outside searchTree cells
	//if (minVal > pAxis) { minDistCells = (minVal - pAxis) / dAxis; }
	//else if (maxVal < pAxis) { minDistCells = (pAxis - maxVal) / dAxis; }


	//search along given axis:
	Real startAxis = pAxis + minDistance * dAxis;
	Real endAxis = pAxis + maxDistance * dAxis;

	Index startIndex = searchTree.IndexOfReal(startAxis, searchAxis);
	Index endIndex = searchTree.IndexOfReal(endAxis, searchAxis);
	Index numCells = searchTree.SizeCellsXYZ()[searchAxis];
	Real stepSize = fabs(sizeAxis / (dAxis*(Real)numCells));
	//Index incr = 1;
	Index nSteps = endIndex - startIndex;

	//Real factDir = 1.; //for transverse direction of search tree
	if (nSteps < 0)  
	{ //reversed search
		nSteps = -nSteps;
		startIndex = numCells - startIndex - 1;
		minDistCells = maxDistCells;
	}

	//pout << "startIndex=" << startIndex
	//	<< ", nSteps=" << nSteps
	//	<< ", numCells=" << numCells
	//	<< ", startAxis=" << startAxis
	//	<< ", endAxis=" << endAxis
	//	<< ", stepSize=" << stepSize
	//	<< ", minDistCells=" << minDistCells
	//	<< ", pStart=" << pStart
	//	<< ", pA=" << pStart + minDistance * dir0
	//	<< ", pB=" << pStart + maxDistance * dir0
	//	<< "\n";

	ArrayIndex itemsFound;
	foundLocalIndex = -1;
	foundTypeIndex = Contact::IndexEndOfEnumList;
	foundDistance = maxDistance; //found distance must be smaller!
	foundVelocityAlongLine = 0.;

	Vector3D pStartDir = pStart + dir0;
	Vector2D pStart2D({ pStart[0], pStart[1] });
	//Vector2D pStartDir2D({ pStartDir[0], pStartDir[1] });
	Vector2D dir2D0({ dir0[0], dir0[1] });

	for (Index i = 0; i <= nSteps; i++) 
	{
		Vector3D p0 = pStart + dir0 * (minDistCells+(Real)(startIndex+i)*stepSize*(1. + 1e-7)); //enlarge slightly
		Vector3D p1 = pStart + dir0 * (minDistCells+(Real)(startIndex+(i+1))*stepSize*(1. - 1e-7)); //shrink slightly
		
		Box3D box(p0, p1);
		box.Increase(cylinderRadius); //this is partly inefficient because much more cells need to be searched for, but no simple solution for arbitrary orientation ...
		
		//pout << "dir0=" << dir0 << "\n";
		searchTree.GetItemsInBox(box, itemsFound); //may contain duplicates!
		//{
		//	Index6 bi; searchTree.GetBoxIndizes(box, bi);
		//	pout << "box=" << box << ", index0=" << bi[0] << "," << bi[1] << "," << bi[2] << "," << bi[3] << "," << bi[4] << "," << bi[5] << "\n";
		//  pout << "itemsFound=" << itemsFound << "\n";
		//}

		Index localIndex;
		Contact::TypeIndex typeIndex;
		//pout << "itemsFound=" << itemsFound.NumberOfItems() << "\n";
		for (Index item : itemsFound)
		{
			GlobalToLocalItemAndTypeIndex(item, localIndex, typeIndex);

			if (typeIndex == Contact::IndexSpheresMarkerBased && 
				(selectedTypeIndex == Contact::IndexEndOfEnumList || selectedTypeIndex == Contact::IndexSpheresMarkerBased))
			{
				Vector3D pos = spheresMarkerBased[localIndex].position;
				Real r = spheresMarkerBased[localIndex].radius;
				Real relPos;
				Real d = HGeometry::ShortestDistanceRelativePosition(pStart, pStartDir, pos, relPos);
				if (d <= (r+cylinderRadius)) //tangent point still works ...
				{
					Real deltaX;
					if (d <= cylinderRadius) { d = 0.; deltaX = r; } //in this case, sphere center point is inside cylinder => deltaX = r
					else 
					{ 
						d -= cylinderRadius;
						Real x = r * r - d * d;
						if (x < 0.) { x = 0.; } //for safety in case of rounding errors
						deltaX = sqrt(x); 
					}

					relPos -= deltaX;
					if (relPos >= minDistance && relPos < foundDistance)
					{
						//pout << "pos=" << pos << "\n";
						foundLocalIndex = localIndex;
						foundTypeIndex = typeIndex;
						foundDistance = relPos;
						foundVelocityAlongLine = dir0 * spheresMarkerBased[localIndex].velocity;
					}
				}

			}
			else if (typeIndex == Contact::IndexTrigsRigidBodyBased &&
				(selectedTypeIndex == Contact::IndexEndOfEnumList || selectedTypeIndex == Contact::IndexTrigsRigidBodyBased)) 

			{
				std::array<Vector3D, 3> trigPoints; //global triangle points

				const ContactTriangleRigidBodyBased& trigJ = trigsRigidBodyBased[localIndex];
				const ContactRigidBodyMarkerBased& rigid = rigidBodyMarkerBased[trigJ.contactRigidBodyIndex];

				//compute global points
				for (Index k = 0; k < (Index)trigPoints.size(); k++)
				{
					trigPoints[k] = rigid.orientation * trigJ.points[k] + rigid.position;
				}

				Vector3D nPlane = HGeometry::ComputeTriangleNormal(trigPoints);
				Real relativeDistance; //this is the distance from pStart to cutting point
				bool rv = HGeometry::LinePlaneIntersection(trigPoints[0], nPlane, pStart, dir0, relativeDistance);
				Vector3D pp = pStart + relativeDistance * dir0; //point in plane
				//pout << "index=" << localIndex << ", pp=" << pp << ", dist=" << relativeDistance 
				//	<< ", fd=" << foundDistance
				//	<< ", min=" << minDistance
				//	<< ", max=" << maxDistance
				//	<< "\n";

				if (rv && relativeDistance >= minDistance && relativeDistance < foundDistance) //only if not parallel
				{
					Vector3D pp = pStart + relativeDistance * dir0; //point in plane
					Real lam1, lam2; //relative triangle coordinates
					Vector3D e1 = trigPoints[1] - trigPoints[0];
					Vector3D e2 = trigPoints[2] - trigPoints[0];

					HGeometry::LocalTriangleCoordinates(e1, e2, pp - trigPoints[0], lam1, lam2);
					//check if pp is inside triangle or on edges
					const Real& TOL = settings.tolEquivalentPoints;
					bool inside = (lam1 >= -TOL) && (lam2 >= -TOL) && (lam1 + lam2 <= (1. + TOL));
					//pout << "index=" << localIndex << ", dist=" << relativeDistance << "  lam1=" << lam1 << ", lam2=" << lam2
					//	<< ", in=" << inside << "\n";

					if (inside)
					{
						foundLocalIndex = localIndex;
						foundTypeIndex = typeIndex;
						foundDistance = relativeDistance;

						Vector3D relPos = (trigPoints[0] + lam1 * e1 + lam2 * e2) - rigid.position;
						Vector3D velocity = rigid.velocity + (rigid.orientation * rigid.angularVelocity).CrossProduct(relPos);
						foundVelocityAlongLine = dir0 * velocity;
					}

				}
			}
			else if (typeIndex == Contact::IndexANCFCable2D && 
				(selectedTypeIndex == Contact::IndexEndOfEnumList || selectedTypeIndex == Contact::IndexANCFCable2D) &&
				(dir0[2] == 0)) //must be planar

			{
				const ConstSizeVector<DANCFmaxCoordinates>& q = ancfCable2D[localIndex].coordinates;
				const ConstSizeVector<DANCFmaxCoordinates>& q_t = ancfCable2D[localIndex].coordinates_t;
				Real L = ancfCable2D[localIndex].L;
				//Real halfHeight = ancfCable2D[localIndex].halfHeight;
				Index nSegments = settings.ancfCableMeasuringSegments;

				ConstSizeVector<4> c4x;
				ConstSizeVector<4> c4y;
				ConstSizeVector<4> c4x_t;
				ConstSizeVector<4> c4y_t;
				CObjectANCFCable2DBase::ComputePolynomialCoeffs<ConstSizeVector<DANCFmaxCoordinates>>(q, L, c4x, c4y);
				CObjectANCFCable2DBase::ComputePolynomialCoeffs<ConstSizeVector<DANCFmaxCoordinates>>(q_t, L, c4x_t, c4y_t);

				Real lSeg = L / (Real)nSegments;
				for (Index ix = 0; ix < nSegments; ix++)
				{
					Real x0 = ix * lSeg;
					Real x1 = (ix + 1) * lSeg;
					Vector2D p0({ EXUmath::EvaluatePolynomial(c4x, x0), EXUmath::EvaluatePolynomial(c4y, x0) });
					Vector2D p1({ EXUmath::EvaluatePolynomial(c4x, x1), EXUmath::EvaluatePolynomial(c4y, x1) });
					Real relPosDist;
					Real relPosANCF;
					bool rv = HGeometry::CuttingOf2DLineSegments(pStart2D, dir2D0, p0, p1 - p0, relPosDist, relPosANCF);

					if (rv && relPosANCF >= -settings.tolEquivalentPoints && relPosANCF <= 1. + settings.tolEquivalentPoints && relPosDist >= minDistance && relPosDist < foundDistance)
					{
						//foundLocalIndex = localIndex;
						//foundTypeIndex = typeIndex;
						//foundDistance = relPosDist;

						//make refinement: //with nSegments=20, this gives relative errors around 1e-8 against nSegments=10
						x1 = x0 + (relPosANCF + 0.5e-2)*lSeg; //refine area by factor of 100
						x0 = x0 + (relPosANCF - 0.5e-2)*lSeg; //refine area by factor of 100

						Vector2D p0({ EXUmath::EvaluatePolynomial(c4x, x0), EXUmath::EvaluatePolynomial(c4y, x0) });
						Vector2D p1({ EXUmath::EvaluatePolynomial(c4x, x1), EXUmath::EvaluatePolynomial(c4y, x1) });
						rv = HGeometry::CuttingOf2DLineSegments(pStart2D, dir2D0, p0, p1 - p0, relPosDist, relPosANCF);
						//==> gives refined relPosDist, which should have at least an accuracy around 1e-6

						if (rv && relPosDist >= minDistance && relPosDist < foundDistance)
						{
							Real xFound = x0 + relPosANCF * (x1-x0);
							Vector2D pFound({ EXUmath::EvaluatePolynomial(c4x, xFound), EXUmath::EvaluatePolynomial(c4y, xFound) });
							Real distFound = (pFound - pStart2D)*dir2D0; //this should give more accurate values than relPosDist

							foundLocalIndex = localIndex;
							foundTypeIndex = typeIndex;
							foundDistance = distFound; //simple tests showed that this value is converged up to 15 digits for "regular" large deformation per element

							//also compute velocity:
							Vector2D vANCF({ EXUmath::EvaluatePolynomial(c4x_t, xFound), EXUmath::EvaluatePolynomial(c4y_t, xFound) });
							foundVelocityAlongLine = dir2D0 * vANCF;
						}
					}

				}

			}
		}
		//if (foundLocalIndex != -1) { break; } 
	}
	//pout << "dist=" << foundDistance << "\n";
	return foundLocalIndex != -1;
}


//! update contact interactions, e.g. for ShortestDistanceAlongLine or for getting items in box
void GeneralContact::UpdateContacts(const CSystem& cSystem)
{
    STARTGLOBALTIMERmain(TScontactPostNewton);
    Vector systemODE2Rhs; //dummy, unused

    Index nThreads = exuThreading::TaskManager::GetNumThreads(); //must agree with tempArray
    if (externFunctionsTempArray.NumberOfItems() != nThreads)
    {
        externFunctionsTempArray.EraseData();		//totally reset; for safety for now!
        externFunctionsTempArray.SetNumberOfItems(nThreads);
        SetNumberOfThreads(nThreads);
    }

    ComputeContact<CCactiveSets>(cSystem, externFunctionsTempArray, systemODE2Rhs);

    STOPGLOBALTIMERmain(TScontactPostNewton);
}

//! get contact interactions of itemIndex of type selectedTypeIndex, e.g. IndexSpheresMarkerBased with index 2
//! returns list of contacts, with global indices OR in case of itemIndex == -1, it will return all items with active contacts of the contact type (0=first contact type item)
void GeneralContact::GetActiveContacts(Contact::TypeIndex selectedTypeIndex, Index itemIndex, ArrayIndex*& foundContacts)
{
    CHECKandTHROW(selectedTypeIndex < Contact::IndexEndOfEnumList && selectedTypeIndex >= 0, "GetContactInteractions: selectedTypeIndex must be within available types");
    Index nItemsAvailable = globalContactIndexOffsets[selectedTypeIndex+1] - globalContactIndexOffsets[selectedTypeIndex];

	if (itemIndex == -1)
	{
		//in this case, foundContacts is a default array, which we can fill
		Index nItems = globalContactIndexOffsets[selectedTypeIndex + 1] - globalContactIndexOffsets[selectedTypeIndex];
		foundContacts->SetMaxNumberOfItems(nItems);
		Index offset = globalContactIndexOffsets[selectedTypeIndex];
		for (Index i = 0; i < nItems; i++)
		{
			foundContacts->Append(allActiveContacts[offset + i]->NumberOfItems());
		}
	}
	else
	{
		//in this case, foundContacts will be set to destination array
		CHECKandTHROW(itemIndex < nItemsAvailable, "GetContactInteractions: itemIndex is out of available range");
		__UNUSED(nItemsAvailable); //avoid unused variable warnings

		Index globalIndex = itemIndex + globalContactIndexOffsets[selectedTypeIndex];

		foundContacts = allActiveContacts[globalIndex];

	}
}





#endif