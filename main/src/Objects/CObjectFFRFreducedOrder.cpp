/** ***********************************************************************************************
* @brief        CObjectFFRFreducedOrder implementation
*
* @author       Gerstmayr Johannes
* @date         2019-06-15 (generated)
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See "LICENSE.txt" for more details.
* @note         Bug reports, support and further information:
                - email: johannes.gerstmayr@uibk.ac.at
                - weblink: https://github.com/jgerstmayr/EXUDYN
                
************************************************************************************************ */

#include "Utilities/ExceptionsTemplates.h"
#include "Main/CSystemData.h"


#include "Autogenerated/CObjectFFRFreducedOrder.h"
#include "Linalg/RigidBodyMath.h"

//**delete
//#include "Main/MainSystem.h"
//#include "Pymodules/PybindUtilities.h"
//#include "Autogenerated/MainObjectFFRFreducedOrder.h"
//#include <pybind11/pybind11.h>
//#include <pybind11/stl.h>
//#include <pybind11/stl_bind.h>
//#include <pybind11/operators.h>
//#include <pybind11/numpy.h>       //interface to numpy
//#include <pybind11/buffer_info.h> //passing reference to matrix to numpy
//#include <pybind11/embed.h>       //scoped interpreter
////does not work globally: #include <pybind11/iostream.h> //used to redirect cout:  py::scoped_ostream_redirect output;
////#include <pybind11/cast.h> //for arguments
//#include <pybind11/functional.h> //for function handling ... otherwise gives a python error (no compilation error in C++ !)

//#define computeFFRFfullTerms//this mode does not work any more and according code parts can be erased / copied again from ObjectFFRF to create modally reduced equations

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

void CObjectFFRFreducedOrder::ComputeObjectCoordinates(Vector& coordinates, ConfigurationType configuration) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	coordinates.SetNumberOfItems(GetODE2Size());

	LinkedDataVector coordinatesRR(coordinates, 0, nODE2Rigid);
	LinkedDataVector coordinatesFF(coordinates, nODE2Rigid, nODE2FF);

	coordinatesRR = GetCNode(rigidBodyNodeNumber)->GetCoordinateVector(configuration);
	coordinatesFF = GetCNode(genericNodeNumber)->GetCoordinateVector(configuration);
}

void CObjectFFRFreducedOrder::ComputeObjectCoordinates_t(Vector& coordinates_t, ConfigurationType configuration) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	coordinates_t.SetNumberOfItems(GetODE2Size());

	LinkedDataVector coordinates_tRR(coordinates_t, 0, nODE2Rigid);
	LinkedDataVector coordinates_tFF(coordinates_t, nODE2Rigid, nODE2FF);

	coordinates_tRR = ((CNodeODE2*)GetCNode(rigidBodyNodeNumber))->GetCoordinateVector_t(configuration);
	coordinates_tFF = ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector_t(configuration);
}

Index CObjectFFRFreducedOrder::GetODE2Size() const
{
	return GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates() + GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
}

void CObjectFFRFreducedOrder::InitializeObject()
{
	//build all special matrices here
	physicsCenterOfMassTilde = RigidBodyMath::Vector2SkewMatrix(physicsCenterOfMass);

	//put more constant matrices here for speedup of computation ...

	//++++++++++++++++++++++++++
	//finally
	objectIsInitialized = true;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! Computational function: compute mass matrix
void CObjectFFRFreducedOrder::ComputeMassMatrix(EXUmath::MatrixContainer& massMatrixC, const ArrayIndex& ltg, Index objectNumber, bool computeInverse) const
{
	CHECKandTHROW(!computeInverse, "CObjectFFRFreducedOrder::ComputeMassMatrix: computeInverse=True not implemented, change solver settings: computeMassMatrixInversePerBody=False");

	Matrix& massMatrix = massMatrixC.GetInternalDenseMatrix();
	if (!objectIsInitialized) { PyError("CObjectFFRFreducedOrder::ComputeMassMatrix: objectIsInitialized = false: run Assemble() before computation."); }

	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	Index nODE2 = nODE2Rigid + nODE2FF; //total number of coordinates
	if (parameters.massMatrixUserFunction)
	{
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates);
		ComputeObjectCoordinates_t(tempCoordinates_t);

		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		EvaluateUserFunctionMassMatrix(massMatrix, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);
	}
	else //initialize with zero
	{
		massMatrix.SetNumberOfRowsAndColumns(nODE2, nODE2);
		massMatrix.SetAll(0.);
	}
	if (parameters.computeFFRFterms)
	{
		tempCoordinates.SetNumberOfItems(nODE2); 
		tempCoordinates_t.SetNumberOfItems(nODE2); 
		ComputeObjectCoordinates(tempCoordinates);
		ComputeObjectCoordinates_t(tempCoordinates_t);
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF);

		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12

		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();

		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		//precompute some matrices:
		RigidBodyMath::VectorKroneckerUnitMatrix3D(coordinatesFF, tempKronZetaI);
		//RigidBodyMath::VectorKroneckerUnitMatrix3D(coordinatesFF, tempKronZetaI_t); //not needed in mass matrix

		//Mtt: (constant!)
		Matrix3D Mtt(3, 3);
		Mtt.SetScalarMatrix(3, physicsMass);
		massMatrix.AddSubmatrix(Mtt, 0, 0);

//#define CObjectFFRFreducedOrderComputeMassMatrixOutput

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mtt=" << Mtt << "\n\n";
#endif

		//Mtr:
		//Mtr = -A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G
		//	self.massMatrixFFRFreduced[0:self.dim3D, self.dim3D : self.dim3D + self.nODE2rot] = Mtr
		//	self.massMatrixFFRFreduced[self.dim3D:self.dim3D + self.nODE2rot, 0 : self.dim3D] = Mtr.T
		Matrix3D temp;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(parameters.mPhitTPsiTilde, tempKronZetaI, temp);
		temp += physicsMass * physicsCenterOfMassTilde;
		temp = -1. * A * temp;

		EXUmath::MultMatrixMatrixTemplate<Matrix3D, ConstSizeMatrix<GMaxSize>, Matrix>(temp, Glocal, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, 0, nDim3D);
		massMatrix.AddTransposedSubmatrix(tempMatrix, nDim3D, 0);

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mtr=" << tempMatrix << "\n\n";
		pout << "temp=" << temp << "\n\n";
		pout << "Glocal=" << Glocal << "\n\n";
		pout << "physicsMass * physicsCenterOfMassTilde=" << physicsMass * physicsCenterOfMassTilde << "\n\n";
#endif

		//Mtf:
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, Matrix, Matrix>(A, parameters.mPhitTPsi, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, 0, nODE2Rigid);
		massMatrix.AddTransposedSubmatrix(tempMatrix, nODE2Rigid, 0);

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mtf=" << tempMatrix << "\n\n";
#endif

		//Mrf:
		EXUmath::MultMatrixTransposedMatrixTemplate<Matrix, Matrix, Matrix>(tempKronZetaI, parameters.mPsiTildePsi, tempMatrix2);
		tempMatrix2.AddSubmatrix(parameters.mXRefTildePsi,0,0); //+= operator would call new ...
		EXUmath::MultMatrixTransposedMatrixTemplate<ConstSizeMatrix<GMaxSize>, Matrix, Matrix>(Glocal, tempMatrix2, tempMatrix);
		tempMatrix *= -1;
		massMatrix.AddSubmatrix(tempMatrix, nDim3D, nODE2Rigid);
		massMatrix.AddTransposedSubmatrix(tempMatrix, nODE2Rigid, nDim3D);

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mrf=" << tempMatrix << "\n\n";
#endif

		//Mrr:
		//(self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + (self.mXRefTildePsiTilde @ zetaI).T + zetaI.T @ self.mPsiTildePsiTilde @ zetaI):
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(parameters.mXRefTildePsiTilde, tempKronZetaI, temp);
		Matrix3D temp2=temp;
		temp2.TransposeYourself();
		temp += temp2;
		temp += physicsInertia;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix>(parameters.mPsiTildePsiTilde, tempKronZetaI, tempMatrix);
		EXUmath::MultMatrixTransposedMatrixAddTemplate<Matrix, Matrix, Matrix3D>(tempKronZetaI, tempMatrix, temp);

		//Mrr = G.T@temp@G:
		EXUmath::MultMatrixMatrixTemplate<Matrix3D, ConstSizeMatrix<GMaxSize>, Matrix>(temp, Glocal, tempMatrix2);
		EXUmath::MultMatrixTransposedMatrixTemplate<ConstSizeMatrix<GMaxSize>, Matrix, Matrix>(Glocal, tempMatrix2, tempMatrix);
		massMatrix.AddSubmatrix(tempMatrix, nDim3D, nDim3D);

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mrr=" << tempMatrix << "\n\n";
#endif

		//++++++++++++++++++++++++++++++++
		//Mff:
		//currently, this matrix is zero if CMS user function is used!
		//parameters.massMatrixReduced.;
		if (parameters.massMatrixReduced.UseDenseMatrix())
		{
			//inefficient ...==> add functionality for sparse matrices!
			massMatrix.AddSubmatrix(parameters.massMatrixReduced.GetInternalDenseMatrix(), nODE2Rigid, nODE2Rigid); 
		}
		else
		{
			parameters.massMatrixReduced.GetInternalSparseTripletMatrix().AddToDenseMatrix(massMatrix, nODE2Rigid, nODE2Rigid);
		}

#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
		pout << "Mff=" << massMatrix.GetSubmatrix(nODE2Rigid, nODE2Rigid, nODE2FF, nODE2FF) << "\n";
#endif

//#ifdef CObjectFFRFreducedOrderComputeMassMatrixOutput
//		pout << "Mtt Mtr Mtf=" << massMatrix.GetSubmatrix(0, 0, nDim3D, nODE2Rigid+nODE2FF) << "\n";
//		pout << "Mrr        =" << massMatrix.GetSubmatrix(nDim3D, nDim3D, nODE2Rigid-nDim3D, nODE2Rigid - nDim3D) << "\n";
//		pout << "Mff        =" << massMatrix.GetSubmatrix(nODE2Rigid, nODE2Rigid, nODE2FF, nODE2FF) << "\n";
//#endif
	}
}








//! Computational function: compute right-hand-side (LHS) of second order ordinary differential equations (ODE) to "ode2Lhs"
//in fact, this is the LHS function!
void CObjectFFRFreducedOrder::ComputeODE2LHS(Vector& ode2Lhs, Index objectNumber) const
{
	Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
	Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();
	Index nODE2 = nODE2Rigid + nODE2FF; //total number of coordinates

	ode2Lhs.SetNumberOfItems(nODE2);
	ode2Lhs.SetAll(0.);

	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates);
	ComputeObjectCoordinates_t(tempCoordinates_t);

	if (parameters.computeFFRFterms)
	{
		//link to flexible parts of vectors:
		tempCoordinates.SetNumberOfItems(nODE2);
		tempCoordinates_t.SetNumberOfItems(nODE2);
		ComputeObjectCoordinates(tempCoordinates);
		ComputeObjectCoordinates_t(tempCoordinates_t);
		LinkedDataVector coordinatesFF(tempCoordinates, nODE2Rigid, nODE2FF);
		LinkedDataVector coordinatesFF_t(tempCoordinates_t, nODE2Rigid, nODE2FF);
		LinkedDataVector rp_t = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters_t();

		LinkedDataVector ode2LhsTT(ode2Lhs, 0, ffrfNodeDim);
		LinkedDataVector ode2LhsRR(ode2Lhs, ffrfNodeDim, nODE2Rigid-ffrfNodeDim);
		LinkedDataVector ode2LhsFF(ode2Lhs, nODE2Rigid, nODE2FF);

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//K*q and D*q_T put to LHS !!!
		//stiffness matrix:
		if (parameters.stiffnessMatrixReduced.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.stiffnessMatrixReduced, coordinatesFF, ode2LhsFF);
			parameters.stiffnessMatrixReduced.MultMatrixVectorAdd(coordinatesFF, ode2LhsFF);
			//pout << "coordinatesFF=" << coordinatesFF << "\n";
		}

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//damping matrix:
		if (parameters.dampingMatrixReduced.NumberOfRows() != 0)
		{
			//EXUmath::MultMatrixVectorAdd(parameters.dampingMatrixReduced, coordinatesFF_t, ode2LhsFF);
			parameters.dampingMatrixReduced.MultMatrixVectorAdd(coordinatesFF_t, ode2LhsFF);
		}

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		const Index GMaxSize = CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D; //12

		//compute G-matrices:
		ConstSizeMatrix<GMaxSize> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);
		ConstSizeMatrix<GMaxSize> GlocalT;
		GlocalT = Glocal.GetTransposed();

		ConstSizeMatrix<GMaxSize> Glocal_t;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal_t(Glocal_t);

		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();

		Vector3D omega3D = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(); //omega3D == local!
		Matrix3D omega3Dtilde = RigidBodyMath::Vector2SkewMatrix(omega3D);

		//precompute some matrices:
		RigidBodyMath::VectorKroneckerUnitMatrix3D(coordinatesFF, tempKronZetaI);
		RigidBodyMath::VectorKroneckerUnitMatrix3D(coordinatesFF_t, tempKronZetaI_t);

		Vector3D G_tRp_t;
		EXUmath::MultMatrixVectorTemplate< ConstSizeMatrix<GMaxSize>, LinkedDataVector, Vector3D>(Glocal_t, rp_t, G_tRp_t);

		//this matrix, containing mostly zeros, could be replaced by operator (speedup!):
		//is already transposed matrix!
		tempKronIZetaOmegaT.SetNumberOfRowsAndColumns(nODE2FF, 3 * nODE2FF);
		tempKronIZetaOmegaT.SetAll(0.);
		for (Index i = 0; i < nODE2FF; i++)
		{
			tempKronIZetaOmegaT(i, i * 3 + 0) = omega3D[0];
			tempKronIZetaOmegaT(i, i * 3 + 1) = omega3D[1];
			tempKronIZetaOmegaT(i, i * 3 + 2) = omega3D[2];
		}

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//note that in FEM.py and in the paper (Zwölfer, Gerstmayr, 2021, Acta Mechanica), terms are added to RHS (+), here they are added to LHS (-=)
		//Q_tt
		//force[0:self.dim3D] -= (A @ omega3Dtilde @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ omega3D +
		//			2 * A @ self.mPhitTPsiTilde @ zeta_tI @ omega3D) #identical to FFRF up to 1e-16

		Matrix3D temp;
		EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(parameters.mPhitTPsiTilde, tempKronZetaI, temp);
		temp += physicsMass * physicsCenterOfMassTilde;

		Vector3D fTempTT = A * (omega3Dtilde * (temp * omega3D));
		EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI_t, omega3D, tempVector); //3*nODE2FF length
		Vector3D fTemp2; //2 * (A * (parameters.mPhitTPsiTilde * (tempKronZetaI_t * omega3D)));
		EXUmath::MultMatrixVectorTemplate<Matrix, ResizableVector, Vector3D>(parameters.mPhitTPsiTilde, tempVector, fTemp2); //3*nODE2FF length
		fTempTT += 2 * (A*fTemp2);

		ode2LhsTT -= fTempTT;


		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//Q_rr
		//force[self.dim3D:self.nODE2rigid] -= (-G.T @ omega3Dtilde @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI +
		//			zetaI.T @ self.mXRefTildePsiTilde.T + #transposed!
		//			zetaI.T @ self.mPsiTildePsiTilde @ zetaI) @ omega3D -
		//			2 * G.T @ (self.mXRefTildePsiTilde @ zeta_tI + zetaI.T @ self.mPsiTildePsiTilde @ zeta_tI) @ omega3D)  #identical to FFRF up to 1e-16

		//(self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + (self.mXRefTildePsiTilde @ zetaI).T + zetaI.T @ self.mPsiTildePsiTilde @ zetaI)*omega3D:
		Vector3D temp3D = physicsInertia * omega3D;
		EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI, omega3D, tempVector2); //tempVector2=zetaI*omega3D
		EXUmath::MultMatrixVectorAddTemplate<Matrix, ResizableVector, Vector3D>(parameters.mXRefTildePsiTilde, tempVector2, temp3D);

		EXUmath::MultMatrixTransposedVectorTemplate<Matrix, Vector3D, ResizableVector>(parameters.mXRefTildePsiTilde, omega3D, tempVector);
		EXUmath::MultMatrixTransposedVectorAddTemplate<ResizableMatrix, ResizableVector, Vector3D>(tempKronZetaI, tempVector, temp3D);

		EXUmath::MultMatrixVectorTemplate<Matrix, ResizableVector, ResizableVector>(parameters.mPsiTildePsiTilde, tempVector2, tempVector);
		EXUmath::MultMatrixTransposedVectorAddTemplate<ResizableMatrix, ResizableVector, Vector3D>(tempKronZetaI, tempVector, temp3D);

		//G.T * omega3Dtilde * (...)
		Vector3D QrrTerm1 = omega3Dtilde * temp3D;
		ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> fTempRR(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates());
		EXUmath::MultMatrixVectorTemplate< ConstSizeMatrix<GMaxSize>, Vector3D, ConstSizeVector<CNodeRigidBody::maxRotationCoordinates>>(GlocalT, QrrTerm1, fTempRR);

		//(self.mXRefTildePsiTilde @ zeta_tI + zetaI.T @ self.mPsiTildePsiTilde @ zeta_tI)*omega3D
		EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI_t, omega3D, tempVector2); //tempVector2=zetaI_t*omega3D

		EXUmath::MultMatrixVectorTemplate<Matrix, ResizableVector, Vector3D>(parameters.mXRefTildePsiTilde, tempVector2, temp3D);

		EXUmath::MultMatrixVectorTemplate<Matrix, ResizableVector, ResizableVector>(parameters.mPsiTildePsiTilde, tempVector2, tempVector);
		EXUmath::MultMatrixTransposedVectorAddTemplate<ResizableMatrix, ResizableVector, Vector3D>(tempKronZetaI, tempVector, temp3D);

		//2 * G.T @ (...)
		Vector3D QrrTerm2 = 2 * temp3D;
		EXUmath::MultMatrixVectorAddTemplate< ConstSizeMatrix<GMaxSize>, Vector3D, ConstSizeVector<CNodeRigidBody::maxRotationCoordinates>>(GlocalT, QrrTerm2, fTempRR);

		ode2LhsRR += fTempRR; //-= [-G.T*(...) - G.T*(...) ] ==> +=

		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//Q_rr SLOW
		////(self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI + (self.mXRefTildePsiTilde @ zetaI).T + zetaI.T @ self.mPsiTildePsiTilde @ zetaI):
		//EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(parameters.mXRefTildePsiTilde, tempKronZetaI, temp);
		//Matrix3D temp2 = temp;
		//temp2.TransposeYourself();
		//temp += temp2;
		//temp += physicsInertia;
		//EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix>(parameters.mPsiTildePsiTilde, tempKronZetaI, tempMatrix);
		//EXUmath::MultMatrixTransposedMatrixAddTemplate<Matrix, Matrix, Matrix3D>(tempKronZetaI, tempMatrix, temp);

		////G.T * omega3Dtilde * (...) *omega3D
		//Vector3D QrrTerm1 = omega3Dtilde * (temp * omega3D);
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> fTempRR(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates());
		//EXUmath::MultMatrixVectorTemplate< ConstSizeMatrix<GMaxSize>, Vector3D, ConstSizeVector<CNodeRigidBody::maxRotationCoordinates>>(GlocalT, QrrTerm1, fTempRR);

		//(self.mXRefTildePsiTilde @ zeta_tI + zetaI.T @ self.mPsiTildePsiTilde @ zeta_tI)
		//EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix3D>(parameters.mXRefTildePsiTilde, tempKronZetaI_t, temp);
		//EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix>(parameters.mPsiTildePsiTilde, tempKronZetaI_t, tempMatrix);
		//EXUmath::MultMatrixTransposedMatrixAddTemplate<Matrix, Matrix, Matrix3D>(tempKronZetaI, tempMatrix, temp);

		////2 * G.T @ (...)*omega3D
		//Vector3D QrrTerm2 = 2 * (temp * omega3D);
		//EXUmath::MultMatrixVectorAddTemplate< ConstSizeMatrix<GMaxSize>, Vector3D, ConstSizeVector<CNodeRigidBody::maxRotationCoordinates>>(GlocalT, QrrTerm2, fTempRR);

		//ode2LhsRR += fTempRR; //-= [-G.T*(...) - G.T*(...) ] ==> +=




		
		//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		//Q_ff
		//		force[self.nODE2rigid:] -= (IZetadiadicOmega.T @ (self.mXRefTildePsiTilde.T + self.mPsiTildePsiTilde @ zetaI) @ omega3D +
		//			2 * self.mPsiTildePsi.T @ zeta_tI @ omega3D )#identical to FFRF up to 1e-16


		EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI, omega3D, tempVector); 
		EXUmath::MultMatrixVectorTemplate<Matrix, ResizableVector, ResizableVector>(parameters.mPsiTildePsiTilde, tempVector, tempVector2);
		EXUmath::MultMatrixTransposedVectorAddTemplate<Matrix, Vector3D, ResizableVector>(parameters.mXRefTildePsiTilde, omega3D, tempVector2);
		tempVector2 *= -1.; //(-): add to LHS ...
		EXUmath::MultMatrixVectorAddTemplate<ResizableMatrix, ResizableVector, LinkedDataVector>(tempKronIZetaOmegaT, tempVector2, ode2LhsFF);

		//"-2"*omega3D: add to LHS, factor 2:
		EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI_t, (-2.)*omega3D, tempVector);
		EXUmath::MultMatrixTransposedVectorAddTemplate<Matrix, ResizableVector, LinkedDataVector>(parameters.mPsiTildePsi, tempVector, ode2LhsFF);		

		////+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
		////Q_ff SLOW:
		////		force[self.nODE2rigid:] -= (IZetadiadicOmega.T @ (self.mXRefTildePsiTilde.T + self.mPsiTildePsiTilde @ zetaI) @ omega3D +
		////			2 * self.mPsiTildePsi.T @ zeta_tI @ omega3D )#identical to FFRF up to 1e-16
		//EXUmath::MultMatrixMatrixTemplate<Matrix, Matrix, Matrix>(parameters.mPsiTildePsiTilde, tempKronZetaI, tempMatrix);
		//EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempMatrix, omega3D, tempVector);
		//EXUmath::MultMatrixTransposedVectorAddTemplate< Matrix, Vector3D, ResizableVector>(parameters.mXRefTildePsiTilde, omega3D, tempVector);
		//tempVector *= -1.; //(-): add to LHS ...
		//EXUmath::MultMatrixVectorAddTemplate< ResizableMatrix, ResizableVector, LinkedDataVector>(tempKronIZetaOmegaT, tempVector, ode2LhsFF);

		////"-2"*omega3D: add to LHS, factor 2
		//EXUmath::MultMatrixVectorTemplate<ResizableMatrix, Vector3D, ResizableVector>(tempKronZetaI_t, -2 * omega3D, tempVector);
		//EXUmath::MultMatrixTransposedVectorAddTemplate<Matrix, ResizableVector, LinkedDataVector>(parameters.mPsiTildePsi, tempVector, ode2LhsFF);

		
//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//			#additional terms for Euler angles :
//		if self.rigidBodyNodeType == exu.NodeType.RotationRxyz :
//			force[0:self.dim3D] -= A @ (self.totalMass*self.chiUtilde + self.mPhitTPsiTilde @ zetaI) @ G_tRp_t
//
//			force[self.dim3D:self.nODE2rigid] -= -G.T @ (self.inertiaLocal + self.mXRefTildePsiTilde @ zetaI +
//				zetaI.T @ self.mXRefTildePsiTilde.T +
//				zetaI.T @ self.mPsiTildePsiTilde @ zetaI) @ G_tRp_t
//
//			force[self.nODE2rigid:] -= (self.mXRefTildePsi.T + self.mPsiTildePsi.T @ zetaI) @ G_tRp_t
//



//#++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//			#add gravity(needs to be tested) :
//			if True :
//				force[0:self.dim3D] -= self.totalMass*np.array(self.gravity)
//				force[self.dim3D:self.nODE2rigid] -= G.T @ (Skew(self.chiU) @ (self.totalMass*A.T @ np.array(self.gravity)))
//				force[self.nODE2rigid:] -= self.mPhitTPsi.T @ (A.T @ np.array(self.gravity))
//

		//pout << "ode2RhsTT=" << -1*ode2LhsTT << "\n";
		//pout << "ode2RhsRR=" << -1*ode2LhsRR << "\n";
		//pout << "ode2RhsFF=" << -1*ode2LhsFF << "\n";


	}
	if (parameters.forceUserFunction)
	{
		Real t = GetCSystemData()->GetCData().GetCurrent().GetTime();

		EvaluateUserFunctionForce(tempUserFunctionForce, cSystemData->GetMainSystemBacklink(), t, objectNumber, tempCoordinates, tempCoordinates_t);
		//UserFunctionExceptionHandling([&] //lambda function to add consistent try{..} catch(...) block
		//{
		//	//user function args:(t, coordinates, coordinates_t)
		//	tempUserFunctionForce = (Vector)(parameters.forceUserFunction(t, tempCoordinates, tempCoordinates_t));
		//}, "ObjectFFRFreducedOrder::forceUserFunction");

		ode2Lhs -= tempUserFunctionForce;
	}

}


//! Flags to determine, which access (forces, moments, connectors, ...) to object are possible
AccessFunctionType CObjectFFRFreducedOrder::GetAccessFunctionTypes() const
{
	return (AccessFunctionType)((Index)AccessFunctionType::TranslationalVelocity_qt + 
		(Index)AccessFunctionType::AngularVelocity_qt +
		//(Index)AccessFunctionType::JacobianTtimesVector_q + //to be implemented!
		(Index)AccessFunctionType::DisplacementMassIntegral_q +
		(Index)AccessFunctionType::SuperElement);
}

//! provide Jacobian at localPosition in "value" ONLY OF reference frame, according to configuration type
//! however, DisplacementMassIntegral_q also works for the FFRF body!
void CObjectFFRFreducedOrder::GetAccessFunctionBody(AccessFunctionType accessType, const Vector3D& localPosition, Matrix& value) const
{
#ifndef __EXUDYN__APPLE__ //static_assert not supported by older MAC compilers
	static_assert(CNodeRigidBody::nDim3D == CNodeRigidBody::maxDisplacementCoordinates); //add this code to raise compiler error, if max. number of displacement coordiantes changes in RigidBodyNode ==> requires reimplementation in this file!
#endif
	switch (accessType)
	{
	case AccessFunctionType::TranslationalVelocity_qt: //global translational velocity at localPosition derivative w.r.t. qt = L-matrix = [I   -A*uLocalTilde*Glocal]
	{
		//this function relates a 3D translatory velocity to the time derivative of all coordinates: v_trans = Jac*q_dot
		//Jac = -A*uLocalTilde*Glocal
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);

		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix(-localPosition); //negative sign in -A*uLocalTilde*Glocal
		//uLocalTilde *= -1.;//moved into (-localPosition)

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal now is: A*(-uLocalTilde)*Glocal

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		//unit matrix
		value(0, 0) = 1.; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = 1.; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = 1.;

		//-A*uLocalTilde*Glocal part (=L in this case
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
			}
		}


		break;
	}
	case AccessFunctionType::AngularVelocity_qt: //global angular velocity
	{
		//d(omega)/d(q_t): derivative of angular velocity w.r.t. all coordinates_t = [0_{3x3} G-matrix]
		//ConstSizeVector<CNodeRigidBody::maxRotationCoordinates> rot = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationParameters();
		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> G;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetG(G);// RigidBodyMath::EP2G(rot);

		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			value(0, i) = 0;
			value(1, i) = 0;
			value(2, i) = 0;
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = G(i, j);
			}
		}
		break;
	}
	case AccessFunctionType::DisplacementMassIntegral_q:
	{
		value.SetNumberOfRowsAndColumns(CNodeRigidBody::nDim3D, GetODE2Size());

		Real m = physicsMass;

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> AuTildeGlocal;
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(AuTildeGlocal);// RigidBodyMath::EP2Glocal(rot);
		CHECKandTHROW(physicsCenterOfMass == localPosition, "CObjectFFRFreducedOrder::GetAccessFunctionBody:DisplacementMassIntegral_q: inconsistent localPosition");

		//negative sign in -A*uLocalTilde*Glocal; transposed as compared to paper and earlier gravity force in FEM.py
		ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*physicsCenterOfMass); 

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		EXUmath::MultMatrixMatrix(uLocalTilde, AuTildeGlocal, temp);
		Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix();
		EXUmath::MultMatrixMatrix(A, temp, AuTildeGlocal); //AuTildeGlocal=A*(-m*uLocalTilde)*Glocal

		//g.T @ (self.totalMass*np.eye(3))
		value(0, 0) = m; value(0, 1) = 0.; value(0, 2) = 0.;
		value(1, 0) = 0.; value(1, 1) = m; value(1, 2) = 0.;
		value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m;

		//m * Glocal.T @ (Skew(self.chiU) @ (A.T @ g)) ==> - m*g.T * A * Skew(self.chiU) * Glocal
		//-m*A*uLocalTilde*Glocal part = m*Glocal^T uLocalTilde A^T
		for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		{
			for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
			{
				value(i, CNodeRigidBody::nDim3D + j) = AuTildeGlocal(i, j);
			}
		}
		//pout << "value               =" << value.NumberOfRows() << " x " << value.NumberOfColumns() << "\n";
		//pout << "parameters.mPhitTPsi=" << parameters.mPhitTPsi.NumberOfRows() << " x " << parameters.mPhitTPsi.NumberOfColumns() << "\n";

		//self.mPhitTPsi.T @ (A.T * g) ==> g.T * A * self.mPhitTPsi
		if (parameters.mPhitTPsi.NumberOfRows() != 0) //otherwise it uses the user function ...
		{
			Index nODE2Rigid = GetCNode(rigidBodyNodeNumber)->GetNumberOfODE2Coordinates(); //number of rigid body coordinates
			Index nODE2FF = GetCNode(genericNodeNumber)->GetNumberOfODE2Coordinates();

			//pout << "nODE2FF             =" << nODE2FF << "\n";

			CHECKandTHROW((parameters.mPhitTPsi.NumberOfRows() == CNodeRigidBody::nDim3D) &&
				(parameters.mPhitTPsi.NumberOfColumns() == nODE2FF), "CObjectFFRFreducedOrder::GetAccessFunctionBody:DisplacementMassIntegral_q: inconsistent dimensions of matrix mPhitTPsi");

			//EXUmath::MultMatrixTransposedMatrixTemplate<Matrix, Matrix3D, ResizableMatrix>(parameters.mPhitTPsi, A.GetTransposed(), tempMatrix);
			EXUmath::MultMatrixMatrixTemplate<Matrix3D, Matrix, ResizableMatrix>(A, parameters.mPhitTPsi, tempMatrix);
			//pout << "tempMatrix          =" << tempMatrix.NumberOfRows() << " x " << tempMatrix.NumberOfColumns() << "\n";

			for (Index i = 0; i < tempMatrix.NumberOfRows(); i++)
			{
				for (Index j = 0; j < tempMatrix.NumberOfColumns(); j++)
				{
					value(i, nODE2Rigid + j) = tempMatrix(i, j);
				}
			}
		}



		////this is incomplete:
		//if (physicsCenterOfMass == 0.)
		//{
		//	for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		//	{
		//		for (Index j = 0; j < GetODE2Size(); j++)
		//		{
		//			if (i != j) { value(i, j) = 0.; }
		//			else { value(i, j) = m; } //only diagonal 3x3 term!
		//		}
		//	}
		//}
		//else
		//{

		//	//gives m* \partial p_COM / \partial q
		//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> Glocal;
		//	((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetGlocal(Glocal);// RigidBodyMath::EP2Glocal(rot);
		//	CHECKandTHROW(physicsCenterOfMass == localPosition, "CObjectRigidBody::GetAccessFunctionBody: inconsistent localPosition");


		//	ConstSizeMatrix<9> uLocalTilde = RigidBodyMath::Vector2SkewMatrix((-m)*physicsCenterOfMass); //negative sign in -A*uLocalTilde*Glocal
		//	//uLocalTilde *= -1.;//moved into ((-m)*parameters.physicsCenterOfMass)

		//	ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates * CNodeRigidBody::nDim3D> temp; //temporary matrix during computation
		//	EXUmath::MultMatrixMatrix(uLocalTilde, Glocal, temp);
		//	EXUmath::MultMatrixMatrix(((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(), temp, Glocal); //Glocal=A*(-m*uLocalTilde)*Glocal

		//	//unit matrix
		//	value(0, 0) = m; value(0, 1) = 0.; value(0, 2) = 0.;
		//	value(1, 0) = 0.; value(1, 1) = m; value(1, 2) = 0.;
		//	value(2, 0) = 0.; value(2, 1) = 0.; value(2, 2) = m;

		//	//-A*uLocalTilde*Glocal part (=L in this case
		//	for (Index i = 0; i < CNodeRigidBody::nDim3D; i++)
		//	{
		//		for (Index j = 0; j < ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetNumberOfRotationCoordinates(); j++)
		//		{
		//			value(i, CNodeRigidBody::nDim3D + j) = Glocal(i, j);
		//		}
		//	}
		//}

		break;
	}
	default:
		SysError("CObjectFFRFreducedOrder:GetAccessFunctionBody illegal accessType");
	}
}

//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     REFERENCE FRAME FUNCTIONS     ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! provide according output variable in "value", localPosition ONLY REFERS TO THE REFERENCE FRAME!
void CObjectFFRFreducedOrder::GetOutputVariableBody(OutputVariableType variableType, const Vector3D& localPosition, ConfigurationType configuration, Vector& value, Index objectNumber) const
{
	Index nODE2 = GetODE2Size();
	tempCoordinates.SetNumberOfItems(nODE2);
	tempCoordinates_t.SetNumberOfItems(nODE2);
	ComputeObjectCoordinates(tempCoordinates, configuration);
	ComputeObjectCoordinates_t(tempCoordinates_t, configuration);

	switch (variableType)
	{
	case OutputVariableType::Coordinates:	value.CopyFrom(tempCoordinates);	break;
	case OutputVariableType::Coordinates_t: value.CopyFrom(tempCoordinates_t);	break;
	case OutputVariableType::Force:			ComputeODE2LHS(value, objectNumber);	break;
	default:
		SysError("CObjectFFRFreducedOrder::GetOutputVariableBody failed"); //error should not occur, because types are checked!
	}
}


//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetPosition(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) + 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * localPosition;

}

//  return the (global) position of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(localPosition); //add omega x r
}

//! return the (global) displacement of "localPosition" ONLY OF reference frame, according to configuration type
Vector3D CObjectFFRFreducedOrder::GetDisplacement(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration) - 
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(ConfigurationType::Reference); //this also works for NodePointGround
}

//! return the rotation matrix ONLY OF reference frame (localPosition ignored), according to configuration type
Matrix3D CObjectFFRFreducedOrder::GetRotationMatrix(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
}

//! return configuration dependent angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRFreducedOrder::GetAngularVelocity(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
}

//! return configuration dependent local (=body fixed) angular velocity ONLY OF reference frame (localPosition ignored), according to configuration type
Vector3D CObjectFFRFreducedOrder::GetAngularVelocityLocal(const Vector3D& localPosition, ConfigurationType configuration) const
{
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration);
}



//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//+++++++++++++++     MESH NODE FUNCTIONS      +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

//! compute coordinates for nodeNumber(without reference coordinates) from modeBasis(= multiplication of according part of mode Basis with modal coordinates)
Vector3D CObjectFFRFreducedOrder::GetMeshNodeCoordinates(Index nodeNumber, const Vector& coordinates) const
{
	Vector3D u({ 0.,0.,0. }); //can be displacements and velocities, depending on coordinates!
	const Matrix& Psi = parameters.modeBasis;
	Index nModes = Psi.NumberOfColumns();
	Index nOffset = nodeNumber*3; //offset in modeBasis, giving according x-coordinates of node

	for (Index i = 0; i < 3; i++) //node coordinates x,y,z
	{
		for (Index j = 0; j < nModes; j++) //iteration over all modes / modal coordinates
		{
			u[i] += Psi(nOffset + i, j) * coordinates[j];
		}
	}
	return u;
}

//! for definition see CObjectSuperElement
void CObjectFFRFreducedOrder::GetAccessFunctionSuperElement(AccessFunctionType accessType, const Matrix& weightingMatrix, 
	const ArrayIndex& meshNodeNumbers, const Vector3D& localOffset, Matrix& value) const
{ 
	bool useAlternativeApproach = false;
	if (EXUstd::IsOfType(accessType, AccessFunctionType::SuperElementAlternativeRotationMode)) 
	{ 
		useAlternativeApproach = true; //must be same as in CMarkerSuperElementRigid! alternative approach uses skew symmetric matrix of reference position; follows the inertia concept
		accessType = (AccessFunctionType)((Index)accessType - (Index)AccessFunctionType::SuperElementAlternativeRotationMode);
	}

	switch ((Index)accessType)
	{
	case (Index)AccessFunctionType::TranslationalVelocity_qt + (Index)AccessFunctionType::SuperElement: 
	//global translational velocity at mesh position derivative w.r.t. all q_t: with reference frame: 
	//\partial vMarker / \partial q_t = [I, -A * pLocalTilde * Glocal, A*(w0*PsiNode0+w1*PsiNode1+...)]
	{
		const CNodeRigidBody* cNode = (const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber);
		Index nODE2rigid = cNode->GetNumberOfODE2Coordinates();
		const Matrix& modeBasis = parameters.modeBasis;
		Index nModes = modeBasis.NumberOfColumns();

		CHECKandTHROW(weightingMatrix.NumberOfColumns() == 1, "CObjectFFRFreducedOrder::GetAccessFunctionSuperElement: weightingMatrix must have one column only");

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		value.SetAll(0.);

		//++++++++++++++++++++++++++++++++++++++
		//add action for flexible part:
		Matrix3D A;
		A = ((const CNodeODE2*)(GetCNode(rigidBodyNodeNumber)))->GetRotationMatrix();

		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			//assume that the first 3 coordinates of the node are the displacement coordinates!!!
			Matrix3D jac = A;
			jac *= weightingMatrix(i, 0);
			Index offset = meshNodeNumbers[i] * 3;
			for (Index j = 0; j < 3; j++)
			{
				for (Index k = 0; k < 3; k++)
				{
					for (Index m = 0; m < nModes; m++)
					{
						value(j, nODE2rigid+m) += jac(j,k) * parameters.modeBasis(offset+k, m);
					}
				}
			}
		}

		//++++++++++++++++++++++++++++++++++++++
		//add action for REFERENCE FRAME NODE:
		//\partial vMarker / \partial q_t = [I, -A * pLocalTilde * Glocal, A*(w0*nodeJac0, w1*nodeJac1, ...)]

		Vector3D localPosition = localOffset;// ({ 0,0,0 });
		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			localPosition += weightingMatrix(i, 0) * GetMeshNodeLocalPosition(meshNodeNumbers[i]); //((const CNodeODE2&)cSystemData.GetCNode(cObject.GetNodeNumber(nodeNumbers[i]))).GetPosition();
		}

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::nDim3D> ApLocalTildeGlocal;

		//compute: -A*pLocalTilde*GLocal
		cNode->GetGlocal(ApLocalTildeGlocal);
		EXUmath::ApplyTransformation33(RigidBodyMath::Vector2SkewMatrixTemplate(-localPosition), ApLocalTildeGlocal);
		EXUmath::ApplyTransformation33(A, ApLocalTildeGlocal);

		//now compute remaining jacobian terms for reference frame motion; posJac0 must have already correct size (because of LinkedDataMatrix)
		ConstSizeMatrix<CNodeRigidBody::nDim3D * (CNodeRigidBody::maxDisplacementCoordinates + CNodeRigidBody::maxRotationCoordinates)> posJac0(nDim3D, nODE2rigid);
		LinkedDataMatrix linkedPosJac0(posJac0);
		cNode->GetPositionJacobian(linkedPosJac0); //usually identity, because node does not include localPosition

		value.SetSubmatrix(posJac0, 0, 0); //writes 3x7 matrix for Euler parameters...
		value.SetSubmatrix(ApLocalTildeGlocal, 0, CNodeRigidBody::maxDisplacementCoordinates);
		break;
	}
	case (Index)AccessFunctionType::AngularVelocity_qt + (Index)AccessFunctionType::SuperElement: 
	//global angular velocity at mesh position derivative w.r.t. all q_t: with reference frame: 
	//[0, A * Glocal, A*(0,...,0, w0*pRefTilde0*nodeJac0, 0,..., 0, w1*pRefTilde1*nodeJac1, ...)]
	{
		CHECKandTHROW(weightingMatrix.NumberOfColumns() == 1, "CObjectFFRFreducedOrder::GetAccessFunctionSuperElement: AccessFunctionType::AngularVelocity_qt, weightingMatrix must have 1 row!");

		const CNodeRigidBody* cNode = (const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber);
		Index nODE2rigid = cNode->GetNumberOfODE2Coordinates();
		const Matrix& modeBasis = parameters.modeBasis;
		Index nModes = modeBasis.NumberOfColumns();

		value.SetNumberOfRowsAndColumns(nDim3D, GetODE2Size());
		value.SetAll(0.);

		//++++++++++++++++++++++++++++++++++++++
		//compute global factor
		Real factor = 0; //sum w_i * |pRef_i|^2
		Matrix3D factorMatrix(3,3,0.);  //W in docu
		Vector3D pRef; //mesh node local reference position

		Vector3D pRef0(0);			 //this is the midpoint of the Marker, computed from reference positions

		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			pRef0 += weightingMatrix(i, 0) * GetMeshNodeLocalPosition(meshNodeNumbers[i], ConfigurationType::Reference);
		}

		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			pRef = GetMeshNodeLocalPosition(meshNodeNumbers[i], ConfigurationType::Reference) - pRef0;
			if (useAlternativeApproach)
			{
				factorMatrix -= weightingMatrix(i, 0) * RigidBodyMath::Vector2SkewMatrix(pRef) * RigidBodyMath::Vector2SkewMatrix(pRef); //negative sign!
			}
			else
			{
				factor += weightingMatrix(i, 0) * pRef.GetL2NormSquared();
			}
		}

		if (useAlternativeApproach)
		{
			factorMatrix = factorMatrix.GetInverse();
		}
		else
		{
			factor = 1. / factor; //factor is now inverted
		}

		//++++++++++++++++++++++++++++++++++++++
		//add action for flexible part:
		Matrix3D A;
		A = ((const CNodeODE2*)(GetCNode(rigidBodyNodeNumber)))->GetRotationMatrix();

		for (Index i = 0; i < meshNodeNumbers.NumberOfItems(); i++)
		{
			//assume that the first 3 coordinates of the node are the displacement coordinates!!!
			pRef = GetMeshNodeLocalPosition(meshNodeNumbers[i], ConfigurationType::Reference) - pRef0;
			//Matrix3D jac = A * RigidBodyMath::Vector2SkewMatrix(pRef);  //A must be multiplied from left!
			Matrix3D jac = RigidBodyMath::Vector2SkewMatrix(pRef);
			if (useAlternativeApproach)
			{
				jac = weightingMatrix(i, 0) * A * factorMatrix * jac;
			}
			else
			{
				jac = factor * weightingMatrix(i, 0) * A * jac;
			}
			//pout << "jac" << meshNodeNumbers[i] << "=" << jac << "\n";

			Index offset = meshNodeNumbers[i] * 3;
			for (Index j = 0; j < 3; j++)
			{
				for (Index k = 0; k < 3; k++)
				{
					for (Index m = 0; m < nModes; m++)
					{
						value(j, nODE2rigid + m) += jac(j, k) * parameters.modeBasis(offset + k, m);
					}
				}
			}
		}

		//++++++++++++++++++++++++++++++++++++++
		//add action for REFERENCE FRAME NODE:
		//\partial omegaMarker / \partial q_t = [0, A * Glocal, ...)]

		ConstSizeMatrix<CNodeRigidBody::maxRotationCoordinates*CNodeRigidBody::nDim3D> Glocal;

		cNode->GetGlocal(Glocal);
		EXUmath::ApplyTransformation33(A, Glocal); //G, because d(omega)/d(qRot) = G

		value.SetSubmatrix(Glocal, 0, CNodeRigidBody::maxDisplacementCoordinates);
		//pout << "value=" << value << "\n";
		break;
	}
	default:
		CHECKandTHROWstring("CObjectFFRFreducedOrder:GetAccessFunctionSuperElement illegal accessType");
	}
}

//! get extended output variable types for multi-nodal objects with mesh nodes
OutputVariableType CObjectFFRFreducedOrder::GetOutputVariableTypesSuperElement(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetOutputVariableSuperElement: meshNodeNumber out of range ");
	//independent of meshNodeNumber!!!
	OutputVariableType ovt = (OutputVariableType)(
		(Index)OutputVariableType::Position +
		(Index)OutputVariableType::Displacement +
		(Index)OutputVariableType::Velocity +
		(Index)OutputVariableType::Acceleration +
		(Index)OutputVariableType::DisplacementLocal +
		(Index)OutputVariableType::VelocityLocal);
	if (parameters.outputVariableTypeModeBasis == OutputVariableType::StressLocal) 
	{
		ovt = (OutputVariableType)((Index)ovt + (Index)OutputVariableType::StressLocal);
	}
	else if (parameters.outputVariableTypeModeBasis == OutputVariableType::StrainLocal)
	{
		ovt = (OutputVariableType)((Index)ovt + (Index)OutputVariableType::StrainLocal);
	}

	return ovt;
}

//! get extended output variables for multi-nodal objects with mesh nodes
void CObjectFFRFreducedOrder::GetOutputVariableSuperElement(OutputVariableType variableType, Index meshNodeNumber, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration));	break;
	case OutputVariableType::Displacement:	value.CopyFrom(GetMeshNodePosition(meshNodeNumber, configuration) - GetMeshNodePosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::Velocity:	value.CopyFrom(GetMeshNodeVelocity(meshNodeNumber, configuration));	break;
	case OutputVariableType::Acceleration:	value.CopyFrom(GetMeshNodeAcceleration(meshNodeNumber, configuration));	break;

	case OutputVariableType::DisplacementLocal:	value.CopyFrom(GetMeshNodeLocalPosition(meshNodeNumber, configuration) - GetMeshNodeLocalPosition(meshNodeNumber, ConfigurationType::Reference));	break;
	case OutputVariableType::VelocityLocal:	value.CopyFrom(GetMeshNodeLocalVelocity(meshNodeNumber, configuration));	break;
	case OutputVariableType::StressLocal:
	{
		value.SetNumberOfItems(6);
		value.SetAll(0);
		const Matrix& PsiS = parameters.outputVariableModeBasis;

		//stresses are based on modal displacements only
		LinkedDataVector coordinates = ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector(configuration);

		Index nModes = parameters.modeBasis.NumberOfColumns();

		for (Index i = 0; i < 6; i++) //stress component
		{
			for (Index j = 0; j < nModes; j++) //iteration over all modes / modal coordinates
			{
				value[i] += PsiS(meshNodeNumber, j * 6 + i) * coordinates[j];
			}
		}
		break;
	}
	case OutputVariableType::StrainLocal:
	{
		value.SetNumberOfItems(6);
		value.SetAll(0);
		const Matrix& PsiS = parameters.outputVariableModeBasis;

		//stresses are based on modal displacements only
		LinkedDataVector coordinates = ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector(configuration);

		Index nModes = parameters.modeBasis.NumberOfColumns();

		for (Index i = 0; i < 6; i++) //strain component
		{
			for (Index j = 0; j < nModes; j++) //iteration over all modes / modal coordinates
			{
				value[i] += PsiS(meshNodeNumber, j*6+i) * coordinates[j];
			}
		}
		break;
	}
	default:
		SysError("CObjectFFRFreducedOrder::GetOutputVariableSuperElement failed"); //error should not occur, because types are checked!
	}

}

//! return the mesh node pointer; for consistency checks
CNodeODE2* CObjectFFRFreducedOrder::GetMeshNode(Index meshNodeNumber) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNode: meshNodeNumber out of range");

	return nullptr; //there is no meshnode, its only virtual ...
}

//! return the (local) position of a mesh node according to configuration type; use Configuration.Reference to access the mesh reference position; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeLocalPosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeLocalPosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	if (configuration == ConfigurationType::Reference) {
		return Vector3D({ parameters.referencePositions[meshNodeNumber * 3],
			parameters.referencePositions[meshNodeNumber * 3 + 1],
			parameters.referencePositions[meshNodeNumber * 3 + 2] });
		//note that GetCoordinateVector(ConfigurationType::Reference) is all zero, guaranteed by checkPReAssembleConsistencies()
	}
	else
	{
		return GetMeshNodeCoordinates(meshNodeNumber, ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector(configuration))
		+ Vector3D({ parameters.referencePositions[meshNodeNumber * 3],
			parameters.referencePositions[meshNodeNumber * 3 + 1],
			parameters.referencePositions[meshNodeNumber * 3 + 2] });
	}
}

//! return the (local) velocity of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeLocalVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeLocalVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	return GetMeshNodeCoordinates(meshNodeNumber, ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector_t(configuration));
}

//! return the (local) acceleration of a mesh node according to configuration type; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeLocalAcceleration(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeLocalAcceleration: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	return GetMeshNodeCoordinates(meshNodeNumber, ((CNodeODE2*)GetCNode(genericNodeNumber))->GetCoordinateVector_tt(configuration));
}

//! return the (global) position of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodePosition(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodePosition: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	Matrix3D refRot = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D refPos = ((const CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetPosition(configuration);

	return refPos + refRot * GetMeshNodeLocalPosition(meshNodeNumber, configuration); //no "+1", because it is already the mesh function
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeVelocity(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeVelocity: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRFreducedOrder)");

	// \dot R + A * \localOmega x \localPosition
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetVelocity(configuration) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) *
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocityLocal(configuration).CrossProduct(GetMeshNodeLocalPosition(meshNodeNumber, configuration)) +
		((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration) * GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
}

//! return the (global) velocity of a mesh node according to configuration type; this is the node position transformed by the motion of the reference frame; meshNodeNumber is the local node number of the (underlying) mesh
Vector3D CObjectFFRFreducedOrder::GetMeshNodeAcceleration(Index meshNodeNumber, ConfigurationType configuration) const
{
	CHECKandTHROW(meshNodeNumber < GetNumberOfMeshNodes(), "CObjectFFRFreducedOrder::GetMeshNodeAcceleration: meshNodeNumber out of range (mesh node 0 is node 1 in ObjectFFRF)");

	Matrix3D A = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetRotationMatrix(configuration);
	Vector3D xloc = GetMeshNodeLocalPosition(meshNodeNumber, configuration);
	Vector3D xglob = A * xloc;
	Vector3D vloc = GetMeshNodeLocalVelocity(meshNodeNumber, configuration);
	Vector3D aloc = GetMeshNodeLocalAcceleration(meshNodeNumber, configuration);
	Vector3D vglob = A * vloc;
	Vector3D omega = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularVelocity(configuration);
	Vector3D alpha = ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAngularAcceleration(configuration);

	// \ddot R + A * \ddot xloc + 2*omega x vglob + alpha x xglob + omega x omega x xglob
	return ((CNodeRigidBody*)GetCNode(rigidBodyNodeNumber))->GetAcceleration(configuration) +
		A * aloc + 2 * omega.CrossProduct(vglob) + alpha.CrossProduct(xglob) + omega.CrossProduct(omega.CrossProduct(xglob));
}






