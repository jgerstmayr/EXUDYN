/** ***********************************************************************************************
* @brief		Implementation for NodePoint2DSlope1
*
* @author		Gerstmayr Johannes
* @date			2019-06-15 (generated)
* @pre			...
*
* @copyright    This file is part of Exudyn. Exudyn is free software: you can redistribute it and/or modify it under the terms of the Exudyn license. See 'LICENSE.txt' for more details.
* @note			Bug reports, support and further information:
* 				- email: johannes.gerstmayr@uibk.ac.at
* 				- weblink: missing
* 				
*
* *** Example code ***
*
************************************************************************************************ */

#include "Main/CSystemData.h"
#include "Autogenerated/CNodePoint2DSlope1.h"				//includes ReleaseAssert.h, BasicDefinitions.h, ResizeableArray.h, LinkedDataVector.h

//for CallFunction(...)
#include "Main/MainSystem.h"
#include "Pymodules/PybindUtilities.h"
#include "Autogenerated/MainNodePoint2DSlope1.h"


Vector3D CNodePoint2DSlope1::GetPosition(ConfigurationType configuration) const
{
	//p = pRef + u = reference position + displacement
	LinkedDataVector pRef2D = GetReferenceCoordinateVector();
	Vector3D pRef({ pRef2D[0], pRef2D[1], 0. });
	if (configuration == ConfigurationType::Reference) { return pRef; }

	LinkedDataVector u2D = GetCoordinateVector(configuration);
	Vector3D displacement({ u2D[0], u2D[1], 0. });
	return pRef + displacement;
}

Vector3D CNodePoint2DSlope1::GetVelocity(ConfigurationType configuration) const
{
	LinkedDataVector u2D_t = GetCoordinateVector_t(configuration);
	return Vector3D({ u2D_t[0], u2D_t[1], 0. });
}

//! AUTO:  provide position jacobian of node; derivative of 3D Position with respect to 4 coordinates ux,uy and x/y "displacements" of slopex
void CNodePoint2DSlope1::GetPositionJacobian(Matrix& value) const
{
	//derivative of position with respect to all coordinates
	value.SetMatrix(3, 4, {1.,0.,0.,0., 0.,1.,0.,0., 0.,0.,0.,0.});
}

Matrix3D CNodePoint2DSlope1::GetRotationMatrix(ConfigurationType configuration) const
{
	//slope vector = pRef' + u'
	LinkedDataVector vRef = GetCoordinateVector(ConfigurationType::Reference);
	Real phi;
	if (!(configuration == ConfigurationType::Reference))
	{
		LinkedDataVector v = GetCoordinateVector(configuration);
		phi = atan2(vRef[3] + v[3], vRef[2] + v[2]); //slope vector [1,0] is defined as zero angle
	}
	else
	{ //Reference configuration:
		phi = atan2(vRef[3], vRef[2]); //slope vector [0,1] is defined as zero angle
	}
	//phi is the total angle
	return Matrix3D(3,3,{ cos(phi),-sin(phi),0.,  sin(phi),cos(phi),0., 0.,0.,1.});
}

//! AUTO:  return configuration dependent velocity of node; returns always a 3D Vector
Vector3D CNodePoint2DSlope1::GetAngularVelocity(ConfigurationType configuration) const
{
	//atan2(y,x) = atan(y/x)
	//diff(atan2(y,x),x) = -y/(x^2+y^2)
	//diff(atan2(y,x),y) =  x/(x^2+y^2)
	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	LinkedDataVector u = GetCoordinateVector(configuration);
	LinkedDataVector u_t = GetCoordinateVector_t(configuration);

	Real x = u[2]; //x-slopex
	Real y = u[3]; //y-slopex
	if (configuration != ConfigurationType::Reference)
	{
		x += ref[2];
		y += ref[3];
	}
	//SysError("CNodePoint2DSlope1::GetAngularVelocity: check if computation of angular velocity is correct!");
	//Real diffX = -y / (x*x + y * y)*u_t[2];
	//Real diffY =  x / (x*x + y * y)*u_t[3];
	//return Vector3D({ 0., 0., atan2(diffY,diffX) }); //rotation ignored

	return Vector3D({ 0., 0., (-y*u_t[2] + x*u_t[3]) / (x*x + y*y) }); 
}

void CNodePoint2DSlope1::GetRotationJacobian(Matrix& value) const
{
	//only in current configuration!
	LinkedDataVector ref = GetCoordinateVector(ConfigurationType::Reference);
	LinkedDataVector u = GetCurrentCoordinateVector();

	Real x = u[2] + ref[2]; //x-slopex
	Real y = u[3] + ref[3]; //y-slopex

	value.SetMatrix(3, 4, { 0.,0.,0.,0., 0.,0.,0.,0., 0.,0.,-y / (x*x + y*y), x / (x*x + y*y) });
}

//! provide according output variable in "value"
void CNodePoint2DSlope1::GetOutputVariable(OutputVariableType variableType, ConfigurationType configuration, Vector& value) const
{
	switch (variableType)
	{
	case OutputVariableType::Position: value.CopyFrom(GetPosition(configuration)); break;
	case OutputVariableType::Displacement: value.CopyFrom(GetPosition(configuration) - GetPosition(ConfigurationType::Reference)); break;
	case OutputVariableType::Velocity: value.CopyFrom(GetVelocity(configuration)); break;
	case OutputVariableType::Coordinates:
	{
		if (IsConfigurationInitialCurrentReferenceVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Reference + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector(configuration);
		}
		else
		{
			PyError("CNodePoint2DSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	case OutputVariableType::Coordinates_t:
	{
		if (IsConfigurationInitialCurrentVisualization(configuration)) //((Index)configuration & ((Index)ConfigurationType::Current + (Index)ConfigurationType::Initial + (Index)ConfigurationType::Visualization))
		{
			value = GetCoordinateVector_t(configuration);
		}
		else
		{
			PyError("CNodePoint2DSlope1::GetOutputVariable: invalid configuration");
		}
		break;
	}
	default:
		SysError("CNodePoint2DSlope1::GetOutputVariable failed"); //error should not occur, because types are checked!
	}
}



//! call a certain function of object (autogenerated in future!)
py::object MainNodePoint2DSlope1::CallFunction(STDstring functionName, py::dict args) const
{
	//these calls should be automated by python script ...
	if (functionName == "GetTypeName")
	{
		return py::str(GetTypeName());
	}
	else if (functionName == "GetNodeType")
	{
		return py::cast(GetCNodePoint2DSlope1()->GetType());
	}
	else if (functionName == "GetNodeGroup")
	{
		return py::cast(GetCNodePoint2DSlope1()->GetNodeGroup());
	}
	else if (functionName == "GetNumberOfODE2Coordinates")
	{
		return py::int_(GetCNodePoint2DSlope1()->GetNumberOfODE2Coordinates());
	}
	else if (functionName == "GetGlobalODE2CoordinateIndex")
	{
		return py::int_(GetCNodePoint2DSlope1()->GetGlobalODE2CoordinateIndex());
	}
	else if (functionName == "GetCurrentCoordinateVector")
	{
		LinkedDataVector v(GetCNodePoint2DSlope1()->GetCurrentCoordinateVector());
		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	}
	else if (functionName == "GetInitialCoordinateVector")
	{
		LinkedDataVector v(GetCNodePoint2DSlope1()->GetInitialCoordinateVector());
		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	}
	else if (functionName == "GetCurrentCoordinateVector_t")
	{
		LinkedDataVector v(GetCNodePoint2DSlope1()->GetCurrentCoordinateVector_t());
		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	}
	else if (functionName == "GetInitialCoordinateVector_t")
	{
		LinkedDataVector v(GetCNodePoint2DSlope1()->GetInitialCoordinateVector_t());
		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	}
	else if (functionName == "GetCurrentPosition")
	{
		Vector3D v = GetCNodePoint2DSlope1()->GetPosition(ConfigurationType::Current);
		return py::array_t<Real>(v.NumberOfItems(), v.GetDataPointer());
	}
	//before doing so, use : https://pybind11.readthedocs.io/en/master/advanced/pycpp/numpy.html?highlight=numpy#f
	// and matrix example : https://github.com/pybind/pybind11/blob/master/tests/test_buffers.cpp
	//else if (functionName == "GetCurrentRotationMatrix")
	//{
	//	Matrix3D m = GetCNodeRigidBody2D()->GetRotationMatrix(ConfigurationType::Current);
	//	return py::array_t<Real>(m.NumberOfItems(), m.GetDataPointer());
	//}

	PyError(STDstring("MainNodePoint2DSlope1::CallFunction called with invalid functionName '" + functionName + "'"));
	return py::int_(EXUstd::InvalidIndex);
}
