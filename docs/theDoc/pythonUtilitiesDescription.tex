% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++% description of python utility functions; generated by Johannes Gerstmayr% ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

\mysubsection{Module: basicUtilities}
\noindent {def {\bf DiagonalMatrix}}({\it rowsColumns}, {\it value}=1)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: create a diagonal or identity matrix; used for interface.py, avoiding the need for numpy  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it rowsColumns}: provides the number of rows and columns
    \item[] {\it        value}: initialization value for diagonal terms
  \ei
  \item[--]  {\bf output}: list of lists representing a matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf NormL2}}({\it vector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute L2 norm for vectors without switching to numpy or math module  \item[--]  {\bf input}: vector as list or in numpy format  \item[--]  {\bf output}: L2-norm of vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf VSum}}({\it vector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute sum of all values of vector  \item[--]  {\bf input}: vector as list or in numpy format  \item[--]  {\bf output}: sum of all components of vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf VAdd}}({\it v0}, {\it v1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: add two vectors instead using numpy  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: component-wise sum of v0 and v1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf VSub}}({\it v0}, {\it v1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: subtract two vectors instead using numpy: result = v0-v1  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: component-wise difference of v0 and v1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf VMult}}({\it v0}, {\it v1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: scalar multiplication of two vectors instead using numpy: result = v0'*v1  \item[--]  {\bf input}: vectors v0 and v1 as list or in numpy format  \item[--]  {\bf output}: sum of all component wise products: c0[0]*v1[0] + v0[1]*v1[0] + ...\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ScalarMult}}({\it scalar}, {\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: multiplication vectors with scalar: result = s*v  \item[--]  {\bf input}: value {\it scalar} and vector {\it v} as list or in numpy format  \item[--]  {\bf output}: scalar multiplication of all components of v: [scalar*v[0], scalar*v[1], ...]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Normalize}}({\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: take a 3D vector and return a normalized 3D vector (L2Norm=1)  \item[--]  {\bf input}: vector v as list or in numpy format  \item[--]  {\bf output}: vector v multiplied with scalar such that L2-norm of vector is 1\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Vec2Tilde}}({\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: apply tilde operator (skew) to 3D-vector and return skew matrix  \item[--]  {\bf input}: 3D vector v as list or in numpy format  \item[--]  {\bf output}: matrix as list of lists containing the skew-symmetric matrix computed from v: $\mr{0}{-v[2]}{v[1]} {v[2]}{0}{-v[0]} {-v[1]}{v[0]}{0}$\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Tilde2Vec}}({\it m})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: take skew symmetric matrix and return vector (inverse of Skew(...))  \item[--]  {\bf input}: list of lists containing a skew-symmetric matrix (3x3)  \item[--]  {\bf output}: list containing the vector v (inverse function of Vec2Tilde(...))\vspace{12pt}\end{itemize}
%
\mysubsection{Module: utilities}
\noindent {def {\bf PlotLineCode}}({\it index})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper functions for matplotlib, returns a list of 28 line codes to be used in plot, e.g. 'r-' for red solid line  \item[--]  {\bf input}: index in range(0:28)  \item[--]  {\bf output}: a color and line style code for matplotlib plot\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf FillInSubMatrix}}({\it subMatrix}, {\it destinationMatrix}, {\it destRow}, {\it destColumn})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: fill submatrix into given destinationMatrix; all matrices must be numpy arrays  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it subMatrix}: input matrix, which is filled into destinationMatrix
    \item[] {\it   destinationMatrix}: the subMatrix is entered here
    \item[] {\it   destRow}: row destination of subMatrix
    \item[] {\it   destColumn}: column destination of subMatrix
  \ei
  \item[--]  {\bf output}: destinationMatrix is changed after function call  \item[--]  {\bf notes}: may be erased in future!\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf SweepSin}}({\it t}, {\it t1}, {\it f0}, {\it f1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute sin sweep at given time t  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of sweep at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \ei
  \item[--]  {\bf output}: evaluation of sin sweep (in range -1..+1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf SweepCos}}({\it t}, {\it t1}, {\it f0}, {\it f1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute cos sweep at given time t  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of sweep at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \ei
  \item[--]  {\bf output}: evaluation of cos sweep (in range -1..+1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf FrequencySweep}}({\it t}, {\it t1}, {\it f0}, {\it f1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: frequency according to given sweep functions SweepSin, SweepCos  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it t}: evaluate of frequency at time t
    \item[] {\it   t1}: end time of sweep frequency range
    \item[] {\it   f0}: start of frequency interval [f0,f1] in Hz
    \item[] {\it   f1}: end of frequency interval [f0,f1] in Hz
  \ei
  \item[--]  {\bf output}: frequency in Hz\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RoundMatrix}}({\it matrix}, {\it treshold}=1e-14)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: set all entries in matrix to zero which are smaller than given treshold; operates directly on matrix  \item[--]  {\bf input}: matrix as np.array, treshold as positive value  \item[--]  {\bf output}: changes matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ComputeSkewMatrix}}({\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute (3 x 3*n) skew matrix from (3*n) vector; used for ObjectFFRF and CMS implementation  \item[--]  {\bf input}: a vector v in np.array format, containing 3*n components  \item[--]  {\bf output}: (3 x 3*n) skew matrix in np.array format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CheckInputVector}}({\it vector}, {\it length}=-1)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: check if input is list or array with according length; if length==-1, the length is not checked; raises Exception if the check fails  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it vector}: a vector in np.array or list format
    \item[] {\it   length}: desired length of vector; if length=-1, it is ignored
  \ei
  \item[--]  {\bf output}: None\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CheckInputIndexArray}}({\it indexArray}, {\it length}=-1)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: check if input is list or array with according length and positive indices; if length==-1, the length is not checked; raises Exception if the check fails  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it indexArray}: a vector in np.array or list format
    \item[] {\it   length}: desired length of vector; if length=-1, it is ignored
  \ei
  \item[--]  {\bf output}: None\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf LoadSolutionFile}}({\it fileName})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: read coordinates solution file (exported during static or dynamic simulation with option exu.SimulationSettings().solutionSettings.coordinatesSolutionFileName='...') into dictionary:  \item[--]  {\bf input}: fileName: string containing directory and filename of stored coordinatesSolutionFile  \item[--]  {\bf output}: dictionary with 'data': the matrix of stored solution vectors, 'columnsExported': a list with binary values showing the exported columns [nODE2, nVel2, nAcc2, nODE1, nVel1, nAlgebraic, nData],'nColumns': the number of data columns and 'nRows': the number of data rows\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf SetSolutionState}}({\it exu}, {\it mbs}, {\it solution}, {\it row}, {\it configuration})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: load selected row of solution dictionary (previously loaded with LoadSolutionFile) into specific state\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf SetVisualizationState}}({\it exu}, {\it mbs}, {\it solution}, {\it row})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: load selected row of solution dictionary into visualization state and redraw  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn library
    \item[] {\it   mbs}: the system, where the state is applied to
    \item[] {\it   solution}: solution dictionary previously loaded with LoadSolutionFile
    \item[] {\it   row}: the according row of the solution file which is visualized
  \ei
  \item[--]  {\bf output}: renders the scene in mbs and changes the visualization state in mbs\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf AnimateSolution}}({\it exu}, {\it SC}, {\it mbs}, {\it solution}, {\it rowIncrement}=1, {\it timeout}=0.04, {\it createImages}=False, {\it runLoop}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: consecutively load the rows of a solution file and visualize the result  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn library
    \item[] {\it   SC}: the system container, where the mbs lives in
    \item[] {\it   mbs}: the system used for animation
    \item[] {\it   solution}: solution dictionary previously loaded with LoadSolutionFile; will be played from first to last row
    \item[] {\it   rowIncrement}: can be set larger than 1 in order to skip solution frames: e.g. rowIncrement=10 visualizes every 10th row (frame)
    \item[] {\it   timeout}: in seconds is used between frames in order to limit the speed of animation; e.g. use timeout=0.04 to achieve approximately 25 frames per second
    \item[] {\it   createImages}: creates consecutively images from the animation, which can be converted into an animation
    \item[] {\it   runLoop}: if True, the animation is played in a loop until 'q' is pressed in render window
  \ei
  \item[--]  {\bf output}: renders the scene in mbs and changes the visualization state in mbs continuously\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf DrawSystemGraph}}({\it mbs}, {\it showLoads}=True, {\it showSensors}=True, {\it useItemNames}=False, {\it useItemTypes}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper function which draws system graph of a MainSystem (mbs); several options let adjust the appearance of the graph  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it showLoads}: toggle appearance of loads in mbs
    \item[] {\it    showSensors}: toggle appearance of sensors in mbs
    \item[] {\it    useItemNames}: if True, object names are shown instead of basic object types (Node, Load, ...)
    \item[] {\it    useItemTypes}: if True, object type names (ObjectMassPoint, ...) are shown instead of basic object types (Node, Load, ...)
  \ei
  \item[--]  {\bf output}: nothing\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GenerateStraightLineANCFCable2D}}({\it mbs}, {\it positionOfNode0}, {\it positionOfNode1}, {\it numberOfElements}, {\it cableTemplate}, {\it massProportionalLoad}=[0,0,0], {\it fixedConstraintsNode0}=[0,0,0,0], {\it fixedConstraintsNode1}=[0,0,0,0], {\it vALE}=0, {\it ConstrainAleCoordinate}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate cable elements along straight line with certain discretization  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: the system where ANCF cables are added
    \item[] {\it   positionOfNode0}: 3D position (list or np.array) for starting point of line
    \item[] {\it   positionOfNode1}: 3D position (list or np.array) for end point of line
    \item[] {\it   numberOfElements}: for discretization of line
    \item[] {\it   cableTemplate}: a ObjectANCFCable2D object, containing the desired cable properties; cable length and node numbers are set automatically
    \item[] {\it   massProportionalLoad}: a 3D list or np.array, containing the gravity vector or zero
    \item[] {\it   fixedConstraintsNode0}: a list of 4 binary values, indicating the coordinate contraints on the first node (x,y-position and x,y-slope)
    \item[] {\it   fixedConstraintsNode1}: a list of 4 binary values, indicating the coordinate contraints on the last node (x,y-position and x,y-slope)
    \item[] {\it   vALE}: used for ObjectALEANCFCable2D objects
  \ei
  \item[--]  {\bf output}: returns a list [cableNodeList, cableObjectList, loadList, cableNodePositionList, cableCoordinateConstraintList]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GenerateSlidingJoint}}({\it mbs}, {\it cableObjectList}, {\it markerBodyPositionOfSlidingBody}, {\it localMarkerIndexOfStartCable}=0, {\it slidingCoordinateStartPosition}=0)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate a sliding joint from a list of cables, marker to a sliding body, etc.\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GenerateAleSlidingJoint}}({\it mbs}, {\it cableObjectList}, {\it markerBodyPositionOfSlidingBody}, {\it AleNode}, {\it localMarkerIndexOfStartCable}=0, {\it AleSlidingOffset}=0, {\it activeConnector}=True, {\it penaltyStiffness}=0)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate an ALE sliding joint from a list of cables, marker to a sliding body, etc.\vspace{12pt}\end{itemize}
%
\mysubsection{Module: graphicsDataUtilities}
\noindent {def {\bf GraphicsDataRectangle}}({\it xMin}, {\it yMin}, {\it xMax}, {\it yMax}, {\it color}=[0.,0.,0.,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for 2D rectangle  \item[--]  {\bf input}: minimal and maximal cartesian coordinates in (x/y) plane; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataOrthoCubeLines}}({\it xMin}, {\it yMin}, {\it zMin}, {\it xMax}, {\it yMax}, {\it zMax}, {\it color}=[0.,0.,0.,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for orthogonal cube drawn with lines  \item[--]  {\bf input}: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataOrthoCube}}({\it xMin}, {\it yMin}, {\it zMin}, {\it xMax}, {\it yMax}, {\it zMax}, {\it color}=[0.,0.,0.,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for orthogonal 3D cube with min and max dimensions  \item[--]  {\bf input}: minimal and maximal cartesian coordinates for orthogonal cube; color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataOrthoCubePoint}}({\it centerPoint}, {\it size}, {\it color}=[0.,0.,0.,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data forfor orthogonal 3D cube with center point and size  \item[--]  {\bf input}: center point and size of cube (as 3D list or np.array); color provided as list of 4 RGBA values  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataCube}}({\it pList}, {\it color}=[0.,0.,0.,1.], {\it faces}=[1,1,1,1,1,1])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for general cube with endpoints, according to given vertex definition  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pList}: is a list of points [[x0,y0,z0],[x1,y11,z1],...]
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   faces}: includes the list of six binary values (0/1), denoting active faces (value=1); set index to zero to hide face
  \ei
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf SwitchTripletOrder}}({\it vector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: switch order of three items in a list; mostly used for reverting normals in triangles  \item[--]  {\bf input}: 3D vector as list or as np.array  \item[--]  {\bf output}: interchanged 2nd and 3rd component of list\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataSphere}}({\it point}, {\it radius}, {\it color}=[0.,0.,0.,1.], {\it nTiles}=8)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a sphere with point p and radius  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it point}: center of sphere (3D list or np.array)
    \item[] {\it   radius}: positive value
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of sphere >=3; use larger values for finer resolution
  \ei
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataCylinder}}({\it pAxis}, {\it vAxis}, {\it radius}, {\it color}=[0.,0.,0.,1.], {\it nTiles}=16, {\it angleRange}=[0,2*np.pi], {\it lastFace}=True, {\it cutPlain}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a cylinder with given axis, radius and color; nFaces gives the number of tiles (minimum=3)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it pAxis}: axis point of one face of cylinder (3D list or np.array)
    \item[] {\it   vAxis}: vector representing the cylinder's axis (3D list or np.array)
    \item[] {\it   radius}: positive value representing radius of cylinder
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of cylinder >=3; use larger values for finer resolution
    \item[] {\it   angleRange}: given in rad, to draw only part of cylinder (halfcylinder, etc.); for full range use [0..2 * pi]
    \item[] {\it   lastFace}: if angleRange != [0,2*pi], then the faces of the open cylinder are shown with lastFace = True
    \item[] {\it   cutPlain}: only used for angleRange != [0,2*pi]; if True, a plane is cut through the part of the cylinder; if False, the cylinder becomes a cake shape ...
  \ei
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataRigidLink}}({\it p0}, {\it p1}, {\it axis0}=[0,0,0], {\it axis1}=[0,0,0], {\it radius}=[0.1,0.1], {\it thickness}=0.05, {\it width}=[0.05,0.05], {\it color}=[0.,0.,0.,1.], {\it nTiles}=16)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data for a planar Link between the two joint positions, having two axes  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it p0}: joint0 center position
    \item[] {\it   p1}: joint1 center position
    \item[] {\it   axis0}: direction of rotation axis at p0, if drawn as a cylinder; [0,0,0] otherwise
    \item[] {\it   axis1}: direction of rotation axis of p1, if drawn as a cylinder; [0,0,0] otherwise
    \item[] {\it   radius}: list of two radii [radius0, radius1], being the two radii of the joints drawn by a cylinder or sphere
    \item[] {\it   width}: list of two widths [width0, width1], being the two widths of the joints drawn by a cylinder; ignored for sphere
    \item[] {\it   thickness}: the thickness of the link (shaft) between the two joint positions; thickness in z-direction or diameter (cylinder)
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   nTiles}: used to determine resolution of cylinder >=3; use larger values for finer resolution
  \ei
  \item[--]  {\bf output}: graphicsData dictionary, to be used in visualization of EXUDYN objects\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GraphicsDataFromSTLfileTxt}}({\it fileName}, {\it color}=[0.,0.,0.,1.], {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: generate graphics data from STL file (text format!) and use color for visualization  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it fileName}: string containing directory and filename of STL-file (in text / SCII format) to load
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] {\it   verbose}: if True, useful information is provided during reading
  \ei
  \item[--]  {\bf output}: interchanged 2nd and 3rd component of list\vspace{12pt}\end{itemize}
%
\mysubsection{Module: rigidBodyUtilities}
\noindent {def {\bf ComputeOrthonormalBasis}}({\it vector0})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute orthogonal basis vectors (normal1, normal2) for given vector0 (non-unique solution!); if vector0 == [0,0,0], then any normal basis is returned\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GramSchmidt}}({\it vector0}, {\it vector1})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute Gram-Schmidt projection of given 3D vector 1 on vector 0 and return normalized triad (vector0, vector1, vector0 x vector1)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Skew}}({\it vector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute skew symmetric 3x3-matrix from 3x1- or 1x3-vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Skew2Vec}}({\it skew})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] convert skew symmetric matrix m to vector
    \item[] {\it def Skew2Vec(m)}:
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ComputeSkewMatrix}}({\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute (3 x 3*n) skew matrix from (3*n) vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf EulerParameters2G}}({\it eulerParameters})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert Euler parameters (ep) to G-matrix (=$\partial \tomega  / \partial \pv_t$)  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x4 matrix G as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf EulerParameters2GLocal}}({\it eulerParameters})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert Euler parameters (ep) to local G-matrix (=$\partial \LU{b}{\tomega} / \partial \pv_t$)  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x4 matrix G as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf EulerParameters2RotationMatrix}}({\it eulerParameters})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix from eulerParameters  \item[--]  {\bf input}: vector of 4 eulerParameters as list or np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrix2EulerParameters}}({\it rotationMatrix})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute Euler parameters from given rotation matrix  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or as np.array  \item[--]  {\bf output}: vector of 4 eulerParameters as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf AngularVelocity2EulerParameters\_t}}({\it angularVelocity}, {\it eulerParameters})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute time derivative of Euler parameters from (global) angular velocity vector
    \item[] note that for Euler parameters $\pv$, we have $\tomega=\Gm \pv_t$ ==> $\Gm^T \tomega = \Gm^T\cdot \Gm\cdot \pv_t$ ==> $\Gm^T \Gm=4(\Im_{4x4} - \pv\cdot \pv^T)\pv_t = 4 (\Im_{4x4}) \pv_t$
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it angularVelocity}: 3D vector of angular velocity in global frame, as lists or as np.array
    \item[] {\it   eulerParameters}: vector of 4 eulerParameters as np.array or list
  \ei
  \item[--]  {\bf output}: vector of time derivatives of 4 eulerParameters as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationVector2RotationMatrix}}({\it rotationVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: rotaton matrix from rotation vector, see appendix B in \cite{Simo1988}  \item[--]  {\bf input}: 3D rotation vector as list or np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrix2RotationVector}}({\it rotationMatrix})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation vector from rotation matrix  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or as np.array  \item[--]  {\bf output}: vector of 3 components of rotation vector as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ComputeRotationAxisFromRotationVector}}({\it rotationVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation axis from given rotation vector  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3D vector as np.array representing the rotation axis\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotXYZ2RotationMatrix}}({\it rot})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix from consecutive xyz rotations (Tait-Bryan angles); A=Ax*Ay*Az; rot=[rotX, rotY, rotZ]  \item[--]  {\bf input}: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrix2RotXYZ}}({\it rotationMatrix})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert rotation matrix to xyz Euler angles (Tait-Bryan angles);  A=Ax*Ay*Az;  \item[--]  {\bf input}: 3x3 rotation matrix as list of lists or np.array  \item[--]  {\bf output}: vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf AngularVelocity2RotXYZ\_t}}({\it angularVelocity}, {\it rotation})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute time derivatives of angles RotXYZ from (global) angular velocity vector and given rotation  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it angularVelocity}: global angular velocity vector as list or np.array
    \item[] {\it   rotation}: 3D vector of Tait-Bryan rotation parameters [X,Y,Z] in radiant
  \ei
  \item[--]  {\bf output}: time derivative of vector of Tait-Bryan rotation parameters [X,Y,Z] (in radiant) as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotXYZ2EulerParameters}}({\it alpha})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute four Euler parameters from given RotXYZ angles, see \cite{Henderson1977}  \item[--]  {\bf input}: alpha: 3D vector as np.array containing RotXYZ angles  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] 4D vector as np.array containing four Euler parameters
    \item[]           entry zero of output represent the scalar part of Euler parameters
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrixX}}({\it angleRad})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. X-axis (first axis)  \item[--]  {\bf input}: angle around X-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrixY}}({\it angleRad})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. Y-axis (second axis)  \item[--]  {\bf input}: angle around Y-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf RotationMatrixZ}}({\it angleRad})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rotation matrix w.r.t. Z-axis (third axis)  \item[--]  {\bf input}: angle around Z-axis in radiant  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HomogeneousTransformation}}({\it A}, {\it r})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute homogeneous transformation matrix from rotation matrix A and translation vector r\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HTtranslate}}({\it r})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for translation with vector r\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HT0}}({\it })
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: identity homogeneous transformation:\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HTrotateX}}({\it angle})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HTrotateY}}({\it angle})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HTrotateZ}}({\it angle})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: homogeneous transformation for rotation around axis X (first axis)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HT2translation}}({\it T})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return translation part of homogeneous transformation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf HT2rotationMatrix}}({\it T})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return rotation matrix of homogeneous transformation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf InverseHT}}({\it T})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: return inverse homogeneous transformation such that inv(T)*T = np.eye(4)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf AddRigidBody}}({\it mainSys}, {\it inertia}, {\it nodeType}, {\it position}=[0,0,0], {\it velocity}=[0,0,0], {\it rotationMatrix}=[], {\it rotationParameters}=[], {\it angularVelocity}=[0,0,0], {\it gravity}=[0,0,0], {\it graphicsDataList}=[])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] adds a node (with str(exu.NodeType. ...)) and body for a given rigid body
    \item[] either the initial rotation is given by the rotationMatrix (while rotationParameters=[]) or by rotationParameters (while rotationMatrix=[]) (non empty)
    \item[] position ... initial position, etc.
    \item[] all quantities (esp. velocity and angular velocity) are given in global coordinates!
    \item[] returns node number and body number
    \item[] adds gravity force, i.e., m*gravity
  \ei
\vspace{12pt}\end{itemize}
%
\mysubsection{Module: lieGroupBasics}
\noindent {def {\bf Sinc}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the cardinal sine function in radians  \item[--]  {\bf input}: scalar float or int value  \item[--]  {\bf output}: float value in radians\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf Cot}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the cotangent function cot(x)=1/tan(x) in radians  \item[--]  {\bf input}: scalar float or int value  \item[--]  {\bf output}: float value in radians\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf R3xSO3Matrix2RotationMatrix}}({\it G})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: computes 3x3 rotation matrix from 7x7 R3xSO(3) matrix, see \cite{Bruels2011}  \item[--]  {\bf input}: G: 7x7 matrix as np.array  \item[--]  {\bf output}: 3x3 rotation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf R3xSO3Matrix2Translation}}({\it G})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: computes translation part of R3xSO(3) matrix, see \cite{Bruels2011}  \item[--]  {\bf input}: G: 7x7 matrix as np.array  \item[--]  {\bf output}: 3D vector as np.array containg translational part of R3xSO(3)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf R3xSO3Matrix}}({\it x}, {\it R})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: builds 7x7 matrix as element of the Lie group R3xSO(3), see \cite{Bruels2011}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it x}: 3D vector as np.array representing the translation part corresponding to R3
    \item[] {\it    R}: 3x3 rotation matrix as np.array
  \ei
  \item[--]  {\bf output}: 7x7 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ExpSO3}}({\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group SO(3), see \cite{Mueller2017}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ExpS3}}({\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the quaternion exponential map on the Lie group S(3), see \cite{Terze2016, Mueller2017}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] 4D vector as np.array containing four Euler parameters
    \item[]           entry zero of output represent the scalar part of Euler parameters
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf LogSO3}}({\it R})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix logarithmic map on the Lie group SO(3), see \cite{Sonneville2014, Sonneville2017}  \item[--]  {\bf input}: 3x3 rotation matrix as np.array  \item[--]  {\bf output}: 3x3 skew symmetric matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpSO3}}({\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpSO3, see \cite{Bruels2011}  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpSO3Inv}}({\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute the inverse of the tangent operator TExpSO3, see \cite{Sonneville2014}
    \item[]             this function was improved, see coordinateMaps.pdf by Stefan Holzinger
  \ei
  \item[--]  {\bf input}: 3D rotation vector as np.array  \item[--]  {\bf output}: 3x3 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ExpSE3}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group SE(3), see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 4x4 homogeneous transformation matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf LogSE3}}({\it H})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix logarithm on the Lie group SE(3), see \cite{Sonneville2014}  \item[--]  {\bf input}: 4x4 homogeneous transformation matrix as np.array  \item[--]  {\bf output}: 4x4 skew symmetric matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpSE3}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpSE3, see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpSE3Inv}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the inverse of tangent operator TExpSE3, see \cite{Sonneville2014}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ExpR3xSO3}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the matrix exponential map on the Lie group R3xSO(3), see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 7x7 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpR3xSO3}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the tangent operator corresponding to ExpR3xSO3, see \cite{Bruels2011}  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf TExpR3xSO3Inv}}({\it x})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute the inverse of tangent operator TExpR3xSO3  \item[--]  {\bf input}: 6D incremental motion vector as np.array  \item[--]  {\bf output}: 6x6 matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleDirectProductR3AndS3}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for pairs in the Lie group R3xS3  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 7D vector as np.array containing position coordinates and Euler parameters
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleSemiDirectProductR3AndS3}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for pairs in the Lie group R3 semiTimes S3 (corresponds to SE(3))  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 7D vector as np.array containing position coordinates and Euler parameters
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleDirectProductR3AndR3RotVec}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3, see \cite{Holzinger2020}
    \item[]             the rotation vector is used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and rotation vector
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 7D vector as np.array containing composed position coordinates and composed rotation vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleSemiDirectProductR3AndR3RotVec}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             the rotation vector is used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and rotation vector
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed rotation vector\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleDirectProductR3AndR3RotXYZAngles}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the global (inertial) frame
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleSemiDirectProductR3AndR3RotXYZAngles}}({\it q0}, {\it incrementalMotionVector})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for pairs in the group obtained from the direct product of R3 and R3.
    \item[]             Cardan-Tait/Bryan (CTB) angles are used as rotation parametrizations
    \item[]             this composition operation can be used in formulations which represent the translational velocities in the local (body-attached) frame
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q0}: 6D vector as np.array containing position coordinates and Cardan-Tait/Bryan angles
    \item[] {\it   incrementalMotionVector}: 6D incremental motion vector as np.array
  \ei
  \item[--]  {\bf output}: 6D vector as np.array containing composed position coordinates and composed Cardan-Tait/Bryan angles\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleForEulerParameters}}({\it q}, {\it p})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute composition operation for Euler parameters (unit quaternions)
    \item[]             this composition operation is quaternion multiplication, see \cite{Terze2016}
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it q}: 4D vector as np.array containing Euler parameters
    \item[] {\it   p}: 4D vector as np.array containing Euler parameters
  \ei
  \item[--]  {\bf output}: 4D vector as np.array containing composed (multiplied) Euler parameters\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleForRotationVectors}}({\it v0}, {\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for rotation vectors v0 and Omega, see \cite{Holzinger2021}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it v0}: 3D rotation vector as np.array
    \item[] {\it   Omega}: 3D (incremental) rotation vector as np.array
  \ei
  \item[--]  {\bf output}: 3D vector as np.array containing composed rotation vector v\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CompositionRuleRotXYZAnglesRotationVector}}({\it alpha0}, {\it Omega})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute composition operation for RotXYZ angles, see \cite{Holzinger2021}  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it alpha0}: 3D vector as np.array containing RotXYZ angles
    \item[] {\it   Omega}:  3D vector as np.array containing the (incremental) rotation vector
  \ei
  \item[--]  {\bf output}: 3D vector as np.array containing composed RotXYZ angles\vspace{12pt}\end{itemize}
%
\mysubsection{Module: FEM}
\noindent {def {\bf CompressedRowSparseToDenseMatrix}}({\it sparseData})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert zero-based sparse matrix data to dense numpy matrix  \item[--]  {\bf input}: sparseData: format (per row): [row, column, value] ==> converted into dense format  \item[--]  {\bf output}: a dense matrix as np.array\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf MapSparseMatrixIndices}}({\it matrix}, {\it sorting})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: resort a sparse matrix (internal CSR format) with given sorting for rows and columns; changes matrix directly! used for ANSYS matrix import\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf VectorDiadicUnitMatrix3D}}({\it v})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute diadic product of vector v and a 3D unit matrix = diadic(v,I$_{3x3}$); used for ObjectFFRF and CMS implementation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CyclicCompareReversed}}({\it list1}, {\it list2})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compare cyclic two lists, reverse second list; return True, if any cyclic shifted lists are same, False otherwise\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf AddEntryToCompressedRowSparseArray}}({\it sparseData}, {\it row}, {\it column}, {\it value})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] add entry to compressedRowSparse matrix, avoiding duplicates
    \item[] value is either added to existing entry (avoid duplicates) or a new entry is appended
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CSRtoRowsAndColumns}}({\it sparseMatrixCSR})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute rows and columns of a compressed sparse matrix and return as tuple: (rows,columns)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf CSRtoScipySparseCSR}}({\it sparseMatrixCSR})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert internal compressed CSR to scipy.sparse csr matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ScipySparseCSRtoCSR}}({\it scipyCSR})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert scipy.sparse csr matrix to internal compressed CSR\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ResortIndicesOfCSRmatrix}}({\it mXXYYZZ}, {\it numberOfRows})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] resort indices of given CSR matrix in XXXYYYZZZ format to XYZXYZXYZ format; numberOfRows must be equal to columns
    \item[] needed for import from NGsolve
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ConvertHexToTrigs}}({\it nodeNumbers})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] convert list of Hex8/C3D8  element with 8 nodes in nodeNumbers into triangle-List
    \item[] also works for Hex20 elements, but does only take the corner nodes!
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ConvertDenseToCompressedRowMatrix}}({\it denseMatrix})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: convert numpy.array dense matrix to (internal) compressed row format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ReadMatrixFromAnsysMMF}}({\it fileName}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] This function reads either the mass or stiffness matrix from an Ansys
    \item[]            Matrix Market Format (MMF). The corresponding matrix can either be exported
    \item[]            as dense matrix or sparse matrix.
  \ei
  \item[--]  {\bf input}: fileName of MMF file  \item[--]  {\bf output}: internal compressed row sparse matrix (as (nrows x 3) numpy array)  \item[--]  {\bf author}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] Stefan Holzinger
    \item[] {\it  Note}:
    \item[]    A MMF file can be created in Ansys by placing the following APDL code inside
    \item[] {\it    the solution tree in Ansys Workbench}:
    \item[] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]    ! APDL code that exports sparse stiffnes and mass matrix in MMF format. If
    \item[]    ! the dense matrix is needed, replace *SMAT with *DMAT in the following
    \item[]    ! APDL code.
    \item[]    ! Export the stiffness matrix in MMF format
    \item[]    *SMAT,MatKD,D,IMPORT,FULL,file.full,STIFF
    \item[]    *EXPORT,MatKD,MMF,fileNameStiffnessMatrix,,,
    \item[]    ! Export the mass matrix in MMF format
    \item[]    *SMAT,MatMD,D,IMPORT,FULL,file.full,MASS
    \item[]    *EXPORT,MatMD,MMF,fileNameMassMatrix,,,
    \item[] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]  In case a lumped mass matrix is needed, place the following APDL Code inside
    \item[] {\it  the Modal Analysis Tree}:
    \item[] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[]  ! APDL code to force Ansys to use a lumped mass formulation (if available for
    \item[]  ! used elements)
    \item[]  LUMPM, ON, , 0
    \item[] !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
    \item[] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ReadMatrixDOFmappingVectorFromAnsysTxt}}({\it fileName})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] read sorting vector for ANSYS mass and stiffness matrices and return sorting vector as np.array
    \item[]   the file contains sorting for nodes and applies this sorting to the DOF (assuming 3 DOF per node!)
    \item[]   the resulting sorted vector is already converted to 0-based indices
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ReadNodalCoordinatesFromAnsysTxt}}({\it fileName}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: This function reads the nodal coordinates exported from Ansys.  \item[--]  {\bf input}: fileName (file name ending must be .txt!)  \item[--]  {\bf output}: nodal coordinates as numpy array  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The nodal coordinates can be exported from Ansys by creating a named selection
    \item[]    of the body whos mesh should to exported by choosing its geometry. Next,
    \item[]    create a second named selcetion by using a worksheet. Add the named selection
    \item[]    that was created first into the worksheet of the second named selection.
    \item[]    Inside the working sheet, choose 'convert' and convert the first created
    \item[]    named selection to 'mesh node' (Netzknoten in german) and click on generate
    \item[]    to create the second named selection. Next, right click on the second
    \item[]    named selection tha was created and choose 'export' and save the nodal
    \item[]    coordinates as .txt file.
    \item[] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ReadElementsFromAnsysTxt}}({\it fileName}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: This function reads the nodal coordinates exported from Ansys.  \item[--]  {\bf input}: fileName (file name ending must be .txt!)  \item[--]  {\bf output}: element connectivity as numpy array  \item[--]  {\bf author}: Stefan Holzinger  \item[--]  {\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The elements can be exported from Ansys by creating a named selection
    \item[]    of the body whos mesh should to exported by choosing its geometry. Next,
    \item[]    create a second named selcetion by using a worksheet. Add the named selection
    \item[]    that was created first into the worksheet of the second named selection.
    \item[]    Inside the worksheet, choose 'convert' and convert the first created
    \item[]    named selection to 'mesh element' (Netzelement in german) and click on generate
    \item[]    to create the second named selection. Next, right click on the second
    \item[]    named selection tha was created and choose 'export' and save the elements
    \item[]    as .txt file.
    \item[] ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
  \ei
\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS ObjectFFRFinterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  compute terms necessary for ObjectFFRF
class used internally in FEMinterface to compute ObjectFFRF object
this class holds all data for ObjectFFRF user functions
\vspace{9pt} \\ 
\noindent \textcolor{steelblue}{def {\bf \_\_init\_\_}}({\it self}, {\it femInterface})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] initialize ObjectFFRFinterface with FEMinterface class
    \item[]   initializes the ObjectFFRFinterface with nodes, modes, surface description and systemmatrices from FEMinterface
    \item[]   data is then transfered to mbs object with classFunction AddObjectFFRF(...)
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf AddObjectFFRF}}({\it self}, {\it exu}, {\it mbs}, {\it positionRef}=[0,0,0], {\it eulerParametersRef}=[1,0,0,0], {\it initialVelocity}=[0,0,0], {\it initialAngularVelocity}=[0,0,0], {\it gravity}=[0,0,0], {\it constrainRigidBodyMotion}=True, {\it massProportionalDamping}=0, {\it stiffnessProportionalDamping}=0, {\it color}=[0.1,0.9,0.1,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: add according nodes, objects and constraints for FFRF object to MainSystem mbs  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn module
    \item[] {\it   mbs}: a MainSystem object
    \item[] {\it   positionRef}: reference position of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   eulerParametersRef}: reference euler parameters of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   initialVelocity}: initial velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   initialAngularVelocity}: initial angular velocity of created ObjectFFRF (set in rigid body node underlying to ObjectFFRF)
    \item[] {\it   gravity}: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
    \item[] {\it   constrainRigidBodyMotion}: set True in order to add constraint (Tisserand frame) in order to suppress rigid motion of mesh nodes
    \item[] {\it   color}: provided as list of 4 RGBA values
    \item[] add object to mbs as well as according nodes
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf UFforce}}({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it q}, {\it q\_t})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: optional forceUserFunction for ObjectFFRF (per default, this user function is ignored)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf UFmassGenericODE2}}({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it q}, {\it q\_t})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: optional massMatrixUserFunction for ObjectFFRF (per default, this user function is ignored)\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS ObjectFFRFreducedOrderInterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  compute terms necessary for ObjectFFRFreducedOrder
  class used internally in FEMinterface to compute ObjectFFRFreducedOrder dictionary
  this class holds all data for ObjectFFRFreducedOrder user functions
\vspace{9pt} \\ 
\noindent \textcolor{steelblue}{def {\bf \_\_init\_\_}}({\it self}, {\it femInterface}, {\it roundMassMatrix}=1e-13, {\it roundStiffNessMatrix}=1e-13)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] initialize ObjectFFRFreducedOrderInterface with FEMinterface class
    \item[]   initializes the ObjectFFRFreducedOrderInterface with nodes, modes, surface description and reduced system matrices from FEMinterface
    \item[]   data is then transfered to mbs object with classFunction AddObjectFFRFreducedOrderWithUserFunctions(...)
  \ei
  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it femInterface}: must provide nodes, surfaceTriangles, modeBasis, massMatrix, stiffness
    \item[] {\it   roundMassMatrix}: use this value to set entries of reduced mass matrix to zero which are below the treshold
    \item[] {\it   roundStiffNessMatrix}: use this value to set entries of reduced stiffness matrix to zero which are below the treshold
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf AddObjectFFRFreducedOrderWithUserFunctions}}({\it self}, {\it exu}, {\it mbs}, {\it positionRef}=[0,0,0], {\it eulerParametersRef}=[1,0,0,0], {\it initialVelocity}=[0,0,0], {\it initialAngularVelocity}=[0,0,0], {\it gravity}=[0,0,0], {\it UFforce}=0, {\it UFmassMatrix}=0, {\it massProportionalDamping}=0, {\it stiffnessProportionalDamping}=0, {\it color}=[0.1,0.9,0.1,1.])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: add according nodes, objects and constraints for ObjectFFRFreducedOrder object to MainSystem mbs  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it exu}: the exudyn module
    \item[] {\it   mbs}: a MainSystem object
    \item[] {\it   positionRef}: reference position of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   eulerParametersRef}: reference euler parameters of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   initialVelocity}: initial velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   initialAngularVelocity}: initial angular velocity of created ObjectFFRFreducedOrder (set in rigid body node underlying to ObjectFFRFreducedOrder)
    \item[] {\it   gravity}: set [0,0,0] if no gravity shall be applied, or to the gravity vector otherwise
    \item[] {\it   UFforce}: provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFforceFFRFreducedOrder(t, qReduced, qReduced\_t):\\ \phantom{XXXX}return cms.UFforceFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
    \item[] {\it   UFmassMatrix}: provide a user function, which computes the quadratic velocity vector and applied forces; usually this function reads like:\\ \texttt{def UFmassFFRFreducedOrder(t, qReduced, qReduced\_t):\\  \phantom{XXXX}return cms.UFmassFFRFreducedOrder(exu, mbs, t, qReduced, qReduced\_t)}
    \item[] {\it   massProportionalDamping}: Rayleigh damping factor for mass proportional damping, added to floating frame/modal coordinates only
    \item[] {\it   stiffnessProportionalDamping}: Rayleigh damping factor for stiffness proportional damping, added to floating frame/modal coordinates only
    \item[] {\it   color}: provided as list of 4 RGBA values
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf UFmassFFRFreducedOrder}}({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it qReduced}, {\it qReduced\_t})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: CMS mass matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf UFforceFFRFreducedOrder}}({\it self}, {\it exu}, {\it mbs}, {\it t}, {\it qReduced}, {\it qReduced\_t})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: CMS force matrix user function; qReduced and qReduced\_t contain the coordiantes of the rigid body node and the modal coordinates in one vector!\vspace{12pt}\end{itemize}
%
\mysubsubsection{CLASS FEMinterface (in module FEM)}
\noindent\textcolor{steelblue}{{\bf class description}}:  general interface to different FEM / mesh imports and export to EXUDYN functions
         use this class to import meshes from different meshing or FEM programs (NETGEN/NGsolve, ABAQUS, ANSYS, ..) and store it in a unique format
         do mesh operations, compute eigenmodes and reduced basis, etc.
         load/store the data efficiently with LoadFromFile(...), SaveToFile(...)  if import functions are slow
         export to EXUDYN objects
\vspace{9pt} \\ 
\noindent \textcolor{steelblue}{def {\bf \_\_init\_\_}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: initalize all data of the FEMinterface by, e.g., \texttt{fem = FEMinterface()}\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf SaveToFile}}({\it self}, {\it fileName})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: save all data (nodes, elements, ...) to a data filename; this function is much faster than the text-based import functions  \item[--]  \textcolor{steelblue}{\bf input}: use filename without ending ==> ".npy" will be added\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf LoadFromFile}}({\it self}, {\it fileName})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] load all data (nodes, elements, ...) from a data filename previously stored with SaveToFile(...).
    \item[] this function is much faster than the text-based import functions
  \ei
  \item[--]  \textcolor{steelblue}{\bf input}: use filename without ending ==> ".npy" will be added\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ImportFromAbaqusInputFile}}({\it self}, {\it fileName}, {\it typeName}='Part', {\it name}='Part-1', {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] import nodes and elements from Abaqus input file and create surface elements
    \item[] node numbers in elements are converted from 1-based indices to python's 0-based indices
    \item[] only works for Hex8, Hex20, Tet4 and Tet10 (C3D4, C3D8, C3D10, C3D20) elements
    \item[] return node numbers as numpy array
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadMassMatrixFromAbaqus}}({\it self}, {\it fileName}, {\it type}='SparseRowColumnValue')
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it read mass matrix from compressed row text format (exported from Abaqus); in order to export system matrices, write the following lines in your Abaqus input file}:
    \item[] *STEP
    \item[] *MATRIX GENERATE, STIFFNESS, MASS
    \item[] *MATRIX OUTPUT, STIFFNESS, MASS, FORMAT=COORDINATE
    \item[] *End Step
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadStiffnessMatrixFromAbaqus}}({\it self}, {\it fileName}, {\it type}='SparseRowColumnValue')
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read stiffness matrix from compressed row text format (exported from Abaqus)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ImportMeshFromNGsolve}}({\it self}, {\it mesh}, {\it density}, {\it youngsModulus}, {\it poissonsRatio}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: import mesh from NETGEN/NGsolve and setup mechanical problem  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mesh}: a previously created \texttt{ngs.mesh} (NGsolve mesh, see examples)
    \item[] {\it     youngsModulus}: Young's modulus used for mechanical model
    \item[] {\it     poissonsRatio}: Poisson's ratio used for mechanical model
    \item[] {\it     density}: density used for mechanical model
    \item[] {\it     verbose}: set True to print out some status information
  \ei
  \item[--]  \textcolor{steelblue}{\bf notes}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] The interface to NETGEN/NGsolve has been created together with Joachim Schberl, main developer
    \item[]   of NETGEN/NGsolve; Thank's a lot!
    \item[] {\it   download NGsolve at}: https://ngsolve.org/
    \item[]   NGsolve needs Python 3.7 (64bit) ==> use according EXUDYN version!
    \item[]   note that node/element indices in the NGsolve mesh are 1-based and need to be converted to 0-base!
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetMassMatrix}}({\it self}, {\it sparse}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get sparse mass matrix in according format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetStiffnessMatrix}}({\it self}, {\it sparse}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get sparse stiffness matrix in according format\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf NumberOfNodes}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get total number of nodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetNodePositionsAsArray}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get node points as array; only possible, if there exists only one type of Position nodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf NumberOfCoordinates}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get number of total nodal coordinates\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetNodeAtPoint}}({\it self}, {\it point}, {\it tolerance}=1e-5, {\it raiseException}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node number for node at given point, e.g. p=[0.1,0.5,-0.2], using a tolerance (+/-) if coordinates are available only with reduced accuracy
    \item[] if not found, it returns an invalid index
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetNodesInPlane}}({\it self}, {\it point}, {\it normal}, {\it tolerance}=1e-5)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers in plane defined by point p and (normalized) normal vector n using a tolerance for the distance to the plane
    \item[] if not found, it returns an empty list
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetNodesOnCircle}}({\it self}, {\it point}, {\it normal}, {\it r}, {\it tolerance}=1e-5)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] get node numbers on a circle, by point p, (normalized) normal vector n (which is the axis of the circle) and radius r
    \item[] using a tolerance for the distance to the plane
    \item[] if not found, it returns an empty list
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetSurfaceTriangles}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: return surface trigs as node number list (for drawing in EXUDYN)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf VolumeToSurfaceElements}}({\it self}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] generate surface elements from volume elements
    \item[] stores the surface in self.surface
    \item[] only works for one element list and one type ('Hex8') of elements
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetGyroscopicMatrix}}({\it self}, {\it rotationAxis}=2, {\it sparse}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: get gyroscopic matrix in according format; rotationAxis=[0,1,2] = [x,y,z]\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ScaleMassMatrix}}({\it self}, {\it factor})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: scale (=multiply) mass matrix with factor\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ScaleStiffnessMatrix}}({\it self}, {\it factor})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: scale (=multiply) stiffness matrix with factor\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf AddElasticSupportAtNode}}({\it self}, {\it nodeNumber}, {\it springStiffness}=[1e8,1e8,1e8])
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] modify stiffness matrix to add elastic support (joint, etc.) to a node; nodeNumber zero based (as everywhere in the code...)
    \item[] springStiffness must have length according to the node size
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf AddNodeMass}}({\it self}, {\it nodeNumber}, {\it addedMass})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: modify mass matrix by adding a mass to a certain node, modifying directly the mass matrix\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ComputeEigenmodes}}({\it self}, {\it nModes}, {\it excludeRigidBodyModes}=0, {\it useSparseSolver}=True)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute nModes smallest eigenvalues and eigenmodes from mass and stiffnessMatrix
    \item[] store mode vector in modeBasis, but exclude a number of 'excludeRigidBodyModes' rigid body modes from modeBasis
    \item[] if excludeRigidBodyModes > 0, then the computed modes is nModes + excludeRigidBodyModes, from which excludeRigidBodyModes smallest eigenvalues are excluded
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf GetEigenFrequenciesHz}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: return list of eigenvalues in Hz of previously computed eigenmodes\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ComputeCampbellDiagram}}({\it self}, {\it terminalFrequency}, {\it nEigenfrequencies}=10, {\it frequencySteps}=25, {\it rotationAxis}=2, {\it plotDiagram}=False, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] compute Campbell diagram for given mechanical system
    \item[] create a first order system Axd + Bx = 0 with x= [q,qd]' and compute eigenvalues
    \item[] takes mass M, stiffness K and gyroscopic matrix G from FEMinterface
    \item[] currently only uses dense matrices, so it is limited to approx. 5000 unknowns!
  \ei
  \item[--]  \textcolor{steelblue}{\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it terminalFrequency}: frequency in Hz, up to which the campbell diagram is computed
    \item[] {\it   nEigenfrequencies}: gives the number of computed eigenfrequencies(modes), in addition to the rigid body mode 0
    \item[] {\it   frequencySteps}: gives the number of increments (gives frequencySteps+1 total points in campbell diagram)
    \item[] {\it   rotationAxis}:[0,1,2] = [x,y,z] provides rotation axis
    \item[] {\it   plotDiagram}: if True, plots diagram for nEigenfrequencies befor terminating
    \item[] {\it   verbose}: if True, shows progress of computation
  \ei
  \item[--]  \textcolor{steelblue}{\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] [listFrequencies, campbellFrequencies]
    \item[] {\it   listFrequencies}: list of computed frequencies
    \item[] {\it   campbellFrequencies}: array of campbell frequencies per eigenfrequency of system
  \ei
\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf CheckConsistency}}({\it self})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: perform some consistency checks\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadMassMatrixFromAnsys}}({\it self}, {\it fileName}, {\it dofMappingVectorFile}, {\it sparse}=True, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read mass matrix from CSV format (exported from Ansys)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadStiffnessMatrixFromAnsys}}({\it self}, {\it fileName}, {\it dofMappingVectorFile}, {\it sparse}=True, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read stiffness matrix from CSV format (exported from Ansys)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadNodalCoordinatesFromAnsys}}({\it self}, {\it fileName}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read nodal coordinates (exported from Ansys as .txt-File)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent \textcolor{steelblue}{def {\bf ReadElementsFromAnsys}}({\it self}, {\it fileName}, {\it verbose}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  \textcolor{steelblue}{\bf classFunction}: read elements (exported from Ansys as .txt-File)\vspace{12pt}\end{itemize}
%
\mysubsection{Module: plot}
\noindent {def {\bf PlotSensor}}({\it mbs}, {\it sensorNumbers}, {\it components}=0, {\it **kwargs})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: helper for matplotlib in order to easily visualize sensor output  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it mbs}: must be a valid MainSystem (mbs)
    \item[] {\it   sensorNumbers}: consists of one or a list of sensor numbers (type SensorIndex) as returned by the mbs function AddSensor(...)
    \item[] {\it   components}: consists of one or a list of components according to the component of the sensor to be plotted;
    \item[] {\it   *kwargs}: additional options, e.g.:
    \item[]         xLabel -> string for text at x-axis
    \item[]         yLabel -> string for text at y-axis
  \ei
  \item[--]  {\bf output}: plots the sensor data  \item[--]  {\bf example}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] s0=mbs.AddSensor(SensorNode(nodeNumber=0))
    \item[]   s1=mbs.AddSensor(SensorNode(nodeNumber=1))
    \item[]   Plot(mbs, s0, 0)
    \item[]   Plot(mbs, sensorNumbers=[s0,s1], components=[0,2], xlabel='time in seconds')
  \ei
\vspace{12pt}\end{itemize}
%
\mysubsection{Module: processing}
\noindent {def {\bf ProcessParameterList}}({\it parameterFunction}, {\it parameterList}, {\it addComputationIndex}, {\it useMultiProcessing}, {\it **kwargs})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: processes parameterFunction for given parameters in parameterList, see ParameterVariation  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterFunction}: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
    \item[] {\it     parameterList}: list of parameter sets (as dictionaries) which are fed into the parameter variation, e.g., [{'mass': 10}, {'mass':20}, ...]
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
  \ei
  \item[--]  {\bf output}: returns values containing the results according to parameterList  \item[--]  {\bf notes}: options are passed from Parametervariation\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf ParameterVariation}}({\it parameterFunction}, {\it parameters}, {\it useLogSpace}=False, {\it debugMode}=False, {\it addComputationIndex}=False, {\it useMultiProcessing}=False, {\it showProgress}=True, {\it **kwargs})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] calls successively the function parameterFunction(parameterDict) with variation of parameters in given range; parameterDict is a dictionary, containing the current values of parameters,
    \item[] {\it   e.g., parameterDict=['mass'}:13, 'stiffness':12000] to be computed and returns a value or a list of values which is then stored for each parameter
  \ei
  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterFunction}: function, which takes the form parameterFunction(parameterDict) and which returns any values that can be stored in a list (e.g., a floating point number)
    \item[] {\it     parameters}: given as a dictionary, consist of name and triple of (begin, end and steps) same as in np.linspace(...), e.g. 'mass':(10,50,10) for a mass varied from 10 to 50, using 10 steps
    \item[] {\it     useLogSpace}: (optional) if True, the parameters are varied at a logarithmic scale, e.g., [1, 10, 100] instead linear [1, 50.5, 100]
    \item[] {\it     debugMode}: if True, additional print out is done
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     showProgress}: if True, shows for every iteration the progress bar (requires tqdm library)
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
  \ei
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it returns [parameterList, values], containing, e.g., parameterList={'mass'}:[1,1,1,2,2,2,3,3,3], 'stiffness':[4,5,6, 4,5,6, 4,5,6]} and the result values of the parameter variation accoring to the parameterList,
    \item[]            values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
  \ei
  \item[--]  {\bf example}: ParameterVariation(parameters=\{'mass':(1,10,10), 'stiffness':(1000,10000,10)\}, parameterFunction=Test, useMultiProcessing=True)\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf GeneticOptimization}}({\it objectiveFunction}, {\it parameters}, {\it initialPopulationSize}=100, {\it numberOfGenerations}=10, {\it numberOfChildren}=8, {\it survivingIndividuals}=8, {\it rangeReductionFactor}=0.7, {\it distanceFactor}=0.1, {\it debugMode}=False, {\it addComputationIndex}=False, {\it useMultiProcessing}=False, {\it showProgress}=True, {\it **kwargs})
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: compute minimum of given objectiveFunction  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it objectiveFunction}: function, which takes the form parameterFunction(parameterDict) and which returns a value or list (or numpy array) which reflects the size of the objective to be minimized
    \item[] {\it     parameters}: given as a dictionary, consist of name and tuple of (begin, end), e.g. 'mass':(10,50)
    \item[] {\it     initialPopulationSize}: number of random initial individuals
    \item[] {\it     numberOfGenerations}: number of generations
    \item[] {\it     numberOfChildren}: number childrens of surviving population
    \item[] {\it     useGeneCrossing}: (not implemented yet) if True, the children are generated from parents by gene-crossover
    \item[] {\it     survivingIndividuals}: number of surviving individuals after children are born
    \item[] {\it     rangeReductionFactor}: reduction of mutation range relative to ranges of last step
    \item[] {\it     distanceFactor}: children only survive at a certain relative distance of the current range; must be small enough (< 0.5) to allow individuals to survive; ignored if distanceFactor=0; as a rule of thumb, the distanceFactor should be zero in case that there is only one significant minimum, but if there are many local minima, the distanceFactor should be used to search at several different local minima
    \item[] {\it     randomizerInitialization}: initialize randomizer at beginning of optimization in order to get reproducible results, provide any integer in the range between 0 and 2**32 - 1 (default: no initialization)
    \item[] {\it     debugMode}: if True, additional print out is done
    \item[] {\it     addComputationIndex}: if True, key 'computationIndex' is added to every parameterDict in the call to parameterFunction(), which allows to generate independent output files for every parameter, etc.
    \item[] {\it     useMultiProcessing}: if True, the multiprocessing lib is used for parallelized computation; WARNING: be aware that the function does not check if your function runs independently; DO NOT use GRAPHICS and DO NOT write to same output files, etc.!
    \item[] {\it     showProgress}: if True, shows for every iteration the progress bar (requires tqdm library)
    \item[] {\it     numberOfThreads}: default: same as number of cpus (threads); used for multiprocessing lib;
  \ei
  \item[--]  {\bf output}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] returns [optimumParameter, optimumValue, parameterList, valueList], containing the optimum parameter set 'optimumParameter', optimum value 'optimumValue', the whole list of parameters parameterList with according objective values 'valueList'
    \item[]            values=[7,8,9 ,3,4,5, 6,7,8] (depends on solution of problem ..., can also contain tuples, etc.)
  \ei
  \item[--]  {\bf notes}: This function is still under development and shows an experimental state!  \item[--]  {\bf example}: GeneticOptimization(objectiveFunction = fOpt, parameters=\{'mass':(1,10), 'stiffness':(1000,10000)\})\vspace{12pt}\end{itemize}
%
\noindent\rule{8cm}{0.75pt}\vspace{1pt} \\ 
\noindent {def {\bf PlotOptimizationResults2D}}({\it parameterList}, {\it valueList}, {\it xLogScale}=False, {\it yLogScale}=False)
\setlength{\itemindent}{0.7cm}
\begin{itemize}[leftmargin=0.7cm]
  \item[--]  {\bf function description}: visualize results of optimization for every parameter (2D plots)  \item[--]  {\bf input}: \vspace{-6pt}
  \begin{itemize}[leftmargin=1.2cm]
\setlength{\itemindent}{-0.7cm}
    \item[] {\it parameterList}: taken from output parameterList of \texttt{GeneticOptimization}, containing a dictinary with lists of parameters
    \item[] {\it    valueList}: taken from output valueList of \texttt{GeneticOptimization}; containing a list of floats that result from the objective function
    \item[] {\it    xLogScale}: use log scale for x-axis
    \item[] {\it    yLogScale}: use log scale for y-axis
  \ei
  \item[--]  {\bf output}: return [figList, axList] containing the corresponding handles; creates a figure for every parameter in parameterList\vspace{12pt}\end{itemize}
%
