

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ObjectContactFrictionCircleCable2D &mdash; Exudyn1.9.83.dev1 1.9.83.dev1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=3ee1c6c6" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/rtd_sphinx_search.min.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=e11081fd" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=86202e69"></script>
      <script src="../../../_static/doctools.js?v=9bcbadda"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=f281be69"></script>
      <script src="../../../_static/js/rtd_search_config.js"></script>
      <script src="../../../_static/js/rtd_sphinx_search.min.js"></script>
      <script>window.MathJax = {"loader": {"load": ["[tex]/mathtools"]}, "tex": {"packages": {"[+]": ["mathtools"]}, "macros": {"vspace": ["{}", 1], "ra": "{\\rightarrow}", "Rcal": "{\\mathbb{R}}", "Ccal": "{\\mathbb{C}}", "Ncal": "{\\mathbb{N}}", "Rot": "{\\mathbf{A}}", "dd": "{\\mathrm{d}}", "ps": "{p_\\mathrm{s}}", "co": "{\\mathrm{c}}", "si": "{\\mathrm{s}}", "tp": "{^\\mathrm{T}}", "diag": "{\\mathrm{diag}}", "vec": "{\\mathrm{vec}}", "Null": "{\\mathbf{0}}", "varepsilonDot": "{\\boldsymbol{\\varepsilon}}", "talpha": "{\\boldsymbol{\\alpha}}", "tbeta": "{\\boldsymbol{\\beta}}", "tgamma": "{\\boldsymbol{\\gamma}}", "tchi": "{\\boldsymbol{\\chi}}", "tdelta": "{\\boldsymbol{\\delta}}", "teps": "{\\boldsymbol{\\varepsilon}}", "tepsDot": "{\\boldsymbol{\\dot \\varepsilon}}", "teta": "{\\boldsymbol{\\eta}}", "tkappa": "{\\boldsymbol{\\kappa}}", "tkappaDot": "{\\boldsymbol{\\dot \\kappa}}", "tphi": "{\\boldsymbol{\\phi}}", "boldVarPhi": "{\\boldsymbol{\\varphi}}", "tPhi": "{\\boldsymbol{\\Phi}}", "ttheta": "{\\boldsymbol{\\theta}}", "tTheta": "{\\boldsymbol{\\Theta}}", "tlambda": "{\\boldsymbol{\\lambda}}", "tnu": "{\\boldsymbol{\\nu}}", "tmu": "{\\boldsymbol{\\mu}}", "tpsi": "{\\boldsymbol{\\psi}}", "tPsi": "{\\boldsymbol{\\Psi}}", "ttau": "{\\boldsymbol{\\tau}}", "tsigma": "{\\boldsymbol{\\sigma}}", "txi": "{\\boldsymbol{\\xi}}", "tzeta": "{\\boldsymbol{\\zeta}}", "tomega": "{\\boldsymbol{\\omega}}", "tOmega": "{\\boldsymbol{\\Omega}}", "vareps": "{\\varepsilon}", "myoverline": ["\\overline{#1}", 1], "pluseq": "\\mathrel{+}=", "LU": ["{\\prescript{#1}{}{#2}\\,}", 2], "LUX": ["{\\prescript{#1}{}{#2}#3\\,}", 3], "LUR": ["{\\prescript{#1}{}{#2}_{#3}\\,}", 3], "LURU": ["{\\prescript{#1}{}{#2}_{#3}^{#4}\\,}", 4], "LLdot": ["{\\prescript{}{#1}{\\dot{#2}}_{#3}\\,}", 3], "vr": ["{\\left[ \\begin{array}{c} { #1}\\vspace{0.04cm} \\\\ { #2}\\vspace{0.04cm} \\\\ { #3} \\end{array} \\right]}", 3], "mr": ["{\\left[ \\begin{array}{ccc} #1 & #2 & #3 \\vspace{0.04cm}\\\\ #4 & #5 & #6 \\vspace{0.04cm}\\\\ #7 & #8 & #9  \\end{array} \\right]}", 9], "vp": ["{\\left[ \\begin{array}{c} { #1} \\vspace{0.04cm}\\\\ { #2} \\end{array} \\right]}", 2], "mp": ["{\\left[ \\begin{array}{cc} #1 & #2 \\vspace{0.04cm}\\\\ #3 & #4 \\end{array} \\right]}", 4], "mfour": ["{\\left[ \\begin{array}{cccc} { #1} \\\\ { #2} \\\\ { #3} \\\\ { #4} \\end{array} \\right]}", 4], "vfour": ["{\\left[ \\begin{array}{c} { #1} \\\\ { #2} \\\\ { #3} \\\\ { #4} \\end{array} \\right]}", 4], "vrRow": ["{[#1,\\, #2,\\, #3]}", 3], "vsix": ["{\\left[ \\begin{array}{c} { #1} \\\\ { #2} \\\\ { #3} \\\\ { #4} \\\\ { #5} \\\\ { #6} \\end{array} \\right]}", 6], "vsixb": ["{\\begin{array}{c} { #1} \\\\ { #2} \\\\ { #3} \\\\ { #4} \\\\ { #5} \\\\ { #6} \\end{array} }", 6], "vsixs": ["{ \\begin{array}{c} { #1} \\\\ { #2} \\\\ { #3} \\\\ { #4} \\\\ { #5} \\\\ { #6} \\end{array} }", 6], "SO": "{q}", "FO": "{y}", "AE": "{\\lambda}", "SYS": "{s}", "SON": "{$2^\\mathrm{nd}$ order differential equations}", "FON": "{$1^\\mathrm{st}$ order differential equations}", "AEN": "{algebraic equations}", "SYSN": "{system equations}", "cIni": "{_\\mathrm{ini}}", "cRef": "{_\\mathrm{ref}}", "cCur": "{_\\mathrm{cur}}", "cVis": "{_\\mathrm{vis}}", "cSOS": "{_\\mathrm{start\\;of\\;step}}", "cConfig": "{_\\mathrm{config}}", "pLoc": "{\\mathbf{b}}", "pLocB": "{\\,^{b}{\\mathbf{v}}}", "pRef": "{\\mathbf{r}}", "pRefG": "{\\,^{0}{\\mathbf{r}}}", "indf": "{_\\mathrm{f}}", "indt": "{_\\mathrm{t}}", "indr": "{_\\mathrm{r}}", "indtt": "{_\\mathrm{tt}}", "indrr": "{_\\mathrm{rr}}", "indff": "{_\\mathrm{ff}}", "indtf": "{_\\mathrm{tf}}", "indrf": "{_\\mathrm{rf}}", "indtr": "{_\\mathrm{tr}}", "omegaBDtilde": "{\\LU{b}{\\tilde \\tomega_\\mathrm{bd}}}", "indrigid": "{_\\mathrm{rigid}}", "indred": "{_\\mathrm{red}}", "induser": "{_\\mathrm{user}}", "indu": "{_\\mathrm{u}}", "termA": ["{\\color{blue}{#1}}", 1], "termB": ["{\\color{red}{#1}}", 1], "termC": ["{\\color{green}{#1}}", 1], "acc": "{\\ddot \\mathbf{q}}", "GA": "{G\\alpha}", "aalg": "{\\mathbf{a}}", "vel": "{\\mathbf{v}}"}}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="ObjectContactSphereSphere" href="ObjectContactSphereSphere.html" />
    <link rel="prev" title="ObjectContactCircleCable2D" href="ObjectContactCircleCable2D.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Exudyn1.9.83.dev1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Exudyn User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Exudyn.html">Exudyn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InstallationAndGettingStartedIndex.html">Installation and Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OverviewOnExudynIndex.html">Overview on Exudyn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TutorialIndex.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GraphicsAndVisualizationIndex.html">Graphics and visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NotationIndex.html">Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TheoryAndFormulationsIndex.html">Theory and formulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SolversIndex.html">Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cInterface/CInterfaceIndex.html">Python-C++ command interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../pythonUtilities/index.html">Python Utility Functions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="itemsIndex.html">Items reference manual</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="nodeIndex.html">Node</a></li>
<li class="toctree-l2"><a class="reference internal" href="objectBodyIndex.html">Object (Body)</a></li>
<li class="toctree-l2"><a class="reference internal" href="objectSuperElementIndex.html">Object (SuperElement)</a></li>
<li class="toctree-l2"><a class="reference internal" href="objectObjectIndex.html">Object (Object)</a></li>
<li class="toctree-l2"><a class="reference internal" href="objectFiniteElementIndex.html">Object (FiniteElement)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="objectConnectorIndex.html">Object (Connector)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorSpringDamper.html">ObjectConnectorSpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorCartesianSpringDamper.html">ObjectConnectorCartesianSpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorRigidBodySpringDamper.html">ObjectConnectorRigidBodySpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorLinearSpringDamper.html">ObjectConnectorLinearSpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorTorsionalSpringDamper.html">ObjectConnectorTorsionalSpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorCoordinateSpringDamper.html">ObjectConnectorCoordinateSpringDamper</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorCoordinateSpringDamperExt.html">ObjectConnectorCoordinateSpringDamperExt</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorGravity.html">ObjectConnectorGravity</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorHydraulicActuatorSimple.html">ObjectConnectorHydraulicActuatorSimple</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorReevingSystemSprings.html">ObjectConnectorReevingSystemSprings</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectConnectorRollingDiscPenalty.html">ObjectConnectorRollingDiscPenalty</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectContactConvexRoll.html">ObjectContactConvexRoll</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectContactCoordinate.html">ObjectContactCoordinate</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectContactCircleCable2D.html">ObjectContactCircleCable2D</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">ObjectContactFrictionCircleCable2D</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectContactSphereSphere.html">ObjectContactSphereSphere</a></li>
<li class="toctree-l3"><a class="reference internal" href="ObjectContactCurveCircles.html">ObjectContactCurveCircles</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="objectConstraintIndex.html">Object (Constraint)</a></li>
<li class="toctree-l2"><a class="reference internal" href="objectJointIndex.html">Object (Joint)</a></li>
<li class="toctree-l2"><a class="reference internal" href="markerIndex.html">Marker</a></li>
<li class="toctree-l2"><a class="reference internal" href="loadIndex.html">Load</a></li>
<li class="toctree-l2"><a class="reference internal" href="sensorIndex.html">Sensor</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../structures/StructuresAndSettingsIndex.html">Structures and Settings</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Abbreviations.html">List of Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ExamplesIndex.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TestModelsIndex.html">TestModels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trackerlog.html">Issue tracker</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Exudyn1.9.83.dev1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="itemsIndex.html">Items reference manual</a></li>
          <li class="breadcrumb-item"><a href="objectConnectorIndex.html">Object (Connector)</a></li>
      <li class="breadcrumb-item active">ObjectContactFrictionCircleCable2D</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/docs/RST/items/ObjectContactFrictionCircleCable2D.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="objectcontactfrictioncirclecable2d">
<span id="sec-item-objectcontactfrictioncirclecable2d"></span><h1>ObjectContactFrictionCircleCable2D<a class="headerlink" href="#objectcontactfrictioncirclecable2d" title="Link to this heading"></a></h1>
<p>A very specialized penalty-based contact/friction condition between a 2D circle in the local x/y plane (=marker0, a RigidBody Marker, from node or object) on a body and an ANCFCable2DShape (=marker1, Marker: BodyCable2DShape), in xy-plane; a node NodeGenericData is required with 3<span class="math notranslate nohighlight">\(\times\)</span>(number of contact segments) – containing per segment: [contact gap, stick/slip (stick=0, slip=+-1, undefined=-2), last friction position]. The connector works with Cable2D and ALECable2D, HOWEVER, due to conceptual differences the (tangential) frictionStiffness cannot be used with ALECable2D; if using, it gives wrong tangential stresses, even though it may work in general.</p>
<p><strong>Additional information for ObjectContactFrictionCircleCable2D</strong>:</p>
<ul>
<li><div class="line-block">
<div class="line">This <code class="docutils literal notranslate"><span class="pre">Object</span></code> has/provides the following types = <code class="docutils literal notranslate"><span class="pre">Connector</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Requested <code class="docutils literal notranslate"><span class="pre">Marker</span></code> type = <code class="docutils literal notranslate"><span class="pre">_None</span></code></div>
</div>
</li>
<li><div class="line-block">
<div class="line">Requested <code class="docutils literal notranslate"><span class="pre">Node</span></code> type = <code class="docutils literal notranslate"><span class="pre">GenericData</span></code></div>
</div>
</li>
</ul>
<p>The item <strong>ObjectContactFrictionCircleCable2D</strong> with type = ‘ContactFrictionCircleCable2D’ has the following parameters:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>name</strong> [type = String, default = ‘’]:</div>
<div class="line">connector’s unique name</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>markerNumbers</strong> [<span class="math notranslate nohighlight">\([m0,m1]\tp\)</span>, type = ArrayMarkerIndex, default = [ invalid [-1], invalid [-1] ]]:</div>
<div class="line">a marker <span class="math notranslate nohighlight">\(m0\)</span> with position and orientation and a marker <span class="math notranslate nohighlight">\(m1\)</span> of type BodyCable2DShape; together defining the contact geometry</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>nodeNumber</strong> [<span class="math notranslate nohighlight">\(n_g\)</span>, type = NodeIndex, default = invalid (-1)]:</div>
<div class="line">node number of a NodeGenericData with 3 <span class="math notranslate nohighlight">\(\times n_{cs}\)</span>  dataCoordinates (used for active set strategy <span class="math notranslate nohighlight">\(\ra\)</span> hold the gap of the last discontinuous iteration, friction state (+-1=slip, 0=stick, -2=undefined) and the last sticking position; initialize coordinates with list [0.1]*<span class="math notranslate nohighlight">\(n_{cs}\)</span>+[-2]*<span class="math notranslate nohighlight">\(n_{cs}\)</span>+[0.]*<span class="math notranslate nohighlight">\(n_{cs}\)</span>, meaning that there is no initial contact with undefined slip/stick</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>numberOfContactSegments</strong> [<span class="math notranslate nohighlight">\(n_{cs}\)</span>, type = PInt, default = 3]:</div>
<div class="line">number of linear contact segments to determine contact; each segment is a line and is associated to a data (history) variable; must be same as in according marker</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>contactStiffness</strong> [<span class="math notranslate nohighlight">\(k_c\)</span>, type = UReal, default = 0.]:</div>
<div class="line">contact (penalty) stiffness [SI:N/m/(contact segment)]; the stiffness is per contact segment; specific contact forces (per length) <span class="math notranslate nohighlight">\(f_n\)</span> act in contact normal direction only upon penetration</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>contactDamping</strong> [<span class="math notranslate nohighlight">\(d_c\)</span>, type = UReal, default = 0.]:</div>
<div class="line">contact damping [SI:N/(m s)/(contact segment)]; the damping is per contact segment; acts in contact normal direction only upon penetration</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>frictionVelocityPenalty</strong> [<span class="math notranslate nohighlight">\(\mu_v\)</span>, type = UReal, default = 0.]:</div>
<div class="line">tangential velocity dependent penalty coefficient for friction [SI:N/(m s)/(contact segment)]; the coefficient causes tangential (contact) forces against relative tangential velocities in the contact area</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>frictionStiffness</strong> [<span class="math notranslate nohighlight">\(\mu_k\)</span>, type = UReal, default = 0.]:</div>
<div class="line">tangential displacement dependent penalty/stiffness coefficient for friction [SI:N/m/(contact segment)]; the coefficient causes tangential (contact) forces against relative tangential displacements in the contact area</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>frictionCoefficient</strong> [<span class="math notranslate nohighlight">\(\mu\)</span>, type = UReal, default = 0.]:</div>
<div class="line">friction coefficient [SI: 1]; tangential specific friction forces (per length) <span class="math notranslate nohighlight">\(f_t\)</span> must fulfill the condition <span class="math notranslate nohighlight">\(f_t \le \mu f_n\)</span></div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>circleRadius</strong> [<span class="math notranslate nohighlight">\(r\)</span>, type = UReal, default = 0.]:</div>
<div class="line">radius [SI:m] of contact circle</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>useSegmentNormals</strong> [type = Bool, default = True]:</div>
<div class="line">True: use normal and tangent according to linear segment; this is appropriate for very long (compared to circle) segments; False: use normals at segment points according to vector to circle center; this is more consistent for short segments, as forces are only applied in beam tangent and normal direction</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>activeConnector</strong> [type = Bool, default = True]:</div>
<div class="line">flag, which determines, if the connector is active; used to deactivate (temporarily) a connector or constraint</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>visualization</strong> [type = VObjectContactFrictionCircleCable2D]:</div>
<div class="line">parameters for visualization of item</div>
</div>
</li>
</ul>
<p>The item VObjectContactFrictionCircleCable2D has the following parameters:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>show</strong> [type = Bool, default = True]:</div>
<div class="line">set True, if item is shown in visualization and false if it is not shown; note that only normal contact forces can be  drawn, which are approximated by <span class="math notranslate nohighlight">\(k_c \cdot g\)</span> (neglecting damping term)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>showContactCircle</strong> [type = Bool, default = True]:</div>
<div class="line">if True and show=True, the underlying contact circle is shown; uses circleTiling*4 for tiling (from VisualizationSettings.general)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>drawSize</strong> [type = float, default = -1.]:</div>
<div class="line">drawing size = diameter of spring; size == -1.f means that default connector size is used</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>color</strong> [type = Float4, default = [-1.,-1.,-1.,-1.]]:</div>
<div class="line">RGBA connector color; if R==-1, use default color</div>
</div>
</li>
</ul>
<hr class="docutils" />
<section id="description-of-objectcontactfrictioncirclecable2d">
<span id="description-objectcontactfrictioncirclecable2d"></span><h2>DESCRIPTION of ObjectContactFrictionCircleCable2D<a class="headerlink" href="#description-of-objectcontactfrictioncirclecable2d" title="Link to this heading"></a></h2>
<p><strong>The following output variables are available as OutputVariableType in sensors, Get…Output() and other functions</strong>:</p>
<ul>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Coordinates</span></code>: <span class="math notranslate nohighlight">\([u_{t,0},\, g_0,\, u_{t,1},\, g_1,\, \ldots,\, u_{t,n_{cs}},\, g_{n_{cs}}]\tp\)</span></div>
<div class="line">local (relative) displacement in tangential (<span class="math notranslate nohighlight">\({\mathbf{t}}\)</span>) and normal (<span class="math notranslate nohighlight">\({\mathbf{n}}\)</span>) direction per segment (<span class="math notranslate nohighlight">\(n_{cs}\)</span>); values are only provided in case of contact, otherwise zero; tangential displacement is only non-zero in case of sticking!</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">Coordinates\_t</span></code>: <span class="math notranslate nohighlight">\([v_{t,0},\, v_{n,0},\, v_{t,1},\, v_{n,1},\, \ldots,\, v_{t,n_{cs}},\, v_{n,n_{cs}}]\tp\)</span></div>
<div class="line">local (relative) velocity in tangential (<span class="math notranslate nohighlight">\({\mathbf{t}}\)</span>) and normal (<span class="math notranslate nohighlight">\({\mathbf{n}}\)</span>) direction per segment (<span class="math notranslate nohighlight">\(n_{cs}\)</span>); values are only provided in case of contact, otherwise zero</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><code class="docutils literal notranslate"><span class="pre">ForceLocal</span></code>: <span class="math notranslate nohighlight">\([f_{t,0},\, f_{n,0},\, f_{t,1},\, f_{n,1},\, \ldots,\, f_{t,n_{cs}},\, f_{n,n_{cs}}]\tp\)</span></div>
<div class="line">local contact forces in tangential (<span class="math notranslate nohighlight">\({\mathbf{t}}\)</span>) and normal (<span class="math notranslate nohighlight">\({\mathbf{n}}\)</span>) direction per segment (<span class="math notranslate nohighlight">\(n_{cs}\)</span>)</div>
</div>
</li>
</ul>
</section>
<section id="definition-of-quantities">
<h2>Definition of quantities<a class="headerlink" href="#definition-of-quantities" title="Link to this heading"></a></h2>
<table class="docutils align-default" id="id1">
<caption><span class="caption-text"></span><a class="headerlink" href="#id1" title="Link to this table"></a></caption>
<thead>
<tr class="row-odd"><th class="head"><div class="line-block">
<div class="line">intermediate variables</div>
</div>
</th>
<th class="head"><div class="line-block">
<div class="line">symbol</div>
</div>
</th>
<th class="head"><div class="line-block">
<div class="line">description</div>
</div>
</th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><div class="line-block">
<div class="line">marker m0 position</div>
</div>
</td>
<td><div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\(\LU{0}{{\mathbf{p}}}_{m0}\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">represents current global position of the circle’s centerpoint</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">marker m0 velocity</div>
</div>
</td>
<td><div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\(\LU{0}{{\mathbf{v}}}_{m0}\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">current global velocity which is provided by marker m0</div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">marker m1</div>
</div>
</td>
<td><div class="line-block">
<div class="line"><br /></div>
</div>
</td>
<td><div class="line-block">
<div class="line">represents the 2D ANCF cable</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">data node</div>
</div>
</td>
<td><div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\({\mathbf{x}}=[x_{i},\; \ldots,\; x_{3 n_{cs} -1}]\tp\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">coordinates of node with node number <span class="math notranslate nohighlight">\(n_{GD}\)</span></div>
</div>
</td>
</tr>
<tr class="row-even"><td><div class="line-block">
<div class="line">data coordinates for segment <span class="math notranslate nohighlight">\(i\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\([x_i,\, x_{n_{cs}+ i},\, x_{2\cdot n_{cs}+ i}]\tp = [x_{gap},\, x_{isSlipStick},\, x_{lastStick}]\tp\)</span>, with <span class="math notranslate nohighlight">\(i \in [0,n_{cs}-1]\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">The data coordinates include the gap <span class="math notranslate nohighlight">\(x_{gap}\)</span>, the stick-slip state <span class="math notranslate nohighlight">\(x_{isSlipStick}\)</span> and the previous sticking position <span class="math notranslate nohighlight">\(x_{lastStick}\)</span> as computed in the PostNewtonStep, see description below.</div>
</div>
</td>
</tr>
<tr class="row-odd"><td><div class="line-block">
<div class="line">shortest distance to segment <span class="math notranslate nohighlight">\(s_i\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line"><span class="math notranslate nohighlight">\({\mathbf{d}}_{g,i}\)</span></div>
</div>
</td>
<td><div class="line-block">
<div class="line">shortest distance of center of circle to contact segment, considering the endpoint of the segment</div>
</div>
</td>
</tr>
</tbody>
</table>
<figure class="align-default" id="id2">
<span id="fig-objectcontactfrictioncirclecable2d-sketch"></span><a class="reference internal image-reference" href="../../../_images/ContactFrictionCircleCable2D.png"><img alt="../../../_images/ContactFrictionCircleCable2D.png" src="../../../_images/ContactFrictionCircleCable2D.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 43 </span><span class="caption-text">Sketch of cable, contact segments and circle; showing case without contact, <span class="math notranslate nohighlight">\(|\mathbf{d}_{g1}| &gt; r\)</span>, while contact occurs with <span class="math notranslate nohighlight">\(|\mathbf{d}_{g1}| \le r\)</span>; the shortest distance vector <span class="math notranslate nohighlight">\(\mathbf{d}_{g1}\)</span> is related to segment <span class="math notranslate nohighlight">\(s_1\)</span> (which is perpendicular to the the segment line) and <span class="math notranslate nohighlight">\(\mathbf{d}_{g2}\)</span> is the shortest distance to the end point of segment <span class="math notranslate nohighlight">\(s_2\)</span>, not being perpendicular</span><a class="headerlink" href="#id2" title="Link to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="connector-forces-contact-geometry">
<h2>Connector forces: contact geometry<a class="headerlink" href="#connector-forces-contact-geometry" title="Link to this heading"></a></h2>
<p>The connector represents a force element between a ‘circle’ (or cylinder) represented by a marker <span class="math notranslate nohighlight">\(m0\)</span>, which has position and orientation,
and an <code class="docutils literal notranslate"><span class="pre">ANCFCable2D</span></code> beam element (denoted as ‘cable’) represented by a <code class="docutils literal notranslate"><span class="pre">MarkerBodyCable2DShape</span></code> <span class="math notranslate nohighlight">\(m1\)</span>.
The cable with reference length <span class="math notranslate nohighlight">\(L\)</span> is discretized by splitting into <span class="math notranslate nohighlight">\(n_{cs}\)</span> straight segments <span class="math notranslate nohighlight">\(s_i\)</span>, located between points <span class="math notranslate nohighlight">\(p_i\)</span> and <span class="math notranslate nohighlight">\(p_{i+1}\)</span>.
Note that these points can be placed with an offset from the cable centerline, see <code class="docutils literal notranslate"><span class="pre">verticalOffset</span></code> defined in <code class="docutils literal notranslate"><span class="pre">MarkerBodyCable2DShape</span></code>.
In order to compute the gap function for a line segment, the shortest distance of one line segment with
points <span class="math notranslate nohighlight">\({\mathbf{p}}_i\)</span>, <span class="math notranslate nohighlight">\({\mathbf{p}}_{i+1}\)</span> to the circle’s centerpoint given by the marker <span class="math notranslate nohighlight">\({\mathbf{p}}_{m0}\)</span> is computed.
All computations here are performed in the global coordinates system (0),
including edge points of every segment.</p>
<p>With the intermediate quantities (all of them related to segment <span class="math notranslate nohighlight">\(s_i\)</span>)(we omit <span class="math notranslate nohighlight">\(s_i\)</span> in some terms for brevity!),</p>
<div class="math notranslate nohighlight">
\[{\mathbf{v}}_s = {\mathbf{p}}_{i+1} - {\mathbf{p}}_i, \quad {\mathbf{v}}_p = {\mathbf{p}}_{m0} - {\mathbf{p}}_i, \quad n = {\mathbf{v}}_s\tp {\mathbf{v}}_p, \quad d = {\mathbf{v}}_s\tp {\mathbf{v}}_s\]</div>
<p>and assuming that <span class="math notranslate nohighlight">\(d \neq 0\)</span> (otherwise the two segment points would be identical and
the shortest distance would be <span class="math notranslate nohighlight">\(d_g = |{\mathbf{v}}_p|\)</span>),
we find the relative position <span class="math notranslate nohighlight">\(\rho\)</span> of the shortest (projected) point on the
segment, which runs from 0 to 1 if lying on the segment, as</p>
<div class="math notranslate nohighlight">
\[\rho = \frac{n}{d}\]</div>
<p>We distinguish 3 cases (see also <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-sketch"><span class="std std-numref">Fig. 43</span></a> for cases 1 and 2):</p>
<ul class="simple">
<li><dl class="simple">
<dt>If <span class="math notranslate nohighlight">\(\rho \le 0\)</span>, the shortest distance would be the distance to point <span class="math notranslate nohighlight">\({\mathbf{p}}_p={\mathbf{p}}_i\)</span>,</dt><dd><p>reading</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[d_g = |{\mathbf{p}}_{m0} - {\mathbf{p}}_i| \quad (\rho \le 0)\]</div>
<ul class="simple">
<li><dl class="simple">
<dt>If <span class="math notranslate nohighlight">\(\rho \ge 1\)</span>, the shortest distance would be the distance to point <span class="math notranslate nohighlight">\({\mathbf{p}}_p={\mathbf{p}}_{i+1}\)</span>,</dt><dd><p>reading</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[d_g = |{\mathbf{p}}_{m0} - {\mathbf{p}}_{i+1}| \quad (\rho \ge 1)\]</div>
<ul class="simple">
<li><dl class="simple">
<dt>Finally, if <span class="math notranslate nohighlight">\(0 &lt; \rho &lt; 1\)</span>, then the shortest distance has a projected point somewhere</dt><dd><p>on the segment with the point (projected on the segment)</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}{\mathbf{p}}_p = {\mathbf{p}}_i + \rho \cdot {\mathbf{v}}_s\\
 and the distance\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[d_g = |{\mathbf{d}}_g| = \sqrt{{\mathbf{v}}_p\tp {\mathbf{v}}_p - (n^2)/d}\]</div>
<p>Here, the shortest distance vector for every segment results from the projected point <span class="math notranslate nohighlight">\({\mathbf{p}}_p\)</span>of the above mentioned cases, see also <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-sketch"><span class="std std-numref">Fig. 43</span></a>,
with the relation</p>
<div class="math notranslate nohighlight">
\[{\mathbf{d}}_g = {\mathbf{d}}_{g,s_i}= {\mathbf{p}}_{m0} - {\mathbf{p}}_p .\]</div>
<p>The contact gap for a specific point for segment <span class="math notranslate nohighlight">\(s_i\)</span> is in general defined as</p>
<div class="math notranslate nohighlight" id="equation-objectcontactfrictioncirclecable2d-gap">
<span class="eqno">(79)<a class="headerlink" href="#equation-objectcontactfrictioncirclecable2d-gap" title="Link to this equation"></a></span>\[g = g_{s_i} = d_g - r .\]</div>
<p>using <span class="math notranslate nohighlight">\(d_g = |{\mathbf{d}}_g|\)</span>.</p>
</section>
<section id="contact-frame-and-relative-motion">
<h2>Contact frame and relative motion<a class="headerlink" href="#contact-frame-and-relative-motion" title="Link to this heading"></a></h2>
<p>Irrespective of the choice of <code class="docutils literal notranslate"><span class="pre">useSegmentNormals</span></code>, the contact normal vector <span class="math notranslate nohighlight">\({\mathbf{n}}_{s_i}\)</span> and tangential vector <span class="math notranslate nohighlight">\({\mathbf{t}}_{s_i}\)</span> are defined per segment as</p>
<div class="math notranslate nohighlight">
\[{\mathbf{n}}_{s_i} = {\mathbf{n}} = [n_0, n_1]\tp = \frac{1}{|{\mathbf{d}}_{g,s_i}|} {\mathbf{d}}_{g,s_i}, \quad {\mathbf{t}}_{s_i} = {\mathbf{t}} = [-n_1, n_0]\tp\]</div>
<p>The vectors <span class="math notranslate nohighlight">\({\mathbf{t}}_{s_i}\)</span> and <span class="math notranslate nohighlight">\({\mathbf{n}}_{s_i}\)</span> define the local (contact) frame for further computations.</p>
<p>The velocity at the closest point of the segment <span class="math notranslate nohighlight">\(s_i\)</span> is interpolated using <span class="math notranslate nohighlight">\(\rho\)</span> and computed as</p>
<div class="math notranslate nohighlight">
\[\dot {\mathbf{p}}_p = (1-\rho) \cdot {\mathbf{v}}_i + \rho \cdot {\mathbf{v}}_{i+1}\]</div>
<p>Alternatively, <span class="math notranslate nohighlight">\(\dot {\mathbf{p}}_p\)</span> could be computed from the cable element by evaluating the velocity at the contact points, but we feel that
this choice is more consistent with the computations at position level.</p>
<p>The gap velocity <span class="math notranslate nohighlight">\(v_n\)</span> (<span class="math notranslate nohighlight">\(\neq \dot g\)</span>) thus reads</p>
<div class="math notranslate nohighlight">
\[v_n = \left( \dot {\mathbf{p}}_p - \dot {\mathbf{p}}_{m0} \right) {\mathbf{n}}\]</div>
<p>In a similar, the tangential velocity reads</p>
<div class="math notranslate nohighlight" id="equation-objectcontactfrictioncirclecable2d-vtangent">
<span class="eqno">(80)<a class="headerlink" href="#equation-objectcontactfrictioncirclecable2d-vtangent" title="Link to this equation"></a></span>\[v_t = \left( \dot {\mathbf{p}}_p - \dot {\mathbf{p}}_{m0} \right) {\mathbf{t}}\]</div>
<p>In case of <code class="docutils literal notranslate"><span class="pre">frictionStiffness</span> <span class="pre">!=</span> <span class="pre">0</span></code>, we continuously track the sticking position at which the cable element (or segment) and the circle
previously sticked together, similar as proposed by Lugr{'i}s et al.~.
The difference here to the latter reference, is that we explicitly exclude switching from Newton’s method and that Lugr{'i}s et al.~used
contact points, while we use linear segments.
For a simple 1D example using this position based approach for friction, see <code class="docutils literal notranslate"><span class="pre">Examples/lugreFrictionText.py</span></code>,
which compares the traditional LuGre friction model  with the position based model with tangential stiffness.</p>
<figure class="align-default" id="id3">
<span id="fig-objectcontactfrictioncirclecable2d-stickingpos"></span><a class="reference internal image-reference" href="../../../_images/ContactFrictionCircleCable2DstickingPos.png"><img alt="../../../_images/ContactFrictionCircleCable2DstickingPos.png" src="../../../_images/ContactFrictionCircleCable2DstickingPos.png" style="width: 600px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 44 </span><span class="caption-text">Calculation of last sticking position; blue parts mark the sticking position calculated as <span class="math notranslate nohighlight">\(x^*_{curStick}\)</span>.</span><a class="headerlink" href="#id3" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Because there is the chance to wind/unwind relative to the (last) sticking position without slipping,
the following strategy is used.
In case of sliding (which could be the last time sliding before sticking),
we compute the <strong>current sticking position</strong>, see <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-stickingpos"><span class="std std-numref">Fig. 44</span></a>, as the sum of the relative position at the segment <span class="math notranslate nohighlight">\(s\)</span></p>
<div class="math notranslate nohighlight">
\[x_{s,curStick} = \rho \cdot L_{seg}\]</div>
<p>in which <span class="math notranslate nohighlight">\(\rho \in [0,1]\)</span> denotes the relative position of contact at the segment with reference length <span class="math notranslate nohighlight">\(L_{seg}=\frac{L}{n_{cs}}\)</span>.
The relative position at the circle <span class="math notranslate nohighlight">\(c\)</span> is</p>
<div class="math notranslate nohighlight">
\[x_{c,curStick} = \alpha \cdot r\]</div>
<p>We immediately see, that under pure rolling(neglecting the effects of small penetration, usually much smaller than shown for visibility in <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-stickingpos"><span class="std std-numref">Fig. 44</span></a>.),</p>
<div class="math notranslate nohighlight">
\[x_{s,curStick} + x_{c,curStick}  = \mathrm{const}.\]</div>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">verticalOffset</span></code> from the cable center line, as defined in the related <code class="docutils literal notranslate"><span class="pre">MarkerBodyCable2DShape</span></code>,
influences the behavior significantly, which is why we recommend to use <code class="docutils literal notranslate"><span class="pre">verticalOffset=0</span></code> whenever this is an
appropriate assumption.
Thus, the current sticking position <span class="math notranslate nohighlight">\(x_{curStick}\)</span> is computed per segment as</p>
<div class="math notranslate nohighlight" id="equation-objectcontactfrictioncirclecable2d-lastcurstick">
<span class="eqno">(81)<a class="headerlink" href="#equation-objectcontactfrictioncirclecable2d-lastcurstick" title="Link to this equation"></a></span>\[x^*_{curStick} = x_{s,curStick} + x_{c,curStick}, \quad\]</div>
<p>Due to the possibility of switching of <span class="math notranslate nohighlight">\(\alpha+\phi\)</span> between <span class="math notranslate nohighlight">\(-\pi\)</span> and <span class="math notranslate nohighlight">\(\pi\)</span>, the result is normalized to</p>
<div class="math notranslate nohighlight" id="equation-objectcontactfrictioncirclecable2d-curstick">
<span class="eqno">(82)<a class="headerlink" href="#equation-objectcontactfrictioncirclecable2d-curstick" title="Link to this equation"></a></span>\[x_{curStick} = x^*_{curStick} - \mathrm{floor}\left(\frac{x^*_{curStick} }{2 \pi \cdot r} + \frac{1}{2}\right) \cdot 2 \pi \cdot r, \quad\]</div>
<p>which gives <span class="math notranslate nohighlight">\(\bar x_{curStick} \in [-\pi \cdot r,\pi \cdot r]\)</span>, which is stored in the 3rd data variable (per segment).
The function floor() is a standardized version of rounding, available in C and Python programming languages.
In the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>, the last sticking position is computed, <span class="math notranslate nohighlight">\(x_{lastStick} = x_{curStick}\)</span>, and it is also available in the <code class="docutils literal notranslate"><span class="pre">startOfStep</span></code> state.</p>
</section>
<section id="contact-forces-definition">
<h2>Contact forces: definition<a class="headerlink" href="#contact-forces-definition" title="Link to this heading"></a></h2>
<p>The contact force <span class="math notranslate nohighlight">\(f_n\)</span> is zero for <span class="math notranslate nohighlight">\(g &gt; 0\)</span> and otherwise computed from</p>
<div class="math notranslate nohighlight" id="equation-objectcontactfrictioncirclecable2d-contactforce">
<span class="eqno">(83)<a class="headerlink" href="#equation-objectcontactfrictioncirclecable2d-contactforce" title="Link to this equation"></a></span>\[f_n = k_c \cdot g + d_c \cdot v_n\]</div>
<p>NOTE that currently, there is only a linear spring-damper model available, assuming that the impact dynamics
is not dominating (such as in belt drives or reeving systems).</p>
<p>Friction forces are primarily based on relative (tangential) velocity at each segment.
The ‘linear’ friction force, based on the velocity penalty parameter <span class="math notranslate nohighlight">\(\mu_v\)</span> reads</p>
<div class="math notranslate nohighlight">
\[f_t^{(lin)} = \mu_v \cdot v_t ,\]</div>
</section>
<section id="postnewtonstep">
<h2>PostNewtonStep<a class="headerlink" href="#postnewtonstep" title="Link to this heading"></a></h2>
<p>In general, see the solver flow chart for the <code class="docutils literal notranslate"><span class="pre">DiscontinuousIteration</span></code>, see <a class="reference internal" href="../GeneralSolverStructure.html#fig-solver-discontinuous-iteration"><span class="std std-numref">Fig. 34</span></a>, should be considered when reading this description. Every step is started with values <code class="docutils literal notranslate"><span class="pre">startOfStep</span></code>, while current values are iterated and updated in the Newton or <code class="docutils literal notranslate"><span class="pre">DiscontinuousIteration</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> computes 3 values per segment, which are used for computation of contact forces, irrespectively of the
current geometryof the contact.
The <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> is called after every full Newton method and evaluates the current state w.r.t. the assumed data variables.
If the assumptions do not fit, new data variables are computed.
This is necessary in order to avoid discontinuities in the equations, while otherwise the Newton iterations would not
(or only slowly) converge.</p>
<p>The data variables per segment are</p>
<div class="math notranslate nohighlight">
\[[x_{gap},\, x_{isSlipStick},\, x_{lastStick}]\]</div>
<p>Here, <span class="math notranslate nohighlight">\(x_{gap}\)</span> contains the gap of the segment (<span class="math notranslate nohighlight">\(\le 0\)</span> means contact), <span class="math notranslate nohighlight">\(x_{lastStick}\)</span> is described in
Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-curstick">(82)</a>, and
<span class="math notranslate nohighlight">\(x_{isSlipStick}\)</span> defines the stick or slip case,</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(x_{isSlipStick} = -2\)</span>: undefined, used for initialization</p></li>
<li><p><span class="math notranslate nohighlight">\(x_{isSlipStick} = 0\)</span>: sticking</p></li>
<li><p><span class="math notranslate nohighlight">\(x_{isSlipStick} = \pm 1\)</span>: slipping, sign defines slipping direction</p></li>
</ul>
<p>The basic algorithm in the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>, with all operations given for any segment <span class="math notranslate nohighlight">\(s_i\)</span>, can be summarized as follows:</p>
<ul class="simple">
<li><dl class="simple">
<dt>[I.] Evaluate gap per segment <span class="math notranslate nohighlight">\(g\)</span> using Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-gap">(79)</a> and store in data variable:</dt><dd><p><span class="math notranslate nohighlight">\(x_{gap} = g\)</span></p>
</dd>
</dl>
</li>
<li><p>[II.] If <span class="math notranslate nohighlight">\(x_{gap} &lt; 0\)</span> and (<span class="math notranslate nohighlight">\(\mu_v \neq 0\)</span> or  <span class="math notranslate nohighlight">\(\mu_k \neq 0\)</span>):</p></li>
<li><p>Compute contact force <span class="math notranslate nohighlight">\(f_n\)</span> according to Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-contactforce">(83)</a></p></li>
<li><p>Compute current sticking position <span class="math notranslate nohighlight">\(x_{curStick}\)</span> according to Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-lastcurstick">(81)</a>(terms are only evaluated if <span class="math notranslate nohighlight">\(\mu_k \neq 0\)</span>)</p></li>
<li><dl class="simple">
<dt>Retrieve <code class="docutils literal notranslate"><span class="pre">startOfStep</span></code> sticking position(Importantly, the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> always refers to the <code class="docutils literal notranslate"><span class="pre">startOfStep</span></code> state in the sticking position, because in the discontinuous iterations, the algorithm could switch to slipping in between and override the last sticking position in the current step) in <span class="math notranslate nohighlight">\(x^{startOfStep}_{lastStick}\)</span> and compute and normalize</dt><dd><p>difference in sticking position(in case that <span class="math notranslate nohighlight">\(x_{isSlipStick} = -2\)</span>, meaning that there is no stored sticking position, we set <span class="math notranslate nohighlight">\(\Delta x_{stick} = 0\)</span>):</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\Delta x^*_{stick} = x_{curStick} - x^{startOfStep}_{lastStick}, \quad \Delta x_{stick} = \Delta x^*_{stick} - \mathrm{floor}\left(\frac{\Delta x^*_{stick} }{2 \pi \cdot r} + \frac{1}{2}\right) \cdot 2 \pi \cdot r\]</div>
<ul class="simple">
<li><p>Compute linear tangential force for friction stiffness and velocity penalty:</p></li>
</ul>
<div class="math notranslate nohighlight">
\[f_{t,lin} = \mu_v \cdot v_t + \mu_k \Delta x_{stick}\]</div>
<ul class="simple">
<li><dl class="simple">
<dt>Compute tangential force according to Coulomb friction model (note that the sign of <span class="math notranslate nohighlight">\(\Delta x_{stick}\)</span> is used here, but</dt><dd><p>alternatively we may also use the sign of <span class="math notranslate nohighlight">\(f_{t,lin}\)</span>):</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[\begin{split}f_t = \begin{cases} f_t^{(lin)}, \quad \quad \quad \quad \quad \quad \quad \mathrm{if} \quad |f_t^{(lin)}| \le \mu \cdot |f_n| \\ \mu \cdot |f_n| \cdot \mathrm{Sign}(\Delta x_{stick}), \quad \mathrm{else} \end{cases}\end{split}\]</div>
<ul class="simple">
<li><dl class="simple">
<dt>In the case of slipping, given by <span class="math notranslate nohighlight">\(|f_t^{(lin)}| &gt; \mu \cdot |f_n|\)</span>, we update the last sticking position in the data variable,</dt><dd><p>such that the spring is pre-tensioned already,</p>
</dd>
</dl>
</li>
</ul>
<div class="math notranslate nohighlight">
\[x_{lastStick} = x_{curStick} - \mathrm{Sign}(\Delta x_{stick}) \frac{\mu \cdot |f_n|}{\mu_k}, \quad x_{isSlipStick} = \mathrm{Sign}(\Delta x_{stick})\]</div>
<ul>
<li><dl>
<dt>In the case of sticking, given by <span class="math notranslate nohighlight">\(|f_t^{(lin)}| \le \mu \cdot |f_n|\)</span><span class="classifier">Set <span class="math notranslate nohighlight">\(x_{isSlipStick} = 0\)</span> and,</span></dt><dd><p>if <span class="math notranslate nohighlight">\(x^{startOfStep}_{isSlipStick} = -2\)</span> (undefined), we update <span class="math notranslate nohighlight">\(x_{lastStick} = x_{curStick}\)</span>, while otherwise, <span class="math notranslate nohighlight">\(x_{lastStick}\)</span> is unchanged.</p>
</dd>
</dl>
</li>
<li><p>[III. ] If <span class="math notranslate nohighlight">\(x_{gap} &gt; 0\)</span> or (<span class="math notranslate nohighlight">\(\mu_v == 0\)</span> and <span class="math notranslate nohighlight">\(\mu_k == 0\)</span>), we set <span class="math notranslate nohighlight">\(x_{isSlipStick} = -2\)</span> (undefined); this means that in the next step (if this step is accepted), there is no stored sticking position.</p></li>
<li><dl class="simple">
<dt>[IV.] Compute an error <span class="math notranslate nohighlight">\(\varepsilon_{PNS} = \varepsilon^n_{PNS}+\varepsilon^t_{PNS}\)</span>,</dt><dd><p>with physical units forces (per segment point), for <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>:</p>
</dd>
</dl>
</li>
<li><p>if gap <span class="math notranslate nohighlight">\(x_{gap,lastPNS}\)</span> of previous <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> had different sign to current gap, set</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\varepsilon^n_{PNS} = k_c \cdot \Vert x_{gap} - x_{gap,lastPNS}\Vert\]</div>
<p>while otherwise <span class="math notranslate nohighlight">\(\varepsilon^n_{PNS}=0\)</span>.
+  if stick-slip-state <span class="math notranslate nohighlight">\(x_{isSlipStick,lastPNS}\)</span> of previous <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> is different from current <span class="math notranslate nohighlight">\(x_{isSlipStick}\)</span>, set</p>
<div class="math notranslate nohighlight">
\[\varepsilon^t_{PNS} = \Vert \left(\Vert f_t^{(lin)} \Vert  - \mu \cdot |f_n| \right)\Vert\]</div>
<p>while otherwise <span class="math notranslate nohighlight">\(\varepsilon^t_{PNS}=0\)</span>.</p>
<p>Note that the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> is iterated and the data variables are updated continuously until convergence, or until a max.number of iterations is reached. If <code class="docutils literal notranslate"><span class="pre">ignoreMaxIterations</span></code> == 0, computation will continue even if no convergence is reached after the given number of iterations. This will lead so larger errors in such steps, but may have less influence on the overall solution if such cases are rare.</p>
</section>
<section id="computation-of-connector-forces-in-newton">
<h2>Computation of connector forces in Newton<a class="headerlink" href="#computation-of-connector-forces-in-newton" title="Link to this heading"></a></h2>
<p>The computation of LHS terms, the action of forces produced by the contact-friction element, is done during Newton iterations and may not have
discontinuous behavior, thus relating computations to data variables computed in the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>.
For efficiency, the LHS computation is only performed, if the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> determined contact in any segment.</p>
<p>The operations are similar to the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>, but without switching. The following operations are performed for each segment <span class="math notranslate nohighlight">\(s_i\)</span>, if
<span class="math notranslate nohighlight">\(x_{gap, s_i} &lt;= 0\)</span>:</p>
<ul class="simple">
<li><p>[I.] Compute contact force <span class="math notranslate nohighlight">\(f_n\)</span>, Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-contactforce">(83)</a>.</p></li>
<li><p>[II.] In case of sticking (<span class="math notranslate nohighlight">\(|x_{isSlipStick}|\neq 1\)</span>):</p></li>
<li><p>[II.1] the current sticking position <span class="math notranslate nohighlight">\(x_{curStick}\)</span> is computed from Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-lastcurstick">(81)</a>, and the difference of current and last sticking position reads(see the difference to the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>: we use <span class="math notranslate nohighlight">\(x_{lastStick}\)</span> here, not the <code class="docutils literal notranslate"><span class="pre">startOfStep</span></code> variant.):</p></li>
</ul>
<div class="math notranslate nohighlight">
\[\Delta x^*_{stick} = x_{curStick} - x_{lastStick}, \quad \Delta x_{stick} = x^*_{stick} - \mathrm{floor}\left(\frac{\Delta x^*_{stick} }{2 \pi \cdot r} + \frac{1}{2}\right) \cdot 2 \pi \cdot r\]</div>
<ul class="simple">
<li><p>[II.2] if the friction stiffness is <span class="math notranslate nohighlight">\(\mu_k==0\)</span> or if <span class="math notranslate nohighlight">\(x_{isSlipStick} == -2\)</span>, we set <span class="math notranslate nohighlight">\(\Delta x_{stick}=0\)</span></p></li>
<li><p>[II.3] using the tangential velocity from Eq. <a class="reference internal" href="#equation-objectcontactfrictioncirclecable2d-vtangent">(80)</a>, the tangent force follows as (even if it is larger than the sticking limit)</p></li>
</ul>
<div class="math notranslate nohighlight">
\[f_t = \mu_v \cdot v_t + \mu_k \Delta x_{stick}\]</div>
<ul class="simple">
<li><p>[III.] In case of slipping (<span class="math notranslate nohighlight">\(|x_{isSlipStick}|=1\)</span>), the tangential firction force is set  as(see again difference to <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code>!),</p></li>
</ul>
<div class="math notranslate nohighlight">
\[f_t = \mu \cdot |f_n| \cdot x_{isSlipStick}, \quad \mathrm{else}\]</div>
<p>Note that in the Newton method, the tangential force may be inconsistent with the Kuhn-Tucker conditions. However,
the <code class="docutils literal notranslate"><span class="pre">PostNewtonStep</span></code> resolves this inconsistency.</p>
</section>
<section id="computation-of-lhs-terms-for-circle-and-ancf-cable-element">
<h2>Computation of LHS terms for circle and ANCF cable element<a class="headerlink" href="#computation-of-lhs-terms-for-circle-and-ancf-cable-element" title="Link to this heading"></a></h2>
<p>If <code class="docutils literal notranslate"><span class="pre">activeConnector</span> <span class="pre">=</span> <span class="pre">True</span></code>,
contact forces <span class="math notranslate nohighlight">\({\mathbf{f}}_i\)</span> with <span class="math notranslate nohighlight">\(i \in [0,n_{cs}]\)</span> – these are <span class="math notranslate nohighlight">\((n_{cs}+1)\)</span> forces – are applied at the points <span class="math notranslate nohighlight">\(p_i\)</span>, and they are computed for every contact segments (i.e., two segments may contribute to contact forces of one point).
For every contact computation, first all contact forces at segment points are set to zero.
We distinguish two cases SN and PWN. If <code class="docutils literal notranslate"><span class="pre">useSegmentNormals==True</span></code>, we use the SN case, while otherwise the PWN case is used,
compare <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-normals"><span class="std std-numref">Fig. 45</span></a>.</p>
<figure class="align-default" id="id4">
<span id="fig-objectcontactfrictioncirclecable2d-normals"></span><a class="reference internal image-reference" href="../../../_images/ContactFrictionCircleCable2Dnormals.png"><img alt="../../../_images/ContactFrictionCircleCable2Dnormals.png" src="../../../_images/ContactFrictionCircleCable2Dnormals.png" style="width: 700px;" />
</a>
<figcaption>
<p><span class="caption-number">Fig. 45 </span><span class="caption-text">Choice of normals and tangent vectors for calculation of normal contact forces and tangential (friction) forces; note that the <code class="docutils literal notranslate"><span class="pre">useSegmentNormals=False</span></code> is not appropriate for this setup and would produce highly erroneous forces.</span><a class="headerlink" href="#id4" title="Link to this image"></a></p>
</figcaption>
</figure>
<p>Segment normals (=SN) lead to always good approximations for normal directions, irrespectively of short or extremely long segments as compared to the circle. However, in case of segments that are short as compared to the circle radius, normals computed from the center of the circle to the segment points (=PWN) are more consistent and produce tangents only in circumferential direction, which may improve behavior in some applications. The equations for the two cases read:</p>
<blockquote>
<div><p><strong>CASE SN</strong>: use <strong>S</strong>egment <strong>N</strong>ormals</p>
</div></blockquote>
<p>If there is contact in a segment <span class="math notranslate nohighlight">\(s_i\)</span>, i.e., gap state <span class="math notranslate nohighlight">\(x_{gap} \le 0\)</span>, see <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-sketch"><span class="std std-numref">Fig. 43</span></a>(right), contact forces <span class="math notranslate nohighlight">\({\mathbf{f}}_{s_i}\)</span> are computed per segment,</p>
<div class="math notranslate nohighlight">
\[{\mathbf{f}}_{s_i} = f_n \cdot {\mathbf{n}}_{s_i} + f_t {\mathbf{t}}_{s_i}\]</div>
<p>and added to every force at segment points according to</p>
<div class="math notranslate nohighlight">
\[\begin{split}{\mathbf{f}}_i &amp;\pluseq&amp; (1-\rho) \cdot {\mathbf{f}}_{s_i}      \\
\nonumber {\mathbf{f}}_{i+1} &amp;\pluseq&amp; \rho \cdot {\mathbf{f}}_{s_i}\end{split}\]</div>
<dl class="simple">
<dt>while in case <span class="math notranslate nohighlight">\(x_{gap}  &gt; 0\)</span> nothing is added.</dt><dd><p><strong>CASE PWN</strong>: use <strong>P</strong>oint <strong>W</strong>ise <strong>N</strong>ormals (at segment points)</p>
</dd>
</dl>
<p>If there is contact in a segment <span class="math notranslate nohighlight">\(s_i\)</span>, i.e., gap <span class="math notranslate nohighlight">\(x_{gap} \le 0\)</span>,
see <a class="reference internal" href="#fig-objectcontactfrictioncirclecable2d-sketch"><span class="std std-numref">Fig. 43</span></a>(right),
intermediate contact forces <span class="math notranslate nohighlight">\({\mathbf{f}}^{l,r}_{i}\)</span> are computed per segment point,</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned} {\mathbf{f}}^l = f_n \cdot {\mathbf{n}}_{l,s_i} + f_t {\mathbf{t}}_{l,s_i}, \quad {\mathbf{f}}^r = f_n \cdot {\mathbf{n}}_{r,s_i} + f_t {\mathbf{t}}_{r,s_i}\\
in which \ :math:`{\mathbf{n}}_{l,s_i}`\  is the vector from circle center to the left point (\ :math:`i`\ ) of the segment \ :math:`s_i`\ ,
and \ :math:`{\mathbf{n}}_{l,s_i}`\  to the right point (\ :math:`i+1`\ ). The tangent vectors are perpendicular to the normals.
The forces are then applied to the contact forces \ :math:`{\mathbf{f}}_i`\  using the parameter \ :math:`\rho`\ , which takes into account the distance of contact to the left or right side of the segment,\end{aligned}\end{align} \]</div>
<div class="math notranslate nohighlight">
\[\begin{split}{\mathbf{f}}_i &amp;\pluseq&amp; (1-\rho) \cdot {\mathbf{f}}^l      \\
\nonumber {\mathbf{f}}_{i+1} &amp;\pluseq&amp; \rho \cdot {\mathbf{f}}^r\end{split}\]</div>
<p>while in case <span class="math notranslate nohighlight">\(x_{gap}  &gt; 0\)</span> nothing is added.</p>
<p>The forces <span class="math notranslate nohighlight">\({\mathbf{f}}_i\)</span> are then applied through the marker to the <code class="docutils literal notranslate"><span class="pre">ObjectANCFCable2D</span></code> element as point loads via a position jacobian
(using the according access function), for details see the C++ implementation.</p>
<p>The forces on the circle marker <span class="math notranslate nohighlight">\(m0\)</span> are computed as the total sum of all
segment contact forces,</p>
<div class="math notranslate nohighlight">
\[{\mathbf{f}}_{m0} = -\sum_{s_i} {\mathbf{f}}_{s_i}\]</div>
<p>and additional torques on the circle’s rotation simply follow from</p>
<div class="math notranslate nohighlight">
\[\tau_{m0} = -\sum_{s_i} r \cdot f_{t_{s_i}} .\]</div>
<p>During Newton iterations, the contact forces for segment <span class="math notranslate nohighlight">\(s_i\)</span> are considered only, if
<span class="math notranslate nohighlight">\(x_i &lt;= 0\)</span>. The dataCoordinate <span class="math notranslate nohighlight">\(x_i\)</span> is not modified during Newton iterations, but computed
during the DiscontinuousIteration, see <a class="reference internal" href="../GeneralSolverStructure.html#fig-solver-discontinuous-iteration"><span class="std std-numref">Fig. 34</span></a> in the solver description.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">activeConnector</span> <span class="pre">=</span> <span class="pre">False</span></code>, all contact and friction forces on the cable and the force and torque on the
circle’s marker are set to zero.</p>
<p>Relevant Examples and TestModels with weblink:</p>
<blockquote>
<div><p><a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveALE.py">beltDriveALE.py</a> (Examples/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDriveReevingSystem.py">beltDriveReevingSystem.py</a> (Examples/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/beltDrivesComparison.py">beltDrivesComparison.py</a> (Examples/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/sliderCrank3DwithANCFbeltDrive.py">sliderCrank3DwithANCFbeltDrive.py</a> (Examples/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/Examples/sliderCrank3DwithANCFbeltDrive2.py">sliderCrank3DwithANCFbeltDrive2.py</a> (Examples/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFcontactFrictionTest.py">ANCFcontactFrictionTest.py</a> (TestModels/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFmovingRigidBodyTest.py">ANCFmovingRigidBodyTest.py</a> (TestModels/), <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/main/pythonDev/TestModels/ANCFslidingAndALEjointTest.py">ANCFslidingAndALEjointTest.py</a> (TestModels/)</p>
</div></blockquote>
<p><strong>The web version may not be complete. For details, consider also the Exudyn PDF documentation</strong> : <a class="reference external" href="https://github.com/jgerstmayr/EXUDYN/blob/master/docs/theDoc/theDoc.pdf">theDoc.pdf</a></p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="ObjectContactCircleCable2D.html" class="btn btn-neutral float-left" title="ObjectContactCircleCable2D" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="ObjectContactSphereSphere.html" class="btn btn-neutral float-right" title="ObjectContactSphereSphere" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>