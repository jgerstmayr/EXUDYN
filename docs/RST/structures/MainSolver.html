<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>MainSolverStatic &mdash; Exudyn1.7.118.dev1 1.7.118.dev1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=82a976d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/rtd_sphinx_search.min.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css?v=e11081fd" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=551d1ecc"></script>
        <script src="../../../_static/doctools.js?v=888ff710"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../../_static/js/rtd_search_config.js"></script>
        <script src="../../../_static/js/rtd_sphinx_search.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Structures for structural elements" href="PyStructuralElementsDataStructures.html" />
    <link rel="prev" title="Solver substructures" href="CSolverStructures.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            Exudyn1.7.118.dev1
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Exudyn User Manual</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Exudyn.html">Exudyn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../InstallationAndGettingStartedIndex.html">Installation and Getting Started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../OverviewOnExudynIndex.html">Overview on Exudyn</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TutorialIndex.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../GraphicsAndVisualizationIndex.html">Graphics and visualization</a></li>
<li class="toctree-l1"><a class="reference internal" href="../NotationIndex.html">Notation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TheoryAndFormulationsIndex.html">Theory and formulations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../SolversIndex.html">Solvers</a></li>
<li class="toctree-l1"><a class="reference internal" href="../cInterface/CInterfaceIndex.html">Python-C++ command interface</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference Manual</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../pythonUtilities/index.html">Python Utility Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../items/itemsIndex.html">Items reference manual</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="StructuresAndSettingsIndex.html">Structures and Settings</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="SimulationSettings.html">Simulation settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="VisualizationSettings.html">Visualization settings</a></li>
<li class="toctree-l2"><a class="reference internal" href="CSolverStructures.html">Solver substructures</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">MainSolverStatic</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mainsolverimplicitsecondorder">MainSolverImplicitSecondOrder</a></li>
<li class="toctree-l2"><a class="reference internal" href="#mainsolverexplicit">MainSolverExplicit</a></li>
<li class="toctree-l2"><a class="reference internal" href="PyStructuralElementsDataStructures.html">Structures for structural elements</a></li>
<li class="toctree-l2"><a class="reference internal" href="BeamSectionGeometry.html">BeamSectionGeometry</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Misc</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../Abbreviations.html">List of Abbreviations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../ExamplesIndex.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../TestModelsIndex.html">TestModels</a></li>
<li class="toctree-l1"><a class="reference internal" href="../trackerlog.html">Issue tracker</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">Exudyn1.7.118.dev1</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="StructuresAndSettingsIndex.html">Structures and Settings</a></li>
      <li class="breadcrumb-item active">MainSolverStatic</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/docs/RST/structures/MainSolver.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="mainsolverstatic">
<span id="sec-mainsolverstatic"></span><h1>MainSolverStatic<a class="headerlink" href="#mainsolverstatic" title="Link to this heading"></a></h1>
<p>PyBind interface (trampoline) class for static solver. With this interface, the static solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(…), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">MainSolverStatic()</span></code></p>
</div></blockquote>
<p>and hereafter you can access all data and functions via ‘solver’.</p>
<p>MainSolverStatic has the following items:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>conv</strong> [type = SolverConvergenceData]:</div>
<div class="line">all information about tolerances, errors and residua</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>it</strong> [type = SolverIterationData]:</div>
<div class="line">all information about iterations (steps, discontinuous iteration, newton,…)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>newton</strong> [type = NewtonSettings]:</div>
<div class="line">copy of newton settings from timeint or staticSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>output</strong> [type = SolverOutputData]:</div>
<div class="line">output modes and timers for exporting solver information and solution</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>timer</strong> [type = CSolverTimer]:</div>
<div class="line">timer which measures the CPU time of solver sub functions</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>CheckInitialized(mainSystem)</strong> [return type = bool]:</div>
<div class="line">check if MainSolver and MainSystem are correctly initialized ==&gt; otherwise raise SysError</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeAlgebraicEquations(mainSystem, velocityLevel=False)</strong> [return type = void]:</div>
<div class="line">compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianAE(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., velocityLevel=False)</strong> [return type = void]:</div>
<div class="line">add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianODE1RHS(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1.)</strong> [return type = void]:</div>
<div class="line">ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(…); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianODE2RHS(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., computeLoadsJacobian=0)</strong> [return type = void]:</div>
<div class="line">set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeLoadFactor(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">for static solver, this is a factor in interval [0,1]; MUST be overwritten</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeMassMatrix(mainSystem, scalarFactor=1.)</strong> [return type = void]:</div>
<div class="line">compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonJacobian(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">compute jacobian for newton method of given solver method; store result in systemJacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonResidual(mainSystem, simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonUpdate(mainSystem, simulationSettings, initial=True)</strong> [return type = void]:</div>
<div class="line">compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeODE2RHS(mainSystem)</strong> [return type = void]:</div>
<div class="line">compute the RHS of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in systemResidual in range(0,nODE2)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>DiscontinuousIteration(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinalizeSolver(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write concluding information (timer statistics, messages) and close files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinishStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">finish static step / time step; write output of results to file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetAEsize()</strong> [return type = Index]:</div>
<div class="line">number of algebraic equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetDataSize()</strong> [return type = Index]:</div>
<div class="line">number of data (history) variables in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetErrorString()</strong> [return type = std::string]:</div>
<div class="line">return error string if solver has not been successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetNewtonSolution()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed solution (=increment) of Newton</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE1size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode1"><span class="std std-ref">ODE1</span></a> equations in solver (not yet implemented)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE2size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSimulationEndTime(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute simulation end time (depends on static or time integration solver)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSolverName()</strong> [return type = std::string]:</div>
<div class="line">get solver name - needed for output file header and visualization window</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemJacobian()</strong> [return type = NumpyMatrix]:</div>
<div class="line">get locally stored / last computed system jacobian of solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemMassMatrix()</strong> [return type = NumpyMatrix]:</div>
<div class="line">get locally stored / last computed mass matrix of solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemResidual()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed system residual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>HasAutomaticStepSizeControl(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">return true, if solver supports automatic stepsize control, otherwise false</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IncreaseStepSize(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">increase step size if convergence is good</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolver(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverData(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize all data,it,conv; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverInitialConditions(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">set/compute initial conditions (solver-specific!); called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverOutput(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize output files; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverPreChecks(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">check if system is solvable; initialize dense/sparse computation modes</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize static step / time step; Python-functions; do some outputs, checks, etc.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsStaticSolver()</strong> [return type = bool]:</div>
<div class="line">return true, if static solver; needs to be overwritten in derived class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsVerboseCheck(level)</strong> [return type = bool]:</div>
<div class="line">return true, if file or console output is at or above the given level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>loadStepGeometricFactor</strong> [type = Real]:</div>
<div class="line">multiplicative load step factor; this factor is computed from loadStepGeometric parameters in SolveSystem(…)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>Newton(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform Newton method for given solver method</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PostInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">post-initialize for solver specific tasks; called at the end of InitializeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PreInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ReduceStepSize(mainSystem, simulationSettings, severity)</strong> [return type = bool]:</div>
<div class="line">reduce step size (1..normal, 2..severe problems); return true, if reduction was successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemJacobian(systemJacobian)</strong> [return type = void]:</div>
<div class="line">set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemMassMatrix(systemMassMatrix)</strong> [return type = void]:</div>
<div class="line">set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemResidual(systemResidual)</strong> [return type = void]:</div>
<div class="line">set locally stored system residual; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSteps(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">main solver part: calls multiple InitializeStep(…)/ DiscontinuousIteration(…)/ FinishStep(…); do step reduction if necessary; return true if success, false else</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSystem(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">solve System: InitializeSolver, SolveSteps, FinalizeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>UpdateCurrentTime(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">update currentTime (and load factor); MUST be overwritten in special solver class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>VerboseWrite(level, str)</strong> [return type = void]:</div>
<div class="line">write to console and/or file in case of level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteCoordinatesToFile(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique coordinates solution file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteSolutionFileHeader(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique file header, depending on static/ dynamic simulation</div>
</div>
</li>
</ul>
</section>
<section id="mainsolverimplicitsecondorder">
<span id="sec-mainsolverimplicitsecondorder"></span><h1>MainSolverImplicitSecondOrder<a class="headerlink" href="#mainsolverimplicitsecondorder" title="Link to this heading"></a></h1>
<p>PyBind interface (trampoline) class for dynamic implicit solver. Note that this solver includes the classical Newmark method (set useNewmark True; with option of index 2 reduction) as well as the generalized-alpha method. With the interface, the dynamic implicit solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(…), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (still fast, but performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">MainSolverImplicitSecondOrder()</span></code></p>
</div></blockquote>
<dl class="simple">
<dt>and hereafter you can access all data and functions via ‘solver’.</dt><dd><p>In this solver, user functions are possible to extend the solver at certain parts, while keeping the overal C++ performance. User functions, which are added with SetUserFunction…(…), have the arguments (MainSolver, MainSystem, simulationSettings), except for ComputeNewtonUpdate which adds the initial flag as an additional argument and ComputeNewtonResidual, which returns the scalar residual.</p>
</dd>
</dl>
<p>MainSolverImplicitSecondOrder has the following items:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>conv</strong> [type = SolverConvergenceData]:</div>
<div class="line">all information about tolerances, errors and residua</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>it</strong> [type = SolverIterationData]:</div>
<div class="line">all information about iterations (steps, discontinuous iteration, newton,…)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>newton</strong> [type = NewtonSettings]:</div>
<div class="line">copy of newton settings from timeint or staticSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>output</strong> [type = SolverOutputData]:</div>
<div class="line">output modes and timers for exporting solver information and solution</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>timer</strong> [type = CSolverTimer]:</div>
<div class="line">timer which measures the CPU time of solver sub functions; note that solver structures can only be written indirectly, e.g.,  timer=dynamicSolver.timer; timer.useTimer = False; dynamicSolver.timer=timer; however, dynamicSolver.timer.useTimer cannot be written.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>alphaF</strong> [type = Real]:</div>
<div class="line">copy of parameter in timeIntegration.generalizedAlpha</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>alphaM</strong> [type = Real]:</div>
<div class="line">copy of parameter in timeIntegration.generalizedAlpha</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>CheckInitialized(mainSystem)</strong> [return type = bool]:</div>
<div class="line">check if MainSolver and MainSystem are correctly initialized ==&gt; otherwise raise SysError</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeAlgebraicEquations(mainSystem, velocityLevel=False)</strong> [return type = void]:</div>
<div class="line">compute the algebraic equations in systemResidual in range(nODE2+nODE1, nODE2+nODE1+nAE)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianAE(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., velocityLevel=False)</strong> [return type = void]:</div>
<div class="line">add jacobian of algebraic equations (multiplied with factor) to systemJacobian in cSolver; the scalarFactors are scaling the derivatives w.r.t. <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> coordinates, ODE2_t (velocity) coordinates and ODE1 coordinates; if velocityLevel == true, the constraints are evaluated at velocity level; the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianODE1RHS(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1.)</strong> [return type = void]:</div>
<div class="line">ADD jacobian of ODE1RHS (multiplied with factors for ODE2 and ODE1 coordinates) to the according rows (nODE2:nODE2+nODE1) of the exising systemJacobian in cSolver; it requires a prior call to ComputeJacobianODE2RHS(…); the scalar factors scalarFactor_ODE2=0 and scalarFactor_ODE2 are used for the same ODE2 block in the jacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeJacobianODE2RHS(mainSystem, scalarFactor_ODE2=1., scalarFactor_ODE2_t=0., scalarFactor_ODE1=1., computeLoadsJacobian=0)</strong> [return type = void]:</div>
<div class="line">set systemJacobian to zero, size = (nODE2+nODE1+nAE) x (nODE2+nODE1+nAE), and add jacobian (multiplied with factors for ODE2 and ODE1 coordinates) of ODE2RHS to systemJacobian in cSolver; using (scalarFactor_ODE2=-1,scalarFactor_ODE2=0) gives the stiffness matrix (=derivatives of ODE2 coords) in the nODE2 x nODE2 part, while using (scalarFactor_ODE2=0,scalarFactor_ODE2=-1) gives the damping matrix (= derivatives of ODE2 velocity coordinates) in the same part; a superposition of these two parts makes sense for implicit solvers; if , Index computeLoadsJacobian=0, loads are not considered in the Jacobian computation; for , Index computeLoadsJacobian=1 the ODE2 and ODE1 derivatives of loads are included and for , Index computeLoadsJacobian=2, also the ODE2_t dependencies are added</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeLoadFactor(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">for static solver, this is a factor in interval [0,1]; MUST be overwritten</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeMassMatrix(mainSystem, scalarFactor=1.)</strong> [return type = void]:</div>
<div class="line">compute systemMassMatrix (multiplied with factor) in cSolver and return mass nODE2 x nODE2 matrix</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonJacobian(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">compute jacobian for newton method of given solver method; store result in systemJacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonResidual(mainSystem, simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonUpdate(mainSystem, simulationSettings, initial=True)</strong> [return type = void]:</div>
<div class="line">compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeODE1RHS(mainSystem)</strong> [return type = void]:</div>
<div class="line">compute the RHS of <a class="reference internal" href="../Abbreviations.html#ode1"><span class="std std-ref">ODE1</span></a> equations in systemResidual in range(0,nODE1)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeODE2RHS(mainSystem)</strong> [return type = void]:</div>
<div class="line">compute the RHS of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in systemResidual in range(0,nODE2)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>DiscontinuousIteration(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>factJacAlgorithmic</strong> [type = Real]:</div>
<div class="line">locally computed parameter from generalizedAlpha parameters</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinalizeSolver(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write concluding information (timer statistics, messages) and close files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinishStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">finish static step / time step; write output of results to file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetAAlgorithmic()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed algorithmic accelerations</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetAEsize()</strong> [return type = Index]:</div>
<div class="line">number of algebraic equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetDataSize()</strong> [return type = Index]:</div>
<div class="line">number of data (history) variables in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetErrorString()</strong> [return type = std::string]:</div>
<div class="line">return error string if solver has not been successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetNewtonSolution()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed solution (=increment) of Newton</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE1size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode1"><span class="std std-ref">ODE1</span></a> equations in solver (not yet implemented)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE2size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSimulationEndTime(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute simulation end time (depends on static or time integration solver)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSolverName()</strong> [return type = std::string]:</div>
<div class="line">get solver name - needed for output file header and visualization window</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetStartOfStepStateAAlgorithmic()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed algorithmic accelerations at start of step</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemJacobian()</strong> [return type = NumpyMatrix]:</div>
<div class="line">get locally stored / last computed system jacobian of solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemMassMatrix()</strong> [return type = NumpyMatrix]:</div>
<div class="line">get locally stored / last computed mass matrix of solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemResidual()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed system residual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>HasAutomaticStepSizeControl(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">return true, if solver supports automatic stepsize control, otherwise false</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IncreaseStepSize(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">increase step size if convergence is good</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolver(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverData(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize all data,it,conv; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverInitialConditions(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">set/compute initial conditions (solver-specific!); called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverOutput(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize output files; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverPreChecks(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">check if system is solvable; initialize dense/sparse computation modes</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize static step / time step; Python-functions; do some outputs, checks, etc.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsStaticSolver()</strong> [return type = bool]:</div>
<div class="line">return true, if static solver; needs to be overwritten in derived class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsVerboseCheck(level)</strong> [return type = bool]:</div>
<div class="line">return true, if file or console output is at or above the given level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>newmarkBeta</strong> [type = Real]:</div>
<div class="line">copy of parameter in timeIntegration.generalizedAlpha</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>newmarkGamma</strong> [type = Real]:</div>
<div class="line">copy of parameter in timeIntegration.generalizedAlpha</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>Newton(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform Newton method for given solver method</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PostInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">post-initialize for solver specific tasks; called at the end of InitializeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PostNewton(mainSystem, simulationSettings)</strong> [return type = Real]:</div>
<div class="line">call PostNewton for all relevant objects (contact, friction, … iterations); returns error for discontinuous iteration</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PreInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ReduceStepSize(mainSystem, simulationSettings, severity)</strong> [return type = bool]:</div>
<div class="line">reduce step size (1..normal, 2..severe problems); return true, if reduction was successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemJacobian(systemJacobian)</strong> [return type = void]:</div>
<div class="line">set locally stored system jacobian of solver; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemMassMatrix(systemMassMatrix)</strong> [return type = void]:</div>
<div class="line">set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemResidual(systemResidual)</strong> [return type = void]:</div>
<div class="line">set locally stored system residual; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionComputeNewtonJacobian(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionComputeNewtonResidual(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionComputeNewtonUpdate(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionDiscontinuousIteration(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionFinishStep(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionInitializeStep(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionNewton(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionPostNewton(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetUserFunctionUpdateCurrentTime(mainSystem, userFunction)</strong> [return type = void]:</div>
<div class="line">set user function</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSteps(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">main solver part: calls multiple InitializeStep(…)/ DiscontinuousIteration(…)/ FinishStep(…); do step reduction if necessary; return true if success, false else</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSystem(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">solve System: InitializeSolver, SolveSteps, FinalizeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>spectralRadius</strong> [type = Real]:</div>
<div class="line">copy of parameter in timeIntegration.generalizedAlpha</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>UpdateCurrentTime(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">update currentTime (and load factor); MUST be overwritten in special solver class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>VerboseWrite(level, str)</strong> [return type = void]:</div>
<div class="line">write to console and/or file in case of level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteCoordinatesToFile(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique coordinates solution file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteSolutionFileHeader(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique file header, depending on static/ dynamic simulation</div>
</div>
</li>
</ul>
</section>
<section id="mainsolverexplicit">
<span id="sec-mainsolverexplicit"></span><h1>MainSolverExplicit<a class="headerlink" href="#mainsolverexplicit" title="Link to this heading"></a></h1>
<p>PyBind interface (trampoline) class for dynamic explicit solver. Note that this solver includes the 1st order explicit Euler scheme and the 4th order Runge-Kutta scheme with 5th order error estimation (DOPRI5). With the interface, the solver and its substructures can be accessed via Python. NOTE that except from SolveSystem(…), these functions are only intended for experienced users and they need to be handled with care, as unexpected crashes may happen if used inappropriate. Furthermore, the functions have a lot of overhead (still fast, but performance much lower than internal solver) due to Python interfaces, and should thus be used for small systems. To access the solver in Python, write</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">solver</span> <span class="pre">=</span> <span class="pre">MainSolverExplicit()</span></code></p>
</div></blockquote>
<dl class="simple">
<dt>and hereafter you can access all data and functions via ‘solver’.</dt><dd><p>In this solver, no user functions are possible, but you can use SolverImplicitSecondOrder instead (turning off Newton gives explicit scheme …).</p>
</dd>
</dl>
<p>MainSolverExplicit has the following items:</p>
<ul>
<li><div class="line-block">
<div class="line"><strong>conv</strong> [type = SolverConvergenceData]:</div>
<div class="line">all information about tolerances, errors and residua</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>it</strong> [type = SolverIterationData]:</div>
<div class="line">all information about iterations (steps, discontinuous iteration, newton,…)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>output</strong> [type = SolverOutputData]:</div>
<div class="line">output modes and timers for exporting solver information and solution</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>timer</strong> [type = CSolverTimer]:</div>
<div class="line">timer which measures the CPU time of solver sub functions</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeLoadFactor(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">for static solver, this is a factor in interval [0,1]; MUST be overwritten</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeMassMatrix(mainSystem, scalarFactor=1.)</strong> [return type = void]:</div>
<div class="line">compute systemMassMatrix (multiplied with factor) in cSolver and return mass matrix</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonJacobian(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">compute jacobian for newton method of given solver method; store result in systemJacobian</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonResidual(mainSystem, simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute residual for Newton method (e.g. static or time step); store residual vector in systemResidual and return scalar residual (specific computation may depend on solver types)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeNewtonUpdate(mainSystem, simulationSettings, initial=True)</strong> [return type = void]:</div>
<div class="line">compute update for currentState from newtonSolution (decrement from residual and jacobian); if initial, this is for the initial update with newtonSolution=0</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeODE1RHS(mainSystem)</strong> [return type = void]:</div>
<div class="line">compute the RHS of <a class="reference internal" href="../Abbreviations.html#ode1"><span class="std std-ref">ODE1</span></a> equations in systemResidual in range(0,nODE1)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ComputeODE2RHS(mainSystem)</strong> [return type = void]:</div>
<div class="line">compute the RHS of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in systemResidual in range(0,nODE2)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>DiscontinuousIteration(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform discontinuousIteration for static step / time step; CALLS ComputeNewtonResidual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinalizeSolver(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write concluding information (timer statistics, messages) and close files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>FinishStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">finish static step / time step; write output of results to file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetAEsize()</strong> [return type = Index]:</div>
<div class="line">number of algebraic equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetDataSize()</strong> [return type = Index]:</div>
<div class="line">number of data (history) variables in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetErrorString()</strong> [return type = std::string]:</div>
<div class="line">return error string if solver has not been successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetMethodOrder()</strong> [return type = Index]:</div>
<div class="line">return order of method (higher value in methods with automatic step size, e.g., DOPRI5=5)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetNumberOfStages()</strong> [return type = Index]:</div>
<div class="line">return number of stages in current method</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE1size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode1"><span class="std std-ref">ODE1</span></a> equations in solver (not yet implemented)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetODE2size()</strong> [return type = Index]:</div>
<div class="line">number of <a class="reference internal" href="../Abbreviations.html#ode2"><span class="std std-ref">ODE2</span></a> equations in solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSimulationEndTime(simulationSettings)</strong> [return type = Real]:</div>
<div class="line">compute simulation end time (depends on static or time integration solver)</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSolverName()</strong> [return type = std::string]:</div>
<div class="line">get solver name - needed for output file header and visualization window</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemMassMatrix()</strong> [return type = NumpyMatrix]:</div>
<div class="line">get locally stored / last computed mass matrix of solver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>GetSystemResidual()</strong> [return type = NumpyVector]:</div>
<div class="line">get locally stored / last computed system residual</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>HasAutomaticStepSizeControl(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">return true, if solver supports automatic stepsize control, otherwise false</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IncreaseStepSize(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">increase step size if convergence is good</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolver(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">initialize solverSpecific,data,it,conv; set/compute initial conditions (solver-specific!); initialize output files</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverData(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize all data,it,conv; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverInitialConditions(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">set/compute initial conditions (solver-specific!); called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverOutput(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize output files; called from InitializeSolver()</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeSolverPreChecks(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">check if system is solvable; initialize dense/sparse computation modes</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>InitializeStep(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">initialize static step / time step; Python-functions; do some outputs, checks, etc.</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsStaticSolver()</strong> [return type = bool]:</div>
<div class="line">return true, if static solver; needs to be overwritten in derived class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>IsVerboseCheck(level)</strong> [return type = bool]:</div>
<div class="line">return true, if file or console output is at or above the given level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>Newton(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">perform Newton method for given solver method</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PostInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">post-initialize for solver specific tasks; called at the end of InitializeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>PreInitializeSolverSpecific(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">pre-initialize for solver specific tasks; called at beginning of InitializeSolver, right after Solver data reset</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>ReduceStepSize(mainSystem, simulationSettings, severity)</strong> [return type = bool]:</div>
<div class="line">reduce step size (1..normal, 2..severe problems); return true, if reduction was successful</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemMassMatrix(systemMassMatrix)</strong> [return type = void]:</div>
<div class="line">set locally stored mass matrix of solver; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SetSystemResidual(systemResidual)</strong> [return type = void]:</div>
<div class="line">set locally stored system residual; must have size nODE2+nODE1+nAE</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSteps(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">main solver part: calls multiple InitializeStep(…)/ DiscontinuousIteration(…)/ FinishStep(…); do step reduction if necessary; return true if success, false else</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>SolveSystem(mainSystem, simulationSettings)</strong> [return type = bool]:</div>
<div class="line">solve System: InitializeSolver, SolveSteps, FinalizeSolver</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>UpdateCurrentTime(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">update currentTime (and load factor); MUST be overwritten in special solver class</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>VerboseWrite(level, str)</strong> [return type = void]:</div>
<div class="line">write to console and/or file in case of level</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteCoordinatesToFile(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique coordinates solution file</div>
</div>
</li>
<li><div class="line-block">
<div class="line"><strong>WriteSolutionFileHeader(mainSystem, simulationSettings)</strong> [return type = void]:</div>
<div class="line">write unique file header, depending on static/ dynamic simulation</div>
</div>
</li>
</ul>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="CSolverStructures.html" class="btn btn-neutral float-left" title="Solver substructures" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="PyStructuralElementsDataStructures.html" class="btn btn-neutral float-right" title="Structures for structural elements" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>